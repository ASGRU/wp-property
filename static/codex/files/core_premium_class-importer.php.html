<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>core/premium/class-importer.php - WP-Property</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="WP-Property"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.38.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/wpp.html">wpp</a></li>
            
                <li><a href="../classes/wpp.overview.html">wpp.overview</a></li>
            
                <li><a href="../classes/wpp.ui.agents.html">wpp.ui.agents</a></li>
            
                <li><a href="../classes/wpp.ui.feps.html">wpp.ui.feps</a></li>
            
                <li><a href="../classes/wpp.ui.settings.html">wpp.ui.settings</a></li>
            
                <li><a href="../classes/wpp.xmli.html">wpp.xmli</a></li>
            
                <li><a href="../classes/WPP_RETS.html">WPP_RETS</a></li>
            
                <li><a href="../classes/WPP_UI.html">WPP_UI</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: core/premium/class-importer.php</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&lt;?php
/**
 * Name: XML Property Importer
 * Class: UsabilityDynamics\WPP\Importer\Bootstrap
 * Internal Slug: property_import
 * JS Slug: wpp_property_import
 * Minimum Core Version: 1.38.3
 * Feature ID: 5
 * Version: 4.1.0
 * Description: WP-Property premium feature for automated importing of XML, CSV, JSON, Google Spreadsheet and MLS/RETS data.
 *
 */
namespace UsabilityDynamics\WPP\Importer {

  // Legacy WP-Property Support.
  if( !class_exists( &#x27;\UsabilityDynamics\WPP\Utility&#x27; ) &amp;&amp; class_exists( &#x27;\WPP_F&#x27; ) ) {
    class Utility extends \WPP_F {}
    class Module {}
  }

  // Importer Boostrap.
  if( !class_exists( &#x27;UsabilityDynamics\WPP\Importer\Bootstrap&#x27; ) ) {

    /**
     * WP-Property Premium Importer Function
     *
     * Handles XML, CSV, JSON and RETS importing;
     *
     * @version 2.33
     * @package WP-Property
     * @subpackage WP-Property XML Property Importer
     */
    class Bootstrap {

      /**
       * Module Version.
       *
       * @public
       * @static
       * @property $version
       * @type {string}
       */
      static public $version = &#x27;4.0.4&#x27;;

      /**
       * Capability to manage the current feature
       *
       * @private
       * @static
       * @property $capability
       * @type {string}
       */
      static protected $capability = &#x27;manage_wpp_import&#x27;;

      /**
       * Replace $default_rets_pk, $default_rets_query, $meta[ &#x27;rets&#x27; ][ &#x27;photo&#x27; ] and $default_resource
       *
       * @var array
       */
      public $meta = array(
        &#x27;rets&#x27; =&gt; array(
          &#x27;pk&#x27; =&gt; &#x27;ListingKey&#x27;,
          &#x27;query&#x27; =&gt; &#x27;(ListingStatus=|Active)&#x27;,
          &#x27;photo&#x27; =&gt; &#x27;Photo&#x27;,
          &#x27;resouce&#x27; =&gt; &#x27;Property&#x27;
        )
      );

      /**
       * Static request map
       */
      static protected $_request_map = array(
        &#x27;wpp_schedule_import&#x27;              =&gt; array(
          &#x27;function&#x27;    =&gt; &#x27;handle_browser_import&#x27;,
          &#x27;description&#x27; =&gt; &#x27;Running XML import schedule.&#x27;
        ),
        &#x27;wpp_manage_pending_images&#x27;        =&gt; array(
          &#x27;function&#x27;    =&gt; &#x27;manage_pending_images&#x27;,
          &#x27;description&#x27; =&gt; &#x27;Managing pending images.&#x27;
        ),
        &#x27;wpp_kill_pending_image_processes&#x27; =&gt; array(
          &#x27;function&#x27;    =&gt; &#x27;kill_pending_image_processes&#x27;,
          &#x27;description&#x27; =&gt; &#x27;Kill pending image processes.&#x27;
        ),
        &#x27;wpp_update_pending_images&#x27;        =&gt; array(
          &#x27;function&#x27;    =&gt; &#x27;update_pending_images&#x27;,
          &#x27;description&#x27; =&gt; &#x27;Updating pending images.&#x27;
        )
      );

      /**
       * Intialize Importer.
       *
       */
      public function __construct() {
        global $wpp_property_import, $wp_properties, $wpp_import_result_stats;

        define( &#x27;WPP_XMLI_Version&#x27;, self::$version );

        // Load Settings
        $wpp_property_import = self::get_settings();

        // If cron, do not load rest.
        if( defined( &#x27;DOING_WPP_CRON&#x27; ) ) {
          return;
        }

        if( current_user_can( self::$capability ) ) {
          add_action( &#x27;post_submitbox_misc_actions&#x27;, array( &amp;$this, &#x27;post_submitbox_misc_actions&#x27; ) );
          add_action( &#x27;save_post&#x27;, array( &amp;$this, &#x27;save_post&#x27; ) );
        }

        // Setup Admin.
        add_action( &#x27;admin_menu&#x27;, array( &amp;$this, &#x27;admin_menu&#x27; ) );
        add_action( &#x27;admin_init&#x27;, array( &amp;$this, &#x27;admin_init&#x27; ) );
        add_action( &#x27;admin_print_styles&#x27;, array( &amp;$this, &#x27;admin_print_styles&#x27; ) );
        add_action( &#x27;admin_enqueue_scripts&#x27;, array( &amp;$this, &#x27;admin_enqueue_scripts&#x27; ) );

        // AJAX Models and Actions.
        add_action( &#x27;wp_ajax_wpp_property_import_handler&#x27;, array( &amp;$this, &#x27;admin_ajax_handler&#x27; ) );
        add_action( &#x27;wp_ajax_wpp_xmli_status&#x27;, array( &amp;$this, &#x27;_ajax_model&#x27; ) );
        add_action( &#x27;wpp_manage_pending_images&#x27;, array( &amp;$this, &#x27;manage_pending_images&#x27; ) );
        add_action( &#x27;wpp_update_pending_images&#x27;, array( &amp;$this, &#x27;update_pending_images&#x27; ), 10, 2 );
        add_action( &#x27;wpp_post_init&#x27;, array( &amp;$this, &#x27;run_from_cron_hash&#x27; ) );

        // WP-Property Filters.
        add_filter( &#x27;wpp_admin_overview_columns&#x27;, array( &amp;$this, &#x27;wpp_admin_overview_columns&#x27; ) );
        add_filter( &#x27;wpp_stat_filter_wpp_xml_import&#x27;, array( &amp;$this, &#x27;wpp_stat_filter_wpp_xml_import&#x27; ) );
        add_filter( &#x27;wpp_capabilities&#x27;, array( &amp;$this, &quot;add_capability&quot; ) );

        // General Filters.
        add_filter( &#x27;upload_mimes&#x27;, array( &amp;$this, &#x27;add_upload_mimes&#x27; ) );
        add_filter( &#x27;admin_body_class&#x27;, array( &amp;$this, &#x27;admin_body_class&#x27; ), 10 );

        // Listen for browser-based requests
        if( count( $request = array_intersect( array_keys( self::$_request_map ), array_keys( $_REQUEST ) ) ) ) {
          $request = array_shift( $request );

          // Now, try to find the schedule
          if( empty( $request ) ) {
            self::show_400();
          }

          // Flatten the results
          self::route_static_request( $request );

        }

        // Register XML-Importer Schedule.
        $this-&gt;register_post_types();

        // Ensure Computed is available.
        if( !$wp_properties[ &#x27;_computed&#x27; ] ) {
          $wp_properties[ &#x27;_computed&#x27; ] = array();
        }

      }

      /**
       * Load XMLI Settings.
       *
       * @return mixed
       */
      public static function get_settings() {
        global $wp_properties, $wpp_property_import;

        // Get Settings from WP-Property Settings.
        if( isset( $wp_properties[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ] ) ) {
          $wpp_property_import = $wp_properties[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ];
        }

        // Load Defaults.
        if( empty( $wpp_property_import ) ) {

          $wpp_property_import[ &#x27;settings&#x27; ]  = array(
            &#x27;allow_xml_uploads_via_media_uploader&#x27; =&gt; &#x27;true&#x27;
          );

          $wpp_property_import[ &#x27;schedules&#x27; ] = false;

        }

        // Load run-time settings
        $wpp_property_import[ &#x27;post_table_columns&#x27; ] = array(
          &#x27;post_title&#x27;   =&gt; __( &#x27;Property Title&#x27;, &#x27;wpp&#x27; ),
          &#x27;post_content&#x27; =&gt; __( &#x27;Property Content&#x27;, &#x27;wpp&#x27; ),
          &#x27;post_excerpt&#x27; =&gt; __( &#x27;Property Excerpt&#x27;, &#x27;wpp&#x27; ),
          &#x27;post_status&#x27;  =&gt; __( &#x27;Property Status&#x27;, &#x27;wpp&#x27; ),
          &#x27;menu_order&#x27;   =&gt; __( &#x27;Property Order&#x27;, &#x27;wpp&#x27; ),
          &#x27;post_date&#x27;    =&gt; __( &#x27;Property Date&#x27;, &#x27;wpp&#x27; ),
          &#x27;post_author&#x27;  =&gt; __( &#x27;Property Author&#x27;, &#x27;wpp&#x27; )
        );

        return $wpp_property_import;

      }

      /**
       * Get Single Setting
       *
       * @param $key
       * @param $default
       *
       * @return null
       */
      private function get( $key, $default ) {
        return null;
      }

      /**
       * Set Setting.
       *
       * @param $key
       * @param $value
       *
       * @return null
       */
      private function set( $key, $value ) {
        return null;
      }

      /**
       * Get XMLI Models.
       *
       * @todo Add import history lookup.
       * @todo Add schedule settings lookup.
       *
       *
       * /wp-admin/admin-ajax.php?action=wpp_xmli_status
       * /wp-admin/admin-ajax.php?action=wpp_xmli_status&amp;_type=listings
       * /wp-admin/admin-ajax.php?action=wpp_xmli_status&amp;_type=media
       *
       * @since 4.0.3
       * @author potanin@UD
       */
      public function _ajax_model() {

        nocache_headers();

        switch( isset( $_REQUEST[ &#x27;_type&#x27; ] ) ? $_REQUEST[ &#x27;_type&#x27; ] : false ) {

          case &#x27;listings&#x27;:

            die( json_encode( array(
              &#x27;ok&#x27;      =&gt; false,
              &#x27;message&#x27; =&gt; __( &#x27;Returning active import schedules and listings.&#x27;, &#x27;wpp&#x27; ),
              &#x27;data&#x27;    =&gt; self::get_schedule_stats()
            ) ) );

            //wpp_import_schedule_id
            //wpp_import_time

            break;

          case &#x27;media&#x27;:

            die(json_encode(array(
              &#x27;ok&#x27;      =&gt; true,
              &#x27;message&#x27; =&gt; __( &#x27;Returning schedules with pending media processes.&#x27;, &#x27;wpp&#x27; ),
              &#x27;data&#x27;    =&gt; array(
                &#x27;stats&#x27;     =&gt; self::get_process_stats(),
                &#x27;schedules&#x27; =&gt; self::get_media_progress()
              )
            )));

          break;

          case &#x27;history&#x27;:

            $_data = array();

            $imported = $wpdb-&gt;get_results( &quot;
              SELECT post_title, post_id, meta_value FROM {$wpdb-&gt;postmeta} pm
              LEFT JOIN {$wpdb-&gt;posts} p
              ON pm.post_id = p.ID
              WHERE meta_key = &#x27;wpp_import_time&#x27;
               AND meta_value != &#x27;&#x27;
               AND post_title IS NOT NULL ORDER BY meta_value DESC LIMIT 0, 500
             &quot; );

            foreach( (array) $imported as $object ) {

              $_data[] = array(
                &#x27;id&#x27; =&gt; $object-&gt;post_id,
                &#x27;permalink&#x27; =&gt; get_permalink( $object-&gt;post_id ),
                &#x27;title&#x27; =&gt; $object-&gt;post_title,
                &#x27;edit-link&#x27; =&gt; get_edit_post_link( $object-&gt;post_id ),
                &#x27;import_time&#x27; =&gt; human_time_diff( $object-&gt;meta_value ),
              );

            }

            die(json_encode(array(
              &#x27;ok&#x27;      =&gt; true,
              &#x27;message&#x27; =&gt; __( &#x27;Returning import history.&#x27;, &#x27;wpp&#x27; ),
              &#x27;data&#x27;    =&gt; $_data
            )));

          break;

          default:

            die( json_encode( array(
              &#x27;ok&#x27;      =&gt; false,
              &#x27;message&#x27; =&gt; __( &#x27;Unknown status request.&#x27;, &#x27;wpp&#x27; )
            ) ) );

            break;

        }

      }

      /**
       * Get Media Progress
       *
       * - modified - When most recent pending listing was last modified, indication of import completion.
       * - updated - When the most revent &quot;working&quot; listing was modified, an indicator of last activity.
       *
       * @since 4.0.3
       * @author potanin@UD
       */
      public function get_media_progress( $args = array() ) {
        global $wpdb;

        $args = (object) wp_parse_args( $args, array(
          &#x27;status&#x27; =&gt; &#x27;working&#x27;
        ) );

        $_total = array();

        $_pending = $wpdb-&gt;get_results( &quot;
      SELECT
      	schedule.meta_value as schedule,
      	count( p.ID ) as pending,
      	MAX( post_modified ) as date

      FROM {$wpdb-&gt;posts} p
      	LEFT JOIN {$wpdb-&gt;postmeta} schedule ON p.ID = schedule.post_id
      	LEFT JOIN {$wpdb-&gt;postmeta} status ON p.ID = status.post_id
      	LEFT JOIN {$wpdb-&gt;postmeta} import_time ON p.ID = import_time.post_id

      WHERE
      	schedule.meta_key = &#x27;wpp_import_schedule_id&#x27; AND
      	status.meta_key = &#x27;wpp::image_status&#x27; AND
      	status.meta_value = &#x27;pending&#x27; AND
      	import_time.meta_key = &#x27;wpp_import_time&#x27;

      GROUP BY schedule
    &quot; );

        $_working = $wpdb-&gt;get_results( &quot;
      SELECT
      	schedule.meta_value as schedule,
      	count( p.ID ) as working,
        MAX( post_modified ) as date

      FROM {$wpdb-&gt;posts} p
      	LEFT JOIN {$wpdb-&gt;postmeta} schedule ON p.ID      = schedule.post_id
      	LEFT JOIN {$wpdb-&gt;postmeta} status ON p.ID        = status.post_id
      	LEFT JOIN {$wpdb-&gt;postmeta} import_time ON p.ID   = import_time.post_id

      WHERE
      	schedule.meta_key     = &#x27;wpp_import_schedule_id&#x27; AND
      	status.meta_key       = &#x27;wpp::image_status&#x27; AND
      	status.meta_value     = &#x27;working&#x27; AND
      	import_time.meta_key  = &#x27;wpp_import_time&#x27;

      GROUP BY schedule
    &quot; );

        foreach( (array) $_pending as $row ) {

          $_total[ $row-&gt;schedule ] = $_total[ $row-&gt;schedule ] ? $_total[ $row-&gt;schedule ] : array(
            &#x27;total&#x27;   =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; array( &#x27;publish&#x27;, &#x27;draft&#x27;, &#x27;trash&#x27;, &#x27;private&#x27; ) ) ) ),
            &#x27;publish&#x27; =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;publish&#x27; ) ) ),
            &#x27;pending&#x27; =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;pending&#x27; ) ) ),
            &#x27;private&#x27; =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;private&#x27; ) ) ),
            &#x27;draft&#x27;   =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;draft&#x27; ) ) ),
            &#x27;trash&#x27;   =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;trash&#x27; ) ) )
          );

          $_total[ $row-&gt;schedule ][ &#x27;pending&#x27; ] = $row-&gt;pending ? intval( $row-&gt;pending ) : 0;
          //$_total[ $row-&gt;schedule ][ &#x27;updated&#x27; ] = $row-&gt;date;
        }

        foreach( (array) $_working as $row ) {

          $_total[ $row-&gt;schedule ] = $_total[ $row-&gt;schedule ] ? $_total[ $row-&gt;schedule ] : array(
            &#x27;total&#x27;   =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; array( &#x27;publish&#x27;, &#x27;draft&#x27;, &#x27;trash&#x27;, &#x27;private&#x27; ) ) ) ),
            &#x27;publish&#x27; =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;publish&#x27; ) ) ),
            &#x27;pending&#x27; =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;pending&#x27; ) ) ),
            &#x27;private&#x27; =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;private&#x27; ) ) ),
            &#x27;draft&#x27;   =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;draft&#x27; ) ) ),
            &#x27;trash&#x27;   =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;trash&#x27; ) ) )
          );

          $_total[ $row-&gt;schedule ][ &#x27;working&#x27; ]  = $row-&gt;working ? intval( $row-&gt;working ) : 0;
          $_total[ $row-&gt;schedule ][ &#x27;modified&#x27; ] = $row-&gt;date;
          $_total[ $row-&gt;schedule ][ &#x27;listings&#x27; ] = self::get_working_listings( $row-&gt;schedule );

        }

        return (array) $_total;

      }

      /**
       * Shedule Overview Stats
       *
       * @since 4.0.3
       * @author potanin@UD
       */
      public function get_schedule_stats( $args = array() ) {
        global $wpdb;

        $args = (object) wp_parse_args( $args, array(
          &#x27;status&#x27; =&gt; &#x27;publish&#x27;
        ) );

        $_total = array();

        $_working = $wpdb-&gt;get_results( &quot;
      SELECT
      	schedule.meta_value as schedule,
      	count( p.ID ) as count

      FROM {$wpdb-&gt;posts} p
      	LEFT JOIN {$wpdb-&gt;postmeta} schedule ON p.ID = schedule.post_id
      	LEFT JOIN {$wpdb-&gt;postmeta} import_time ON p.ID = import_time.post_id

      WHERE
      	schedule.meta_key = &#x27;wpp_import_schedule_id&#x27; AND
      	import_time.meta_key = &#x27;wpp_import_time&#x27;

      GROUP BY schedule
    &quot; );

        foreach( (array) $_working as $row ) {

          $_total[ $row-&gt;schedule ] = $_total[ $row-&gt;schedule ] ? $_total[ $row-&gt;schedule ] : array(
            &#x27;schedule&#x27; =&gt; $row-&gt;schedule,
            &#x27;total&#x27;    =&gt; intval( $row-&gt;count ),
            &#x27;publish&#x27;  =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;publish&#x27; ) ) ),
            &#x27;pending&#x27;  =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;pending&#x27; ) ) ),
            &#x27;private&#x27;  =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;private&#x27; ) ) ),
            &#x27;draft&#x27;    =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;draft&#x27; ) ) ),
            &#x27;trash&#x27;    =&gt; count( self::get_schedule_listings( $row-&gt;schedule, array( &#x27;status&#x27; =&gt; &#x27;trash&#x27; ) ) ),
            &#x27;exists&#x27;   =&gt; self::get_schedule( $row-&gt;schedule ) ? true : false
          );

        }

        return (array) $_total;

      }

      /**
       * Get Listings for a Schedule
       *
       * @since 4.0.3
       * @author potanin@UD
       */
      public function get_schedule_listings( $schedule = null, $args = array() ) {
        global $wpdb;

        $args = (object) wp_parse_args( $args, array(
          &#x27;status&#x27; =&gt; array( &#x27;publish&#x27; )
        ) );

        /** First, get all the possible ids */
        $_listings = $wpdb-&gt;get_results( &quot;
      SELECT p.ID as post_id, m.meta_value as schedule_id, p.post_title, p.post_name, p.post_status
      FROM {$wpdb-&gt;posts} p LEFT JOIN {$wpdb-&gt;postmeta} m
      ON p.ID = m.post_id
      WHERE m.meta_key = &#x27;wpp_import_schedule_id&#x27; 
        AND m.meta_value = &#x27;{$schedule}&#x27;
        AND p.post_status IN ( &#x27;&quot; . implode( &quot;&#x27;, &#x27;&quot;, (array) $args-&gt;status ) . &quot;&#x27; )
    &quot; );

        return (array) $_listings;

      }

      /**
       * Get Progress Stats
       *
       * @since 4.0.3
       * @author potanin@UD
       */
      public function get_process_stats( $schedule = &#x27;&#x27; ) {
        global $wpdb;

        $_stats = array(
          &#x27;media&#x27; =&gt; array(
            &#x27;pending&#x27; =&gt; intval( $wpdb-&gt;get_var( &quot;SELECT COUNT(meta_id) FROM {$wpdb-&gt;postmeta} WHERE meta_key = &#x27;wpp::image_status&#x27; AND meta_value = &#x27;pending&#x27;; &quot; ) ),
            &#x27;working&#x27; =&gt; intval( $wpdb-&gt;get_var( &quot;SELECT COUNT(meta_id) FROM {$wpdb-&gt;postmeta} WHERE meta_key = &#x27;wpp::image_status&#x27; AND meta_value = &#x27;working&#x27;; &quot; ) )
          )
        );

        return (array) $_stats;

      }

      /**
       * Get Working Properties
       *
       * @since 4.0.3
       * @author potanin@UD
       */
      public function get_working_listings( $schedule = &#x27;&#x27; ) {
        global $wpdb;

        $_listings = $wpdb-&gt;get_results( &quot;
      SELECT
      	p.ID as id,
      	post_date as created,
      	post_modified as modified,
      	post_status as status,
      	
      	status.meta_value as media_status,
      	import_time.meta_value as import_time

      FROM {$wpdb-&gt;posts} p
      	LEFT JOIN {$wpdb-&gt;postmeta} schedule ON p.ID = schedule.post_id
      	LEFT JOIN {$wpdb-&gt;postmeta} status ON p.ID = status.post_id
      	LEFT JOIN {$wpdb-&gt;postmeta} import_time ON p.ID = import_time.post_id

      WHERE
      	schedule.meta_key = &#x27;wpp_import_schedule_id&#x27; AND
      	schedule.meta_value = &#x27;{$schedule}&#x27; AND
      	status.meta_key = &#x27;wpp::image_status&#x27; AND
      	status.meta_value = &#x27;working&#x27; AND
      	import_time.meta_key = &#x27;wpp_import_time&#x27;

    &quot; );

        return $_listings;

      }

      /**
       * Mark Working Images as Pending
       *
       * @todo Right now this kills all processes, should be schedule specific.
       * @since 4.0.3
       * @author potanin@UD
       */
      public function kill_pending_image_processes() {
        global $wpdb;

        /*
    $_pending = $wpdb-&gt;get_results(&quot;
      SELECT
      	schedule.meta_value as schedule,
      	count( p.ID ) as pending,
      	MAX( post_modified ) as date

      FROM {$wpdb-&gt;posts} p
      	LEFT JOIN {$wpdb-&gt;postmeta} schedule ON p.ID = schedule.post_id
      	LEFT JOIN {$wpdb-&gt;postmeta} status ON p.ID = status.post_id
      	LEFT JOIN {$wpdb-&gt;postmeta} import_time ON p.ID = import_time.post_id

      WHERE
      	schedule.meta_key = &#x27;wpp_import_schedule_id&#x27; AND
      	status.meta_key = &#x27;wpp::image_status&#x27; AND
      	status.meta_value = &#x27;pending&#x27; AND
      	import_time.meta_key = &#x27;wpp_import_time&#x27;

      GROUP BY schedule
    &quot;);
    */

        $_affected = $wpdb-&gt;query( &quot;UPDATE {$wpdb-&gt;postmeta} SET meta_value = &#x27;pending&#x27; WHERE meta_key = &#x27;wpp::image_status&#x27; AND meta_value = &#x27;working&#x27;; &quot; );

        if( $_GET[ &#x27;echo_log&#x27; ] ) {
          die( $_affected . &#x27; processes removed.&#x27; );
        }

        return self::get_media_progress();

      }

      /**
       * Register Post Types
       *
       * @todo Migrate jobs into core.
       *
       * @since 4.0.3
       * @author potanin@UD
       */
      public function register_post_types() {
        global $wp_post_types, $wp_rewrite, $wp;

        // Import Schedule.
        register_post_type( &#x27;_wpp_import&#x27;, array(
          &#x27;label&#x27;        =&gt; __( &#x27;Import&#x27;, &#x27;wpp&#x27; ),
          &#x27;labels&#x27;       =&gt; array(),
          &#x27;public&#x27;       =&gt; false,
          &#x27;show_ui&#x27;      =&gt; false,
          &#x27;show_in_menu&#x27; =&gt; false,
          &#x27;query_var&#x27;    =&gt; false,
          &#x27;has_archive&#x27;  =&gt; false,
          &#x27;hierarchical&#x27; =&gt; false,
          &#x27;can_export&#x27;   =&gt; true
        ) );

        // Jobs
        register_post_type( &#x27;_ud_process&#x27;, array(
          &#x27;label&#x27;        =&gt; __( &#x27;Process&#x27;, &#x27;wpp&#x27; ),
          &#x27;labels&#x27;       =&gt; array(),
          &#x27;public&#x27;       =&gt; false,
          &#x27;show_ui&#x27;      =&gt; false,
          &#x27;show_in_menu&#x27; =&gt; false,
          &#x27;query_var&#x27;    =&gt; false,
          &#x27;has_archive&#x27;  =&gt; false,
          &#x27;hierarchical&#x27; =&gt; false,
        ) );

        // Logs.
        register_post_type( &#x27;_ud_log&#x27;, array(
          &#x27;label&#x27;        =&gt; __( &#x27;Log&#x27;, &#x27;wpp&#x27; ),
          &#x27;labels&#x27;       =&gt; array(),
          &#x27;public&#x27;       =&gt; false,
          &#x27;show_ui&#x27;      =&gt; false,
          &#x27;show_in_menu&#x27; =&gt; false,
          &#x27;query_var&#x27;    =&gt; false,
          &#x27;has_archive&#x27;  =&gt; false,
          &#x27;hierarchical&#x27; =&gt; false
        ) );

        //die( &#x27;&lt;pre&gt;&#x27; . print_r( $wp_post_types, true ) . &#x27;&lt;/pre&gt;&#x27; );

      }

      /**
       * Add XMLI Import/Media Process
       *
       * ### Notes:
       * - post_name - stores unique hash for a process.
       * - post_password - stores &quot;public&quot; secret key for a process
       * - post_excerpt - stores &quot;type&quot; of process
       *
       * ### Status:
       * - working - Active process.
       * - pending - Scheduled process.
       * - complete - Complete process.
       *
       * ### Type:
       * - import - Schedule import.
       * - media - Media import.
       *
       */
      static public function add_process( $args = array() ) {

        if( !current_user_can( self::$capability ) ) {
          return new WP_Error( &#x27;Current user does not have the necessary permissions to add a process.&#x27; );
        }

        $args = (object) wp_parse_args( $args, array(
          &#x27;id&#x27;       =&gt; null,
          &#x27;type&#x27;     =&gt; &#x27;import&#x27;,
          &#x27;status&#x27;   =&gt; &#x27;working&#x27;,
          &#x27;owner&#x27;    =&gt; get_current_user_id(),
          &#x27;parent&#x27;   =&gt; 0,
          &#x27;hash&#x27;     =&gt; wp_generate_password( 16 ),
          &#x27;password&#x27; =&gt; wp_generate_password( 20 ),
          &#x27;data&#x27;     =&gt; null,
          &#x27;meta&#x27;     =&gt; null
        ) );

        if( $args-&gt;id &amp;&amp; is_wp_error( self::get_process( $args-&gt;id ) ) ) {
          $args-&gt;id = null;
        }

        // Insert Process.
        $_id = wp_insert_post( array(
          &#x27;ID&#x27;             =&gt; $args-&gt;id,
          &#x27;post_status&#x27;    =&gt; $args-&gt;status,
          &#x27;post_author&#x27;    =&gt; $args-&gt;owner,
          &#x27;post_parent&#x27;    =&gt; $args-&gt;parent,
          &#x27;post_excerpt&#x27;   =&gt; $args-&gt;type,
          &#x27;post_name&#x27;      =&gt; $args-&gt;hash,
          &#x27;post_password&#x27;  =&gt; $args-&gt;password,
          &#x27;post_content&#x27;   =&gt; $args-&gt;data ? json_encode( $args-&gt;data ) : &#x27;{}&#x27;,
          &#x27;post_title&#x27;     =&gt; sprintf( __( &#x27;Process: %1s&#x27;, &#x27;wpp&#x27; ), ucwords( $args-&gt;type ) ),
          &#x27;post_mime_type&#x27; =&gt; &#x27;application/json&#x27;,
          &#x27;post_type&#x27;      =&gt; &#x27;_ud_process&#x27;,
        ), true );

        // Failed Adding Process.
        if( is_wp_error( $_id ) ) {
          return self::fatal_error( __( &#x27;Error adding process.&#x27;, &#x27;wpp&#x27; ), $_id );
        }

        // Add Meta Data.
        foreach( (array) $args-&gt;meta as $key =&gt; $value ) {
          update_post_meta( $_id, &#x27;wpp::&#x27; . $key, $value );
        }

        // Return added process.
        return self::get_process( $_id );

      }

      /**
       * Get XMLI Import/Meida Process
       *
       * @since 4.0.3
       * @author potanin@UD
       */
      static public function get_process( $id = null, $args = array() ) {
        global $wpdb;

        if( !$id ) {
          return new WP_Error( &#x27;Can not get process without a valid ID.&#x27;, &#x27;wpp&#x27; );
        }

        if( !current_user_can( self::$capability ) ) {
          return new WP_Error( &#x27;Current user does not have the necessary permissions to get a process.&#x27;, &#x27;wpp&#x27; );
        }

        $args = wp_parse_args( $args, array(
          &#x27;format&#x27; =&gt; &#x27;object&#x27;
        ) );

        if( !$_process = get_post( $id, OBJECT ) ) {
          return new WP_Error( __( &#x27;Process not found.&#x27;, &#x27;wpp&#x27; ) );
        }

        $_meta = array();

        foreach( (array) $wpdb-&gt;get_results( $wpdb-&gt;prepare( &quot;SELECT meta_key, meta_value FROM {$wpdb-&gt;postmeta} WHERE post_id = %d&quot;, $id ), OBJECT ) as $row ) {
          $_meta[ str_replace( &#x27;wpp::&#x27;, &#x27;&#x27;, $row-&gt;meta_key ) ] = $row-&gt;meta_value;
        };

        return (object) array(
          &#x27;id&#x27;       =&gt; $_process-&gt;ID,
          &#x27;type&#x27;     =&gt; $_process-&gt;post_excerpt,
          &#x27;hash&#x27;     =&gt; $_process-&gt;post_name,
          &#x27;title&#x27;    =&gt; $_process-&gt;post_title,
          &#x27;status&#x27;   =&gt; $_process-&gt;post_status,
          &#x27;parent&#x27;   =&gt; $_process-&gt;post_parent,
          &#x27;password&#x27; =&gt; $_process-&gt;post_password,
          &#x27;owner&#x27;    =&gt; $_process-&gt;post_author,
          &#x27;date&#x27;     =&gt; strtotime( $_process-&gt;post_date ),
          &#x27;data&#x27;     =&gt; json_decode( $_process-&gt;post_content ),
          &#x27;meta&#x27;     =&gt; (object) $_meta
        );

      }

      /**
       * Get XMLI Import/Meida Process
       *
       * @since 4.0.3
       * @author potanin@UD
       */
      static public function kill_process( $id = null, $args = array() ) {

        if( !$id ) {
          return new WP_Error( &#x27;Can not kill a process without a valid ID.&#x27;, &#x27;wpp&#x27; );
        }

        if( !current_user_can( self::$capability ) ) {
          return new WP_Error( &#x27;Current user does not have the necessary permissions to add a process.&#x27;, &#x27;wpp&#x27; );
        }

        $args = wp_parse_args( $args, array(
          &#x27;force&#x27; =&gt; false
        ) );

        if( !wp_delete_post( $id ) ) {
          return self::fatal_error( __( &#x27;Could not delete process.&#x27;, &#x27;wpp&#x27; ) );
        }

        return true;

      }

      /**
       * Fatal Error, die.
       *
       * @since 4.0.3
       * @author potanin@UD
       */
      static public function fatal_error( $message, $data ) {
        wp_die( $message . print_r( $data, true ) );
        return false;
      }

      /**
       * Get Schedule Settings y ID or Hash.
       *
       * @param null $id
       *
       * @return bool|object {Object} Schedule object.@since 4.0.3
       * @author potanin@UD
       */
      static public function get_schedule( $id = null ) {
        global $wpp_property_import;

        if( !$id ) {
          return false;
        }

        // Attempt to find by ID.
        if( $wpp_property_import[ &#x27;schedules&#x27; ][ $id ] ) {
          return (object) $wpp_property_import[ &#x27;schedules&#x27; ][ $id ];
        }

        // Attempt to find by hash.
        foreach( (array) $wpp_property_import[ &#x27;schedules&#x27; ] as $_id =&gt; $_data ) {

          if( $_data[ &#x27;hash&#x27; ] === $id ) {
            return (object) $wpp_property_import[ &#x27;schedules&#x27; ][ $_id ];
          }

        }

        return false;

      }

      /**
       * Routes static request
       *
       * @since 4.0
       */
      static public function route_static_request( $request ) {
        global $wpp_property_import, $wp_properties, $wpp_import_result_stats;

        /** Find the hash */
        $to_find       = $_REQUEST[ $request ];
        $schedule_hash = false;

        /** Try to find the proper schedule */
        foreach( $wpp_property_import[ &#x27;schedules&#x27; ] as $schedule_id =&gt; $schedule ) {
          switch( true ) {
            case( $schedule_id == $to_find ):
              $schedule_hash = $schedule[ &#x27;hash&#x27; ];
              break;
            case( $schedule[ &#x27;hash&#x27; ] == $to_find ):
              $schedule_hash = $schedule[ &#x27;hash&#x27; ];
              break;
          }
          /** If we have the hash, bail out of the loop */
          if( $schedule_hash ) {
            break;
          }
        }

        /** If we didn&#x27;t find the id or hash, bail */
        if( !$schedule_hash ) {
          self::show_400();
        }

        /** We have everything we need to continue, start our try catch block */
        $output = ( isset( $_REQUEST[ &#x27;output&#x27; ] ) &amp;&amp; $_REQUEST[ &#x27;output&#x27; ] == &#x27;xml&#x27; ? &#x27;xml&#x27; : &#x27;html&#x27; );
        /** Setup general options */
        set_time_limit( 0 );
        ignore_user_abort( true );
        /** Set our buffer levels */
        if( $request == &#x27;wpp_schedule_import&#x27; ) {
          if( ob_get_level() == 0 ) {
            ob_start();
          }
        } else {
          while( ob_get_level() ) {
            ob_end_flush();
          }
          @ob_implicit_flush( true );
        }
        /** Now, show our header */
        self::header( $schedule, self::$_request_map[ $request ][ &#x27;description&#x27; ], $output );
        /** Flush the output buffer */
        ob_flush();
        try {
          /** Just call the function */
          call_user_func_array( array( self, self::$_request_map[ $request ][ &#x27;function&#x27; ] ), array( $schedule_id, $schedule ) );
        } catch( Exception $e ) {
          /** Show errors */
          self::maybe_echo_log( &#x27;There was an issue with the request: &#x27; . $e-&gt;getMessage() );
        }
        ob_flush();
        /** Now, show our footer */
        self::footer( $schedule, $output );
        /** Flush it */
        ob_flush();
        /** We gone */
        die();

      }

      /**
       * Displays our header for browser requests
       *
       * @since 4.0
       */
      static public function header( $schedule, $description, $output = &#x27;html&#x27; ) {
        if( $output == &#x27;xml&#x27; ) {
          header( &#x27;Content-type: text/xml&#x27; );
          print &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&lt;xml_import&gt;\n&quot;;
        } else {
          ?&gt;
          &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; class=&quot;graceful_death&quot;&gt;
          &lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
        &lt;title&gt;XMLI: &lt;?php echo $schedule[ &#x27;name&#x27; ]; ?&gt;&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
          html {
            height: 100%;
            background-color: #F2F2F2
          }

          body {
            background: rgba(255, 255, 255, 0.39);
            border: 10px solid rgba(227, 227, 227, 0.54);
            border-radius: 0.5em;
            color: #333333;
            font-family: Calibri, Times New Roman,serif;
            line-height: 1.5em;
            margin: 3em 5em;
            padding: 1.5em;
          }

          h1.title {
            padding: 0;
            margin: 0;
          }

          p.subtitle {
            padding: 10px 0;
            margin: 0 0 10px 0;
            border-bottom: 1px solid #dadada;
          }

          ul.summary {
            background: #E7E7E7;
            border: 1px solid #A4A4A4;
            line-height: 1.7em;
            list-style: none outside none;
            margin-top: 1em;
            padding: 10px;
          }

          span.time {
            color: #929292;
            margin-right: 8px;
          }
        &lt;/style&gt;
      &lt;/head&gt;
          &lt;body&gt;
          &lt;h1 class=&quot;title&quot;&gt;XMLI: &lt;?php echo $schedule[ &#x27;name&#x27; ]; ?&gt;&lt;/h1&gt;
          &lt;p class=&quot;subtitle&quot;&gt;&lt;?php echo $description; ?&gt;&lt;/p&gt; &lt;?php
        }
      }

      /**
       * Displays our footer for browser requests
       *
       * @since 4.0
       */
      static public function footer( $schedule, $output = &#x27;html&#x27; ) {
        global $wpp_import_result_stats;
        if( $output == &#x27;xml&#x27; ) {
          print &quot;&lt;result_stats&gt;\n&quot;;
          foreach( $wpp_import_result_stats as $row ) {
            print &quot;\t&lt;stat&gt;&quot; . $row . &quot;&lt;/stat&gt;\n&quot;;
          }
          print &quot;&lt;/result_stats&gt;\n&quot;;
          print &quot;&lt;/xml_import&gt;&quot;;
        } else {
          ?&gt;
          &lt;/body&gt;&lt;/html&gt; &lt;?php
        }
      }

      /**
       * Shows 404 page on errors
       *
       * @since 4.0
       */
      static public function show_400() {
        status_header( 400 );
        nocache_headers();
        echo &#x27;Bad request.&#x27;;
        exit;
      }

      /**
       * This is the function that handles downloading our schedule&#x27;s images.
       *
       * Basically this function will find the properties that have pending images, and then cause the processes to run which will actually
       * do the work. It will spawn {$num_worker_threads} simultaneously  that each represent 1 wp-property object, and when it
       * is done, it will then turn around and check again for any additional missing images, and reschedule itself.
       *
       * @since 4.0
       */
      public function manage_pending_images( $schedule_id, $schedule = false, $shot = 1 ) {
        global $wp_properties, $wpp_property_import, $wpdb;

        // register_shutdown_function( array( &#x27;UsabilityDynamics\WPP\Importer\Bootstrap&#x27;, &#x27;shutdown&#x27; ) );

        // If we don&#x27;t the schedule, route back to the router
        if( !$schedule ) {
          $_REQUEST[ &#x27;wpp_manage_pending_images&#x27; ] = $schedule_id;
          $_REQUEST[ &#x27;echo_log&#x27; ]                  = &#x27;true&#x27;;
          self::route_static_request( &#x27;wpp_manage_pending_images&#x27; );

          return;
        }

        /** Ok, we&#x27;re here, lets go ahead and manage those processes */
        self::maybe_echo_log( &#x27;Attempting to manage pending images for schedule #&#x27; . $schedule_id . &#x27;.&#x27; );

        /** Setup the number of threads, and my transient base */
        $num_worker_threads = isset( $schedule[ &#x27;num_worker_threads&#x27; ] ) &amp;&amp; is_numeric( $schedule[ &#x27;num_worker_threads&#x27; ] ) &amp;&amp; $schedule[ &#x27;num_worker_threads&#x27; ] ? $schedule[ &#x27;num_worker_threads&#x27; ] : 10;
        $transient_prefix   = &#x27;wpp_xlmi&#x27; . $schedule_id . &#x27;_&#x27;;

        /** First, get all the possible ids */
        $schedule_post_ids = $wpdb-&gt;get_col( &quot;
          SELECT DISTINCT post_id
          FROM {$wpdb-&gt;postmeta}
          WHERE meta_key = &#x27;wpp_import_schedule_id&#x27;
            AND meta_value = &#x27;{$schedule_id}&#x27;
        &quot;);

        if( !( is_array( $schedule_post_ids ) &amp;&amp; count( $schedule_post_ids ) ) ) {
          $schedule_post_ids = array( 0 );
        }

        //** Determine if process already runs. */
        $working_ids = $wpdb-&gt;get_col( $query = &quot;
          SELECT DISTINCT post_id
          FROM {$wpdb-&gt;postmeta}
          WHERE post_id IN ( &quot; . implode( &#x27;,&#x27;, $schedule_post_ids ) . &quot;)
            AND meta_key = &#x27;wpp::image_status&#x27;
            AND meta_value = &#x27;working&#x27;
          ORDER BY post_id ASC
        &quot; );

        //die( &#x27;&lt;pre&gt;&#x27; . print_r( $working_ids  , true ) . &#x27;&lt;/pre&gt;&#x27; );

        if( is_array( $working_ids ) &amp;&amp; count( $working_ids ) ) {
          if( $shot &gt;= 60 ) {
            throw new Exception( __( &#x27;Looks like there is an error on managing the images for this schedule. Try to re-import properties again.&#x27;, &#x27;wpp&#x27; ) );
          }
          self::maybe_echo_log( __( &#x27;Something else is currently managing the images for this schedule. Waiting 5 seconds to try to start process again.&#x27;, &#x27;wpp&#x27; ) );
          sleep( 5 );

          return self::manage_pending_images( $schedule_id, $schedule, ++$shot );
        }

        /** Now, go ahead get the highest post primary key that has already been run */
        if( !( $latest_id = get_transient( $transient_prefix . &#x27;latest_id&#x27; ) ) ) {
          /** Just make one up now */
          $latest_id = 0;
        }

        /** Now, we&#x27;re going to run that query against the DB meta */
        $query = &quot;
      SELECT DISTINCT post_id
      FROM {$wpdb-&gt;postmeta}
      WHERE post_id &gt; {$latest_id}
          AND post_id IN ( &quot; . implode( &#x27;,&#x27;, $schedule_post_ids ) . &quot; )
        AND meta_key = &#x27;wpp::image_status&#x27;
          AND meta_value = &#x27;pending&#x27;
        ORDER BY post_id ASC
        LIMIT {$num_worker_threads}
    &quot;;

        /** Now get the pending IDs we&#x27;ll need to update */
        $pending_ids = $wpdb-&gt;get_col( $query );

        if( count( $pending_ids ) ) {

          //If we have a result set, update them to be &#x27;working&#x27; status, and then update the &#x27;latest id&#x27; transient
          $wpdb-&gt;query( $query = &quot;UPDATE {$wpdb-&gt;postmeta} SET meta_value = &#x27;working&#x27; WHERE post_id IN ( &quot; . implode( &#x27;,&#x27;, $pending_ids ) . &quot; ) AND meta_key = &#x27;wpp::image_status&#x27;&quot; );

          /** Now, since we&#x27;ve done that lets loop through and schedule the tasks */
          foreach( (array) $pending_ids as $k =&gt; $id ) {
            self::maybe_echo_log( sprintf( __( &#x27;Found post, scheduling process for post #%1s with images.&#x27;, &#x27;wpp&#x27; ), $id ) );

            $args = array_filter( array(
              &#x27;wpp_update_pending_images&#x27; =&gt; $schedule_id,
              &#x27;post_id&#x27;                   =&gt; $id
            ) );

            /** Now, try to execute that thang, without scheduling */
            self::maybe_schedule_cron( &#x27;wpp_update_pending_images&#x27;, $args );
            self::maybe_run_cron( &#x27;wpp_update_pending_images&#x27;, $args, true );

          }
        } else {
          /** Otherwise, we don&#x27;t have any additional items to process, reset the &#x27;latest id&#x27; transient */
          delete_transient( $transient_prefix . &#x27;latest_id&#x27; );
        }

        /** Ok, we&#x27;re done managing processing */
        self::maybe_echo_log( &#x27;Done processing images until next run.&#x27; );

      }

      /**
       * This is the function that handles downloading our schedule&#x27;s images
       *
       * @todo Verify if this is ran for listings that don&#x27;t have any images. If not, ensure that minimum_images check is done elsewhere and disqualify listings with no/not enough images.
       * @todo Consider using wp_delete_post() to trash listings that do not meet image limit/minimum/dimensions criteria.
       *
       * @since 4.0
       */
      public function update_pending_images( $schedule_id, $schedule = false ) {
        global $wp_properties, $wpp_property_import, $wpdb;

        // If we don&#x27;t the schedule, route back to the router

        if( !is_array( $schedule ) ) {
          $_REQUEST[ &#x27;wpp_update_pending_images&#x27; ] = $schedule_id;
          $_REQUEST[ &#x27;echo_log&#x27; ]                  = &#x27;true&#x27;;
          $_REQUEST[ &#x27;post_id&#x27; ]                   = $schedule;
          self::route_static_request( &#x27;wpp_update_pending_images&#x27; );

          return;
        }

        // Get Schedule Settings.
        $_settings = self::get_schedule( $schedule_id );

        /** Get our post id from the request */
        if( !( isset( $_REQUEST[ &#x27;post_id&#x27; ] ) &amp;&amp; is_numeric( $_REQUEST[ &#x27;post_id&#x27; ] ) ) ) {
          throw new Exception( &#x27;Invalid post id.&#x27; );
        }

        $post_id = $_REQUEST[ &#x27;post_id&#x27; ];

        self::maybe_echo_log( &#x27;Attempting to update pending images for schedule #: &#x27; . $schedule_id . &#x27; and post #: &#x27; . $post_id . &#x27;.&#x27; );

        /** Ok, first get the post */
        if( !( $property = Utility::get_property( $post_id, &#x27;load_parent=false&amp;get_children=false&#x27; ) ) ) {
          throw new Exception( &#x27;Invalid property id.&#x27; );
        }

        //** Clean Up Attached Images:
        //** Get all attached images - in ascending post_date order (oldest attachments first) */
        $wp_upload_dir   = wp_upload_dir();
        $all_attachments = $wpdb-&gt;get_results( $wpdb-&gt;prepare( &quot;SELECT ID as attachment_id, post_date, post_content_filtered, guid, post_name, meta_value as _wp_attached_file FROM {$wpdb-&gt;posts} p LEFT JOIN {$wpdb-&gt;postmeta} pm ON p.ID = pm.post_id WHERE post_type = &#x27;attachment&#x27; AND post_parent = %d AND meta_key = &#x27;_wp_attached_file&#x27; ORDER BY post_date ASC &quot;, $post_id ) );

        // Cycle through all attached files, remove non-existing ones and verify md5.
        foreach( (array) $all_attachments as $key =&gt; $attached ) {

          self::keep_hope_alive();

          $all_attachments[ $key ]-&gt;full_path      = trailingslashit( $wp_upload_dir[ &#x27;basedir&#x27; ] ) . $attached-&gt;_wp_attached_file;
          $all_attachments[ $key ]-&gt;attachment_url = trailingslashit( $wp_upload_dir[ &#x27;baseurl&#x27; ] ) . $attached-&gt;_wp_attached_file;

          if( !file_exists( $all_attachments[ $key ]-&gt;full_path ) ) {
            self::maybe_echo_log( sprintf( __( &#x27;Attachment referenced in database not found on disk: (%1s), removing reference from DB.&#x27;, &#x27;wpp&#x27; ), $all_attachments[ $key ]-&gt;attachment_url ) );
            wp_delete_attachment( $attached-&gt;attachment_id );
          }
        }

        /** Get the unique key */
        $unique_id_key      = $schedule[ &#x27;unique_id&#x27; ];
        $property_unique_id = $property[ $unique_id_key ];

        /** Create a temp directory using the import ID as name */
        $image_directory = self::create_import_directory( array( &#x27;ad_hoc_temp_dir&#x27; =&gt; $schedule_id . &#x27;x&#x27; . $property_unique_id ) );

        if( $image_directory ) {
          $image_directory = $image_directory[ &#x27;ad_hoc_temp_dir&#x27; ];
        } else {
          self::maybe_echo_log( sprintf( __( &#x27;Image directory %1s could not be created.&#x27;, &#x27;wpp&#x27; ), $image_directory ) );
        }

        /** Start a new try/catch block, we have to finish off this code */
        try {
          self::keep_hope_alive();

          /** Ok, see if we&#x27;re a RETS request, versus a regular */
          if( $schedule[ &#x27;source_type&#x27; ] == &#x27;rets&#x27; ) {

            /** Setup what our image data should look like */
            $image_data = array(
              &#x27;featured-image&#x27; =&gt; array(),
              &#x27;images&#x27;         =&gt; array()
            );

            $rets_pk_value = !empty( $property[ &#x27;wpp::rets_pk&#x27; ] ) ? $property[ &#x27;wpp::rets_pk&#x27; ] : false;

            if( !$rets_pk_value ) {
              throw new Exception( __( &#x27;System (Primary) Key is not found.&#x27;, &#x27;wpp&#x27; ) );
            }

            /** Ok, first connect to RETS */
            $rets = self::connect_rets( $schedule );

            /** Determine RETS resource */
            $rets_res = !empty( $schedule[ &#x27;rets_resource&#x27; ] ) ? $schedule[ &#x27;rets_resource&#x27; ] : self::$default_rets_resource;

            /** Determine our Photo object */
            $rets_photo = !empty( $schedule[ &#x27;rets_photo&#x27; ] ) ? $schedule[ &#x27;rets_photo&#x27; ] : self::$meta[ &#x27;rets&#x27; ][ &#x27;photo&#x27; ];

            // RETS Image object query limit.
            if( $schedule[ &#x27;limit_images&#x27; ] ) {
              $limit_images = self::build_photo_number_query( $schedule[ &#x27;limit_images&#x27; ] );
            }

            /** Do our query */
            $photos = $rets-&gt;GetObject( $rets_res, $rets_photo, $rets_pk_value, $limit_images );

            /** Begin image cycle - go through every image and write it to schedule&#x27;s temp directory */
            foreach( (array) $photos as $image_count =&gt; $photo ) {
              self::keep_hope_alive();

              // Image Limit Reached.
              if( $schedule[ &#x27;limit_images&#x27; ] &amp;&amp; $image_count == $schedule[ &#x27;limit_images&#x27; ] ) {
                break;
              }

              if( !preg_match( &#x27;/^image/&#x27;, $photo[ &#x27;Content-Type&#x27; ] ) ) {
                continue;
              }

              try {

                if( !$photo[ &#x27;Data&#x27; ] ) {
                  Throw new exception( sprintf( __( &#x27;Could not save image saved image - empty file returned by server.&#x27;, &#x27;wpp&#x27; ) ) );
                }

                $filetype = preg_split( &quot;%/%&quot;, $photo[ &#x27;Content-Type&#x27; ] );
                $filename = str_replace( &#x27;\\&#x27;, &#x27;/&#x27;, $image_directory . &#x27;/&#x27; . $property_unique_id . &#x27;_&#x27; . ( $image_count + 1 ) . &#x27;.&#x27; . $filetype[ 1 ] );

                /** Write image data to file */
                @file_put_contents( $filename, $photo[ &#x27;Data&#x27; ] );

                if( is_file( $filename ) ) {
                  $this_image_size = @getimagesize( $filename );

                  //** Check if image is valid, delete if not, and log message if detail is on*/
                  if( !$this_image_size ) {
                    if( self::delete_by_path( $filename ) &amp;&amp; $schedule[ &#x27;log_detail&#x27; ] == &#x27;on&#x27; ) {
                      self::maybe_echo_log( sprintf( __( &#x27;Image %1s downloaded, but appears corrupt - deleting.&#x27;, &#x27;wpp&#x27; ), $image_count ) );
                    }
                    continue;
                  }

                  /** Ok, if we&#x27;re the first image, we&#x27;re also the featured image */
                  if( $image_count == 0 ) {
                    $image_data[ &#x27;featured-image&#x27; ][ ] = $filename;
                  } else {
                    $image_data[ &#x27;images&#x27; ][ ] = $filename;
                  }

                } else {
                  Throw new exception( &quot;Could not save image {$property_unique_id} to {$filename}. &quot; );
                }

              } catch( Exception $e ) {
                self::maybe_echo_log( $e-&gt;getMessage() );
              }

            }
          } else {

            //** Ok, we have the property object, lets see if we can abstract the images from it */
            if( ( $raw_images = ( isset( $property[ &#x27;wpp::images&#x27; ] ) ? $property[ &#x27;wpp::images&#x27; ] : false ) ) ) {
              $image_data = @json_decode( html_entity_decode( $raw_images ), 1 );
            }

            //** Set Featured Image if option &#x27;Automatically set the first image as the thumbnail&#x27; enabled and feature image is not set yet. */
            if( empty( $image_data[ &#x27;featured-image&#x27; ] ) &amp;&amp; !empty( $schedule[ &#x27;automatically_feature_first_image&#x27; ] ) &amp;&amp; !empty( $image_data[ &#x27;images&#x27; ][ 0 ] ) ) {
              $image_data[ &#x27;featured-image&#x27; ] = $image_data[ &#x27;images&#x27; ][ 0 ];
              unset( $image_data[ &#x27;images&#x27; ][ 0 ] );
            }

          }

        } catch( Exception $e ) {
          /** Don&#x27;t really do anything, except log it out */
          self::maybe_echo_log( &#x27;Oops, there was an issue: &#x27; . $e-&gt;getMessage() );
        }

        /** Ok, bail if we&#x27;re having issues */
        if( !is_array( $image_data ) ) {
          throw new Exception( &#x27;Image data could not be properly decoded.&#x27; );
        }

        /** Now, go through the images and attach them all */
        $attached_images = array();

        /** Do the featured image */
        if( isset( $image_data[ &#x27;featured-image&#x27; ] ) &amp;&amp; is_array( $image_data[ &#x27;featured-image&#x27; ] ) &amp;&amp; count( $image_data[ &#x27;featured-image&#x27; ] ) ) {
          foreach( $image_data[ &#x27;featured-image&#x27; ] as $image ) {
            self::keep_hope_alive();

            $attached_image = self::attach_image( array(
              &#x27;post_id&#x27;           =&gt; $post_id,
              &#x27;image&#x27;             =&gt; $image,
              &#x27;data&#x27;              =&gt; $property,
              &#x27;schedule_settings&#x27; =&gt; $schedule,
              &#x27;schedule_id&#x27;       =&gt; $schedule_id,
            ) );

            if( $attached_image ) {
              $attached_images[ ] = $attached_image[ &#x27;thumb_id&#x27; ];
              update_post_meta( $post_id, &#x27;_thumbnail_id&#x27;, $attached_image[ &#x27;thumb_id&#x27; ] );
              self::maybe_echo_log( &quot;Imported featured image, set featured thumbnail to {$attached_image[&#x27;thumb_id&#x27;]} for {$post_id}.&quot; );
            }

          }
        }

        if( isset( $image_data[ &#x27;images&#x27; ] ) &amp;&amp; is_array( $image_data[ &#x27;images&#x27; ] ) &amp;&amp; count( $image_data[ &#x27;images&#x27; ] ) ) {
          foreach( $image_data[ &#x27;images&#x27; ] as $image ) {
            self::keep_hope_alive();

            $attached_image = self::attach_image( array(
              &#x27;post_id&#x27;           =&gt; $post_id,
              &#x27;image&#x27;             =&gt; $image,
              &#x27;data&#x27;              =&gt; $property,
              &#x27;schedule_settings&#x27; =&gt; $schedule,
              &#x27;schedule_id&#x27;       =&gt; $schedule_id,
            ) );

            if( $attached_image ) {
              $attached_images[ ] = $attached_image[ &#x27;thumb_id&#x27; ];
              self::maybe_echo_log( &quot;Imported image with thumb {$attached_image[&#x27;thumb_id&#x27;]}.&quot; );
            }

          }
        }

        //** Automatically setup slideshows */
        if( !empty( $attached_images ) &amp;&amp; $schedule[ &#x27;automatically_load_slideshow_images&#x27; ] == &#x27;on&#x27; ) {
          update_post_meta( $post_id, &#x27;slideshow_images&#x27;, $attached_images );
          self::maybe_echo_log( &quot;Imported images have been automatically loaded to property slideshow images.&quot; );
        }

        /** So, remove the keys we no longer need, and then also publish the post */
        $post = array_filter( array(
          &#x27;ID&#x27;            =&gt; $post_id,
          &#x27;post_modified&#x27; =&gt; current_time( &#x27;mysql&#x27; )
        ) );

        /** Get rid of the rest */
        $remove_keys = array(
          &#x27;wpp::image_status&#x27;,
          &#x27;wpp::images&#x27;
        );

        foreach( $remove_keys as $key ) {
          delete_post_meta( $post_id, $key );
        }

        // Get Images.
        $_images = get_children( array(
          &#x27;post_parent&#x27;    =&gt; $post_id,
          &#x27;post_type&#x27;      =&gt; &#x27;attachment&#x27;,
          &#x27;post_mime_type&#x27; =&gt; &#x27;image&#x27;
        ) );

        // Not Enough Images.
        if( $_settings-&gt;minimum_images &amp;&amp; count( $_images ) &lt; $_settings-&gt;minimum_images ) {
          $post[ &#x27;post_status&#x27; ] = &#x27;trash&#x27;;
          update_post_meta( $post_id, &#x27;wpp::insufficient_images&#x27;, true );
        } else {
          $post[ &#x27;post_status&#x27; ] = &#x27;publish&#x27;;
          delete_post_meta( $post_id, &#x27;wpp::insufficient_images&#x27; );
          // wp_delete_post();
        }

        // Go ahead and update the property now
        wp_update_post( $post );

        // Log it
        self::maybe_echo_log( __( &#x27;Updated listing.&#x27;, &#x27;wpp&#x27; ) );

        /** Now that we&#x27;re done with all that, lets remove the temp directory */
        self::delete_by_path( $image_directory );

        /** Ok, see if we need to spawn another one */
        $working_ids = $wpdb-&gt;get_col( $query = &quot;
          SELECT DISTINCT post_id
          FROM {$wpdb-&gt;postmeta}
          WHERE post_id IN ( SELECT post_id FROM {$wpdb-&gt;postmeta} WHERE meta_key = &#x27;wpp_import_schedule_id&#x27; AND meta_value = &#x27;{$schedule_id}&#x27; )
            AND meta_key = &#x27;wpp::image_status&#x27;
            AND meta_value = &#x27;working&#x27;
          ORDER BY post_id ASC
        &quot; );

        // If we don&#x27;t have any working IDs, bail and call the &#x27;manage&#x27; process again
        if( is_array( $working_ids ) &amp;&amp; !count( $working_ids ) ) {
          self::maybe_schedule_cron( &#x27;wpp_manage_pending_images&#x27;, array( &#x27;wpp_manage_pending_images&#x27; =&gt; $schedule_id ) );
          self::maybe_run_cron( &#x27;wpp_manage_pending_images&#x27;, array( &#x27;wpp_manage_pending_images&#x27; =&gt; $schedule_id ), true, true );
        }

      }

      /**
       * Generate RETS Photo Query
       *
       * @sinde 4.0.4
       * @author potanin@UD
       */
      static public function build_photo_number_query( $limit = null ) {

        if( !$limit ) {
          return &#x27;*&#x27;;
        }

        $_query = array();
        $i      = 1;

        while( $i &lt;= $limit ) {
          $_query[ ] = $i++;

        }

        return implode( &#x27;,&#x27;, $_query );

      }

      /**
       * This function simply checks to make sure an event isn&#x27;t scheduled, before trying to add another one
       * in wp_cron, so that wp_cron will act as a failsafe for anything we might not be handling
       *
       * @since 4.0
       */
      static public function maybe_schedule_cron( $job_identifier, $args ) {

        // Schedule it for 1 second since the epoch
        if( !wp_next_scheduled( $job_identifier, (array) $args ) ) {
          wp_schedule_single_event( 1, $job_identifier, (array) $args );
        }

      }

      /**
       * This function uses wp_remote_get to cause the cron job to run immediately, and then removes
       * the job once it is successful
       *
       * @since 4.0
       */
      static public function maybe_run_cron( $job_identifier, $args, $force = false, $blocking = false ) {

        // Make sure that args is an array
        if( !is_array( $args ) ) {
          $args = array( $args );
        }

        /** Now, ensure the event is scheduled, and run */
        if( $force || wp_next_scheduled( $job_identifier, $args ) ) {

          /** Build the URL, and run the job with wp_remote_get, then remove the job from the cron queue */
          wp_unschedule_event( 1, $job_identifier, $args );

          /** Create our args */
          $url = home_url() . &#x27;/?echo_log=true&#x27;;

          foreach( $args as $key =&gt; $value ) {
            $url .= &quot;&amp;&quot; . urlencode( $key ) . &quot;=&quot; . urlencode( $value );
          }

          /** Add on our random cock blocker */
          $url .= &quot;&amp;cb=&quot; . rand();

          //** The filter below is used so that we&#x27;re not relying on Curl, as it doesn&#x27;t handle non blocking requests well */
          add_filter( &#x27;use_curl_transport&#x27;, create_function( &#x27;$value&#x27;, &#x27;return false;&#x27; ) );

          // self::maybe_echo_log( __( &#x27;Trying to call URL: &#x27; ) . $url );
          $result = wp_remote_get( $url, array( &#x27;blocking&#x27; =&gt; $blocking ) );

          if( $blocking ) {
            if( $result ) {
              self::maybe_echo_log( __( &#x27;Successfully called URL.&#x27; ) );
            } else {
              self::maybe_echo_log( __( &#x27;Could not call URL.&#x27; ) );
            }
          }

        }
      }

      /**
       * Performs the import while in browser.
       *
       */
      static public function handle_browser_import( $sch_id, $import_data ) {
        global $wpp_import_result_stats;
        //** Match found.  **/
        $_REQUEST[ &#x27;wpp_schedule_import&#x27; ] = true;
        $_REQUEST[ &#x27;schedule_id&#x27; ]         = $sch_id;
        $_REQUEST[ &#x27;wpp_action&#x27; ]          = &#x27;execute_schedule_import&#x27;;
        $_REQUEST[ &#x27;echo_log&#x27; ]            = &#x27;true&#x27;;

        //** Try to increase memory_limit if it&#x27;s less than 512M */
        $memory_limit = @ini_get( &#x27;memory_limit&#x27; );
        if( (int) $memory_limit &lt; 512 &amp;&amp; $memory_limit != &#x27;-1&#x27; ) {
          @ini_set( &#x27;memory_limit&#x27;, &#x27;512M&#x27; );
          $memory_limit = @ini_get( &#x27;memory_limit&#x27; );
        }

        self::maybe_echo_log( sprintf( __( &#x27;Starting Browser-Initiated Import: %1s. Using XML Importer %2s and WP-Property %3s.&#x27;, &#x27;wpp&#x27; ), $import_data[ &#x27;name&#x27; ], WPP_XMLI_Version, WPP_Version ) );
        self::maybe_echo_memory_usage( sprintf( __( &#x27;on process start. Memory limit: %s. Before %s&#x27;, &#x27;wpp&#x27; ), $memory_limit, &#x27;admin_ajax_handler()&#x27; ), $sch_id );
        self::admin_ajax_handler();

        $last_time_entry = self::maybe_echo_log( &quot;Total run time %s seconds.&quot;, true, true, true );

        if( $_REQUEST[ &#x27;output&#x27; ] != &#x27;xml&#x27; ) {
          echo $last_time_entry[ &#x27;message&#x27; ];
        }

        $total_processing_time = $last_time_entry[ &#x27;timetotal&#x27; ];

        if( is_array( $wpp_import_result_stats ) ) {

          $added_properties   = $wpp_import_result_stats[ &#x27;quantifiable&#x27; ][ &#x27;added_properties&#x27; ];
          $updated_properties = $wpp_import_result_stats[ &#x27;quantifiable&#x27; ][ &#x27;updated_properties&#x27; ];
          $total_properties   = $added_properties + $updated_properties;

          if( $total_properties ) {
            $time_per_property = round( ( $total_processing_time / $total_properties ), 3 );
          }

          if( $time_per_property ) {
            $wpp_import_result_stats[ ] = $last_time_entry[ &#x27;timetotal&#x27; ] . &#x27; seconds total processing time, averaging &#x27; . $time_per_property . &#x27; seconds per property.&#x27;;
          }

          unset( $wpp_import_result_stats[ &#x27;quantifiable&#x27; ] );

          $result_stats = &#x27;&lt;ul class=&quot;summary&quot;&gt;&lt;li&gt;&#x27; . implode( &#x27;&lt;/li&gt;&lt;li&gt;&#x27;, $wpp_import_result_stats ) . &#x27;&lt;/li&gt;&lt;/ul&gt;&#x27;;

          if( $_REQUEST[ &#x27;output&#x27; ] != &#x27;xml&#x27; ) {
            echo $result_stats;
          }
        }

        if( $import_data[ &#x27;send_email_updates&#x27; ] == &#x27;on&#x27; ) {
          //** Send email about import end with all data. */
          self::email_notify( $result_stats, &#x27; &#x27; . $import_data[ &#x27;name&#x27; ] . &#x27; ( #&#x27; . $sch_id . &#x27; ) is complete.&#x27; );
        }

      }

      /**
       * Adds Custom capability to the current premium feature
       *
       */
      public function add_capability( $capabilities ) {
        $capabilities[ self::$capability ] = __( &#x27;Manage XML Importer&#x27;, &#x27;wpp&#x27; );;
        return $capabilities;
      }

      /**
       * Modify body class of imported properties on back-end
       *
       */
      public function admin_body_class( $id ) {
        global $current_screen, $post;

        if( $current_screen-&gt;id == &#x27;property&#x27; ) {

          $wpp_import_schedule_id = get_post_meta( $post-&gt;ID, &#x27;wpp_import_schedule_id&#x27;, true );

          if( $wpp_import_schedule_id ) {
            return &#x27;wpp_property_edit wpp_imported_property&#x27;;
          } else {
            return &#x27;wpp_property_edit&#x27;;
          }

        }

      }

      /**
       * Save Property Hook.
       *
       * Runs on save post.
       *
       * @author peshkov@UD
       * @since 4.0
       */
      public function save_post( $post_id ) {
        if( isset( $_POST[ &#x27;wpp::disable_xmli_update&#x27; ] ) ) {
          update_post_meta( $post_id, &#x27;wpp::disable_xmli_update&#x27;, $_POST[ &#x27;wpp::disable_xmli_update&#x27; ] );
        }
      }

      /**
       * Displays information on property editing pages for properties that came from an XML Import
       *
       */
      public function post_submitbox_misc_actions( $id ) {
        global $post, $wp_properties;

        if( !$wpp_import_schedule_id = get_post_meta( $post-&gt;ID, &#x27;wpp_import_schedule_id&#x27;, true ) ) {
          return;
        }

        //** Get time stamp from new format ( Version 2.6.0+ ) */
        $import_time = get_post_meta( $post-&gt;ID, &#x27;wpp_import_time&#x27;, true );

        //** Get time stamp from old meta_key ( pre-version 2.6.0 ) if new meta_key does not exist */
        if( empty( $import_time ) ) {
          $import_time = get_post_meta( $post-&gt;ID, &#x27;wpp_xml_import&#x27;, true );
        }

        $import_url = admin_url( &quot;edit.php?post_type=property&amp;page=wpp_property_import#{$wpp_import_schedule_id}&quot; );

        $import_name = $wp_properties[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $wpp_import_schedule_id ][ &#x27;name&#x27; ];

        $disable_update = get_post_meta( $post-&gt;ID, &#x27;wpp::disable_xmli_update&#x27;, true );
        $text           = __( &#x27;Ignore updates on XMLI process&#x27;, &#x27;wpp&#x27; );

        if( !empty( $import_time ) ) {
          $import_time = date_i18n( __( &#x27;M j, Y @ G:i&#x27;, &#x27;wpp&#x27; ), strtotime( $import_time ) );
          ?&gt;
          &lt;div class=&quot;misc-pub-section xml_import_time misc-pub-section-last&quot;&gt;
        &lt;span class=&quot;wpp_i_time_stamp&quot;&gt;&lt;?php printf( __( &#x27;&lt;a href=&quot;%2$s&quot; title=&quot;%3$s&quot;&gt;Imported&lt;/a&gt;: &lt;b&gt;%1$s&lt;/b&gt;&#x27;, &#x27;wpp&#x27; ), $import_time, $import_url, $import_name ); ?&gt;&lt;/span&gt;&lt;br/&gt;
            &lt;?php echo Utility::checkbox( &quot;name=wpp::disable_xmli_update&amp;id=wpp_xmli_disable_update&amp;label=$text&quot;, $disable_update ); ?&gt;
      &lt;/div&gt;
        &lt;?php
        }

      }

      /**
       * Deletes a non empty directory, directory must end with &#x27;/&#x27;
       *
       * As of 4.0.3 can also be used to delete a file if a direct file path is passed.
       *
       * @updated 4.0.3
       */
      static public function delete_by_path( $dirname, $delete_files = false ) {

        if( is_dir( $dirname ) ) {
          $dir_handle = opendir( $dirname );
        } elseif( is_file( $dirname ) ) {
          @unlink( $dirname );

          return true;
        } else {
          return 0;
        }

        while( $file = readdir( $dir_handle ) ) {

          if( $file == &#x27;.&#x27; || $file == &#x27;..&#x27; ) {
            continue;
          }

          if( $delete_files &amp;&amp; !is_dir( trailingslashit( $dirname ) . $file ) ) {
            unlink( $dirname . &quot;/&quot; . $file );
          }

          if( is_dir( trailingslashit( $dirname ) . $file ) ) {
            self::delete_by_path( trailingslashit( $dirname ) . $file, $delete_files );
          }

        }

        if( $dir_handle ) {
          closedir( $dir_handle );
        }

        return @rmdir( $dirname );
      }

      /**
       * Get Orphan Attachments
       *
       * @updated 4.0.4
       */
      static public function get_orphan_attachments( $dirname = false ) {
        global $wpdb;

        $orphan = $wpdb-&gt;get_var( &quot;SELECT COUNT(ID) FROM {$wpdb-&gt;posts} WHERE LENGTH( post_content_filtered ) = 32 AND ( post_parent = 0 AND post_type =&#x27;attachment&#x27;)&quot; );

        return $orphan;

      }

      /**
       * Deletes a non empty directory, directory must end with &#x27;/&#x27;
       * In support of &#x27;delete_post&#x27;
       */
      static public function delete_orphan_directories( $dirname = false ) {

        if( !$dirname ) {
          $uploads = wp_upload_dir();
          $dirname = trailingslashit( $uploads[ &#x27;basedir&#x27; ] ) . &#x27;wpp_import_files&#x27;;
        }

        if( is_dir( $dirname ) ) {
          $dir_handle = opendir( $dirname );
        } else {
          return false;
        }

        while( $file = readdir( $dir_handle ) ) {
          if( $file == &quot;.&quot; || $file == &quot;..&quot; || $file == &#x27;temp&#x27; ) {
            continue;
          }

          if( is_dir( trailingslashit( $dirname ) . $file ) ) {
            self::delete_by_path( trailingslashit( $dirname ) . $file );
          }

        }

        closedir( $dir_handle );

        if( @rmdir( $dirname ) ) {
          //self::maybe_echo_log( &quot;Removed directory: {$dirname}&quot; );
          return true;
        } else {
          return false;
        }

      }

      /**
       * Adds a colum to the overview table
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc.
       */
      public function wpp_stat_filter_wpp_xml_import( $timestamp ) {
        return human_time_diff( $timestamp ) . &#x27; &#x27; . __( &#x27;ago&#x27;, &#x27;wpp&#x27; );
      }

      /**
       * Adds a colum to the overview table
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc.
       */
      public function wpp_admin_overview_columns( $columns ) {
        $columns[ &#x27;wpp_xml_import&#x27; ] = __( &#x27;Last Import&#x27;, &#x27;wpp&#x27; );

        return $columns;
      }

      /**
       * Renders Memory Usage Log if &#x27;Enable detailed logging to assist with troubleshooting&#x27; option is enabled
       *
       * @staticvar int $last_usage
       *
       * @param string   $text
       * @param bool|int $schedule_id
       *
       * @return bool
       * @since 4.0
       * @author peshkov@UD
       */
      static public function maybe_echo_memory_usage( $text = &#x27;&#x27;, $schedule_id = false ) {
        global $wp_properties;
        static $last_usage = 0;

        $schedule = false;
        if( !empty( $wp_properties[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ] ) ) {
          $schedule = $wp_properties[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ];
        }
        if( !$schedule || empty( $schedule[ &#x27;log_detail&#x27; ] ) ) {
          return false;
        }

        $differents    = $last_usage ? number_format( ( memory_get_usage() / 1024 / 1024 ) - $last_usage, 3 ) . &#x27;Mb&#x27; : __( &#x27;none&#x27;, &#x27;wpp&#x27; );
        $current_usage = number_format( $last_usage = memory_get_usage() / 1024 / 1024, 3 ) . &#x27;Mb&#x27;;
        $log           = sprintf( __( &quot;Memory Usage: %s. Difference: %s. Details: %s&quot;, &quot;wpp&quot; ), $current_usage, $differents, !empty( $text ) ? $text : __( &#x27;none&#x27;, &#x27;wpp&#x27; ) );
        $log           = &quot;&lt;span style=\&quot;color:green;\&quot;&gt;{$log}&lt;/span&gt;&quot;;
        self::maybe_echo_log( $log );
      }

      /**
       * Checks if the current view should display a log during import, or perform the import silently.
       *
       * If should be echoed, does so, unless explicitly told not to.
       * If no text is passed, returns bool
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc.
       */
      static public function maybe_echo_log( $text = false, $echo = true, $last_entry = false, $return_times = false ) {
        global $wpp_runtime_log, $wpp_import_result_stats;

        $newline = ( ( php_sapi_name() == &#x27;cli&#x27; || defined( &#x27;DOING_WPP_CRON&#x27; ) ) ? PHP_EOL : &#x27;&lt;br /&gt;&#x27; . PHP_EOL );

        if( empty( $wpp_runtime_log[ &#x27;first_entry&#x27; ] ) ) {
          $mtime                            = explode( &#x27; &#x27;, microtime() );
          $timestart                        = $mtime[ 1 ] + $mtime[ 0 ];
          $wpp_runtime_log[ &#x27;first_entry&#x27; ] = $timestart;
        }

        if( $last_entry &amp;&amp; isset( $wpp_runtime_log[ &#x27;first_entry&#x27; ] ) ) {

          $mtime     = microtime();
          $mtime     = explode( &#x27; &#x27;, $mtime );
          $timeend   = $mtime[ 1 ] + $mtime[ 0 ];
          $timetotal = $timeend - $wpp_runtime_log[ &#x27;first_entry&#x27; ];

          $timetotal = ( function_exists( &#x27;number_format_i18n&#x27; ) ) ? number_format_i18n( $timetotal, 0 ) : number_format( $timetotal, 0 );
          $text      = str_replace( &#x27;%s&#x27;, $timetotal, $text );

        }

        if( !$text ) {
          return;
        }

        /** Return time, meant for running at end of script */
        if( $return_times ) {

          if( $_REQUEST[ &#x27;output&#x27; ] == &#x27;xml&#x27; ) {
            return array(
              &#x27;timetotal&#x27; =&gt; $timetotal,
              &#x27;message&#x27;   =&gt; __( &#x27;Time: &#x27;, &#x27;wpp&#x27; ) . date( &#x27;H:i:s&#x27; ) . &#x27;: &#x27; . $text . $newline
            );
          } else {
            return array(
              &#x27;timetotal&#x27; =&gt; $timetotal,
              &#x27;message&#x27;   =&gt; &#x27;&lt;span class=&quot;time&quot;&gt;&#x27; . __( &#x27;Time: &#x27;, &#x27;wpp&#x27; ) . date( &#x27;H:i:s&#x27; ) . &#x27;:&lt;/span&gt;&#x27; . $text . $newline
            );
          }

        }

        //** Only excho when we are doing a browser-side import, and echo is enabled */
        if( count( $request = array_intersect( array_keys( self::$_request_map ), array_keys( $_REQUEST ) ) ) &amp;&amp; $_REQUEST[ &#x27;echo_log&#x27; ] == &#x27;true&#x27; ) {
          if( $text &amp;&amp; $echo ) {

            if( !isset( $_REQUEST[ &#x27;do_not_pad&#x27; ] ) ) {
              $end = str_pad( $newline, 4096 );
            } else {
              $end = $newline;
            }

            if( isset( $_REQUEST[ &#x27;output&#x27; ] ) &amp;&amp; $_REQUEST[ &#x27;output&#x27; ] == &#x27;xml&#x27; ) {
              echo &quot;&lt;entry&gt;\n&quot;;
              echo &quot;\t&lt;timestamp&gt;&quot; . time() . &quot;&lt;/timestamp&gt;\n&quot;;
              echo &quot;\t&lt;time&gt;&quot; . date( &#x27;H:i:s&#x27; ) . &quot;&lt;/time&gt;\n&quot;;
              echo &quot;\t&lt;event&gt;&quot; . $text . &quot;&lt;/event&gt;\n&quot;;
              echo &quot;&lt;/entry&gt;\n&quot;;
            } elseif( php_sapi_name() == &#x27;cli&#x27; || defined( &#x27;DOING_WPP_CRON&#x27; ) ) {
              echo __( &#x27;Time: &#x27;, &#x27;wpp&#x27; ) . date( &#x27;H:i:s&#x27; ) . $text . &#x27;&#x27; . $end;
            } else {
              echo &#x27;&lt;span class=&quot;time&quot;&gt;&#x27; . __( &#x27;Time: &#x27;, &#x27;wpp&#x27; ) . date( &#x27;H:i:s&#x27; ) . &#x27;:&lt;/span&gt;&#x27; . $text . &#x27;&#x27; . $end;
            }

            if( !isset( $_REQUEST[ &#x27;do_not_pad&#x27; ] ) ) {
              ob_flush();
              flush();
            }

          } else {
            return $echo;
          }
        }

        return false;
      }

      /**
       * Jquery ui stylesheet inint
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc.
       */
      public function admin_print_styles() {
        if( isset( $_REQUEST[ &#x27;page&#x27; ] ) &amp;&amp; $_REQUEST[ &#x27;page&#x27; ] == &#x27;wpp_property_import&#x27; &amp;&amp; file_exists( WPP_Path . &#x27;css/jquery-ui.css&#x27; ) ) {
          wp_register_style( &#x27;jquery-ui-styles&#x27;, WPP_URL . &#x27;css/jquery-ui.css&#x27; );
          wp_enqueue_style( &#x27;jquery-ui-styles&#x27; );
        }
      }

      /**
       * Hooks into &#x27;admin_init&#x27;
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
       */
      public function admin_init() {
        global $wpp_property_import, $wp_properties, $wp_messages;

        if( $wpp_property_import[ &#x27;settings&#x27; ][ &#x27;allow_xml_uploads_via_media_uploader&#x27; ] == &#x27;true&#x27; ) {
          add_filter( &#x27;upload_mimes&#x27;, array( &#x27;UsabilityDynamics\WPP\Importer\Bootstrap&#x27;, &#x27;add_upload_mimes&#x27; ) );
        }

        // Download backup of configuration
        if( isset( $_REQUEST[ &#x27;page&#x27; ] ) &amp;&amp; $_REQUEST[ &#x27;page&#x27; ] == &#x27;wpp_property_import&#x27; &amp;&amp; $_REQUEST[ &#x27;wpp_action&#x27; ] == &#x27;download-wpp-import-schedule&#x27; &amp;&amp; wp_verify_nonce( $_REQUEST[ &#x27;_wpnonce&#x27; ], &#x27;download-wpp-import-schedule&#x27; ) ) {

          $schedule_id = $_REQUEST[ &#x27;schedule_id&#x27; ];

          $schedule_data = $wp_properties[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ];

          $filename[ ] = &#x27;wpp-schedule&#x27;;
          $filename[ ] = sanitize_key( get_bloginfo( &#x27;name&#x27; ) );
          $filename[ ] = sanitize_key( $schedule_data[ &#x27;name&#x27; ] );
          $filename[ ] = date( &#x27;Y-m-d&#x27; ) . &#x27;.txt&#x27;;

          header( &quot;Cache-Control: private&quot; );
          header( &quot;Content-Description: File Transfer&quot; );
          header( &quot;Content-Disposition: attachment; filename=&quot; . implode( &#x27;-&#x27;, $filename ) );
          header( &quot;Content-Transfer-Encoding: binary&quot; );
          header( &#x27;Content-Type: text/plain; charset=&#x27; . get_option( &#x27;blog_charset&#x27; ), true );

          die( json_encode( $wp_properties[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ] ) );

          die();

        }

        //* Handle Import of schedule from an uploaded file */
        if( isset( $_REQUEST[ &#x27;page&#x27; ] ) &amp;&amp; $_REQUEST[ &#x27;page&#x27; ] == &#x27;wpp_property_import&#x27; &amp;&amp; $_REQUEST[ &#x27;wpp_action&#x27; ] == &#x27;import_wpp_schedule&#x27; &amp;&amp; wp_verify_nonce( $_REQUEST[ &#x27;_wpnonce&#x27; ], &#x27;wpp_import_import_schedule&#x27; ) ) {

          if( $backup_file = $_FILES[ &#x27;wpp_import&#x27; ][ &#x27;tmp_name&#x27; ][ &#x27;import_schedule&#x27; ] ) {

            $imported_schedule = file_get_contents( $backup_file );

            if( !empty( $imported_schedule ) ) {
              $imported_schedule = @json_decode( $imported_schedule, true );
            }

            if( is_array( $imported_schedule ) ) {

              $schedule_id = time();

              // generate new hash
              $imported_schedule[ &#x27;hash&#x27; ] = md5( sha1( $schedule_id ) );
              $imported_schedule[ &#x27;name&#x27; ] = $imported_schedule[ &#x27;name&#x27; ] . &#x27; &#x27; . __( &#x27;( Imported )&#x27;, &#x27;wpp&#x27; );

              $wp_properties[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ] = $imported_schedule;

              update_option( &#x27;wpp_settings&#x27;, $wp_properties );

              wp_redirect( admin_url( &quot;edit.php?post_type=property&amp;page=wpp_property_import&amp;message=imported&quot; ) );

            } else {
              $wp_messages[ &#x27;error&#x27; ][ ] = __( &#x27;Schedule coult not be imported.&#x27;, &#x27;wpp&#x27; );
            }

          }
        }
      }

      /**
       * Add XML/CSV/JSON mimes to allow WP Media Uploader to handle import files
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
       */
      public function add_upload_mimes( $current ) {
        global $wpp_property_import;

        $current[ &#x27;xml&#x27; ]  = &#x27;text/xml&#x27;;
        $current[ &#x27;csv&#x27; ]  = &#x27;text/csv&#x27;;
        $current[ &#x27;json&#x27; ] = &#x27;application/json&#x27;;
        $current[ &#x27;json&#x27; ] = &#x27;text/json&#x27;;

        return $current;

      }

      /**
       * Hooks into &#x27;admin_enqueue_scripts&quot;
       *
       * Loads all admin scripts.
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
       */
      public function admin_enqueue_scripts() {
        global $current_screen;

        if( isset( $current_screen-&gt;id ) &amp;&amp; $current_screen-&gt;id == &#x27;property_page_wpp_property_import&#x27; ) {
          wp_enqueue_script( &#x27;requires&#x27;, &#x27;http://cdn.udx.io/udx.requires.js&#x27; );
          wp_enqueue_script( &#x27;jquery-ui-progressbar&#x27; );
          wp_enqueue_script( &#x27;accordion&#x27; );
        }

        // wp_register_script( &#x27;wpp-xmli&#x27;, WPP_URL . &#x27;js/wpp.admin.xmli.js&#x27;, array( &#x27;jquery&#x27;, &#x27;wp-property-global&#x27; ), WPP_XMLI_Version );
        // wp_enqueue_script( &#x27;wp-property-backend-global&#x27; );
        // wp_enqueue_script( &#x27;wp-property-global&#x27; );
        // wp_enqueue_script( &#x27;wpp-xmli&#x27; );

      }

      /**
       * Add &quot;Importer&quot; Page.
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
       */
      function admin_menu() {
        global $wpp_property_import;
        $page = add_submenu_page( &#x27;edit.php?post_type=property&#x27;, __( &#x27;Importer&#x27;, &#x27;wpp&#x27; ), __( &#x27;Importer&#x27;, &#x27;wpp&#x27; ), self::$capability, &#x27;wpp_property_import&#x27;, array( $this, &#x27;page_main&#x27; ) );
        add_action( &quot;load-{$page}&quot;, array( &#x27;UsabilityDynamics\WPP\Importer\Bootstrap&#x27;, &#x27;wpp_importer_page_load&#x27; ) );
      }

      /**
       * Run cron job from hash
       *
       *
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc.
       */
      public function run_from_cron_hash() {
        global $wpp_property_import, $wpp_import_result_stats, $wp_properties;

        if( !isset( $wpp_property_import ) ) {
          $wpp_property_import = $wp_properties[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ];
        }

        if( !defined( &#x27;WPP_DEBUG_MODE&#x27; ) ) {
          define( &#x27;WPP_DEBUG_MODE&#x27;, false );
        }

        //** Cycle through schedules and try to mach. **/
        if( !empty( $wpp_property_import[ &#x27;schedules&#x27; ] ) ) /** Warning fix korotkov@ud */
          foreach( $wpp_property_import[ &#x27;schedules&#x27; ] as $sch_id =&gt; $sch ) {

            if( $sch[ &#x27;hash&#x27; ] == WPP_IMPORTER_HASH ) {

              //** Match found.  **/
              $_REQUEST[ &#x27;wpp_schedule_import&#x27; ] = true;
              $_REQUEST[ &#x27;schedule_id&#x27; ]         = $sch_id;
              $_REQUEST[ &#x27;wpp_action&#x27; ]          = &#x27;execute_schedule_import&#x27;;
              $_REQUEST[ &#x27;echo_log&#x27; ]            = ( WPP_DEBUG_MODE === true ? &#x27;true&#x27; : &#x27;false&#x27; );
              $_REQUEST[ &#x27;do_not_pad&#x27; ]          = true;
              $_REQUEST[ &#x27;do_not_flush&#x27; ]        = true;

              if( $sch[ &#x27;send_email_updates&#x27; ] == &#x27;on&#x27; ) {
                //** Send email about import start */
                /* self::email_notify( &#x27;Import has begun.&#x27;, &#x27;Schedule #&#x27;. $sch_id . &#x27; Initiated&#x27; ); */
              }

              $import_result = &#x27;&#x27;;

              //** Wrap all echoed data into ob */
              if( !WPP_DEBUG_MODE ) {
                ob_start();
              }

              self::maybe_echo_log( sprintf( __( &#x27;Starting Cron-Initiated Import: %1s. Using XML Importer %2s and WP-Property %3s.&#x27;, &#x27;wpp&#x27; ), $sch[ &#x27;name&#x27; ], WPP_XMLI_Version, WPP_Version ) );
              self::admin_ajax_handler();
              $last_time_entry = self::maybe_echo_log( &quot;Total run time %s seconds.&quot;, true, true, true );

              if( !WPP_DEBUG_MODE ) {
                $import_result .= ob_get_contents();
                ob_end_clean();
              }

              $total_processing_time = $last_time_entry[ &#x27;timetotal&#x27; ];

              if( is_array( $wpp_import_result_stats ) ) {

                $added_properties   = $wpp_import_result_stats[ &#x27;quantifiable&#x27; ][ &#x27;added_properties&#x27; ];
                $updated_properties = $wpp_import_result_stats[ &#x27;quantifiable&#x27; ][ &#x27;updated_properties&#x27; ];
                $total_properties   = $added_properties + $updated_properties;

                if( $total_properties &gt; 0 ) {
                  $time_per_property          = round( ( $total_processing_time / $total_properties ), 2 );
                  $wpp_import_result_stats[ ] = $last_time_entry[ &#x27;timetotal&#x27; ] . &#x27; seconds total processing time, averaging &#x27; . $time_per_property . &#x27; seconds per property.&#x27;;
                }

                unset( $wpp_import_result_stats[ &#x27;quantifiable&#x27; ] );

                $result_stats = &#x27;&lt;ul class=&quot;summary&quot;&gt;&lt;li&gt;&#x27; . implode( &#x27;&lt;/li&gt;&lt;li&gt;&#x27;, $wpp_import_result_stats ) . &#x27;&lt;/li&gt;&lt;/ul&gt;&#x27;;
                $cron_result  = implode( &quot;\n&quot;, $wpp_import_result_stats );

              } else {
                $cron_result = &#x27;No stats were returned by import process.&#x27;;
              }

              $import_header = $sch[ &#x27;name&#x27; ] . &#x27; ( #&#x27; . $sch_id . &#x27; ) is complete.&#x27;;

              if( $sch[ &#x27;send_email_updates&#x27; ] == &#x27;on&#x27; &amp;&amp; !empty( $import_result ) ) {
                //** Send email about import end with all data. */
                self::email_notify( $result_stats . nl2br( $import_result ), $import_header );
              } else {

              }

              //** Display on stats in the cron email. */
              if( !empty( $import_result ) ) {
                die( strtoupper( $import_header ) . &quot;\n\n&quot; . $cron_result . &quot;\n\n&quot; . $import_result );
              }

              die( &quot;\n\n&quot; . $cron_result );

            }

          }

      }

      /**
       * Importer Page Contextual Help
       *
       * @author potanin@UD
       * @updated 4.0.4
       */
      static public function wpp_importer_page_load() {

        $contextual_help = array();

        $contextual_help[ &#x27;XML Importer Help&#x27; ][ ] = &#x27;&lt;h3&gt;&#x27; . __( &quot;XML Importer Help&quot;, &quot;wpp&quot; ) . &#x27;&lt;/h3&gt;&#x27;;
        $contextual_help[ &#x27;XML Importer Help&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;By default, xPath are executed in the xPath input boxes. &lt;a target=&quot;_blank&quot; href=&quot;http://www.w3schools.com/xpath/xpath_syntax.asp&quot;&gt;W3 Schools XPath Syntax&lt;/a&gt;. &#x27;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;
        $contextual_help[ &#x27;XML Importer Help&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;Example: get all the option values that have a label for &quot;height&quot;: &lt;b&gt;options/option[label = &quot;Height&quot;]/value &lt;/b&gt;&#x27;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;

        $contextual_help[ &#x27;RETS&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;&lt;b&gt;Property Resource Class:&lt;/b&gt; Typically this is used to specify the type of property listing, such as Commercial or Residential, the naming convention varies depending on RETS provider. Use &lt;a href=&quot;http://rets.usabilitydynamics.com/&quot; target=&quot;_blank&quot;&gt;rets.usabilitydynamics.com&lt;/a&gt; to determine. &#x27;, &#x27;wpp&#x27; ) . &#x27;&lt;/p&gt;&#x27;;
        $contextual_help[ &#x27;RETS&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;&lt;b&gt;Dynamic DMQL Query Tags:&lt;/b&gt; The DMQL query for RETS supports the following dynamic tags: [this_month], [next_month] and [previous_month]. Example to get all listings modified within the current month: (DATE_MODIFIED=[this_month]+); to get all the listings modified before this month: (DATE_MODIFIED=[previous_month]-). These examples assume that the SystemName for the modified data is DATE_MODIFIED, which will actually vary from one MLS provider to the next.&lt;/p&gt;&#x27;, &#x27;wpp&#x27; );

        $contextual_help[ &#x27;XPath Query to Property Elements&#x27; ][ ] = &#x27;&lt;h3&gt;&#x27; . __( &quot;XPath Query to Property Elements&quot;, &quot;wpp&quot; ) . &#x27;&lt;/h3&gt;&#x27;;
        $contextual_help[ &#x27;XPath Query to Property Elements&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;In order to begin importing data, you must first identify what the &quot;repeating property element&quot; is in the XML file.  Typically this would be something like &lt;b&gt;property&lt;/b&gt; or &lt;b&gt;object&lt;/b&gt;, where the corresponding XPath rules would be &lt;b&gt;//property&lt;/b&gt; or &lt;b&gt;//object&lt;/b&gt;, respectively. The easiest way to identify it is to look through the feed for a repeating pattern. The query must select the elements in order to cycle through them and apply the XPath Rules in the Attribute Map section. &#x27;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;

        $contextual_help[ &#x27;Import Limits&#x27; ][ ] = &#x27;&lt;h3&gt;&#x27; . __( &#x27;Import Limits&#x27;, &quot;wpp&quot; ) . &#x27;&lt;/h3&gt;&#x27;;
        $contextual_help[ &#x27;Import Limits&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;There are two type of limits - the first limit will stop the import after a certain number of objects have been processed before they are checked for quality, while the second limit will stop only after the specified number of objects has actually passsed quality inspection, and have been saved to the database.&#x27;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;
        $contextual_help[ &#x27;Import Limits&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;Limiting imports works well when you are running incremental imports.  A limit of &lt;b&gt;10&lt;/b&gt; will stop after 10 properties have been created.  The importer does not count properties that were skipped during import or that already exist in the system - properties that already exist will be marked as updated.&#x27;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;

        $contextual_help[ &#x27;Image Limits&#x27; ][ ] = &#x27;&lt;h3&gt;&#x27; . __( &#x27;Image Limits&#x27;, &quot;wpp&quot; ) . &#x27;&lt;/h3&gt;&#x27;;
        $contextual_help[ &#x27;Image Limits&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;If a listing is imported successfully but does not meet the minimum number of images, the property status is set to  &quot;private&quot; and is not visible.&#x27;, &#x27;wpp&#x27; ) . &#x27;&lt;/p&gt;&#x27;;

        $contextual_help[ &#x27;Running the Import&#x27; ][ ] = &#x27;&lt;h3&gt;&#x27; . __( &quot;Running the Import&quot;, &quot;wpp&quot; ) . &#x27;&lt;/h3&gt;&#x27;;
        $contextual_help[ &#x27;Running the Import&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;There are two ways to process an import, using the browser, or by setting up a cron job.  Using the browser is easy, and viable when you have a small feed, or a very good server. &#x27;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;
        $contextual_help[ &#x27;Running the Import&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;When working with larger feeds, or for the purposes of automation, it is advisable to execute your import script using a cron job.  For every &quot;Import Schedule&quot; you create, a &lt;b&gt;Cron Command&lt;/b&gt; field will be displayed, followed by the command you would need to enter into the cron job builder, for the import schedule to be executed.&#x27;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;

        $contextual_help[ &#x27;Function: free_text&#x27; ][ ] = &#x27;&lt;h3&gt;&#x27; . __( &quot;Function: free_text&quot;, &quot;wpp&quot; ) . &#x27;&lt;/h3&gt;&#x27;;
        $contextual_help[ &#x27;Function: free_text&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;To insert some common text, use the &lt;b&gt;free_text&lt;/b&gt; command, like so: &lt;b&gt;free_text: Imported from Some List&lt;/b&gt; and the text will be kept as is.&#x27;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;

        $contextual_help[ &#x27;Function: uppercase&#x27; ][ ] = &#x27;&lt;h3&gt;&#x27; . __( &quot;Function: uppercase&quot;, &quot;wpp&quot; ) . &#x27;&lt;/h3&gt;&#x27;;
        $contextual_help[ &#x27;Function: uppercase&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;To convert all alphabetic characters to uppercase, use the &lt;b&gt;uppercase&lt;/b&gt; command, like so: &lt;b&gt;uppercase: {xpath}&lt;/b&gt;.&#x27;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;

        $contextual_help[ &#x27;Function: concat&#x27; ][ ] = &#x27;&lt;h3&gt;&#x27; . __( &quot;Function: concat&quot;, &quot;wpp&quot; ) . &#x27;&lt;/h3&gt;&#x27;;
        $contextual_help[ &#x27;Function: concat&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &quot;You can also combine free text wtih xPath rule results using &lt;b&gt;concat&lt;/b&gt;, example: &lt;b&gt;concat:http://sourcesite.com/images/&#x27;Photo7&#x27;&lt;/b&gt; will result in the text between the quotes being executed as xPath rules, while text outside of quotes being inserted as it is.&quot;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;
        $contextual_help[ &#x27;Function: concat&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &quot;You can also use concat to combine multiple xPath rules together, for example you can create the Property Title from a few XML attributes: &lt;b&gt;concat:&#x27;bedrooms&#x27; bedroom house in &#x27;location/city&#x27;&lt;/b&gt;&quot;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;

        $contextual_help[ &#x27;Function: concat_list&#x27; ][ ] = &#x27;&lt;h3&gt;&#x27; . __( &quot;Function: concat_list&quot;, &quot;wpp&quot; ) . &#x27;&lt;/h3&gt;&#x27;;
        $contextual_help[ &#x27;Function: concat_list&#x27; ][ ] = &#x27;&lt;p&gt;&#x27; . __( &#x27;Example: &lt;b&gt;concat_list root_path=&quot;options/option&quot; label_path=&quot;label&quot; value_path=&quot;value&quot; concat_character=&quot;:&quot; paste_together=&quot;,&quot;&lt;/b&gt;  will look for options/option path, then grab child &quot;value&quot; and &quot;label&quot; paths and import them as a single line. If &quot;paste_together&quot; specified then all collected &quot;label / value&quot; pairs will be joined in single-line value using &quot;paste_together&quot;.&#x27;, &quot;wpp&quot; ) . &#x27;&lt;/p&gt;&#x27;;

        //** Hook this action is you want to add info */
        $contextual_help = apply_filters( &#x27;wpp_importer_page_help&#x27;, $contextual_help );

        if( is_callable( array( &#x27;WPP_Core&#x27;, &#x27;wpp_contextual_help&#x27; ) ) ) {
          do_action( &#x27;wpp_contextual_help&#x27;, array( &#x27;contextual_help&#x27; =&gt; $contextual_help ) );

        } else if( is_callable( array( &#x27;WP_Screen&#x27;, &#x27;add_help_tab&#x27; ) ) ) {

          //** Loop through help items and build tabs */
          foreach( (array) $contextual_help as $help_tab_title =&gt; $help ) {

            //** Add tab with current info */
            get_current_screen()-&gt;add_help_tab( array(
              &#x27;id&#x27;      =&gt; sanitize_title( $help_tab_title ),
              &#x27;title&#x27;   =&gt; $help_tab_title,
              &#x27;content&#x27; =&gt; implode( &#x27;&#x27;, (array) $contextual_help[ $help_tab_title ] ),
            ) );

          }

        }

      }

      /**
       * Handle deleting properties that originated from a feed
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
       */
      static public function delete_feed_properties( $schedule_id, $schedule_settings, $exclude = false ) {
        global $wpdb, $wp_properties;

        if( !is_array( $exclude ) ) {
          $exclude = false;
        }

        if( $all_feed_properties = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT ID FROM {$wpdb-&gt;posts} p LEFT JOIN {$wpdb-&gt;postmeta} pm ON p.ID = pm.post_id WHERE post_type = &#x27;property&#x27; AND meta_key = &#x27;wpp_import_schedule_id&#x27; and meta_value = %s  GROUP BY p.ID&quot;, $schedule_id ) ) ) {
          $r[ &#x27;total_found&#x27; ] = count( $all_feed_properties );
          self::maybe_echo_log( sprintf( __( &#x27;Found %1s properties from database that were imported from this feed.&#x27;, &#x27;wpp&#x27; ), $r[ &#x27;total_found&#x27; ] ) );

          foreach( $all_feed_properties as $property_id ) {
            //** If an array of property IDs to exclude is passed, check if property is in array, if so - bail */
            if( $exclude &amp;&amp; in_array( $property_id, $exclude ) ) {
              continue;
            }
            //** Delete the actual object */
            if( wp_delete_post( $property_id, true ) ) {
              $r[ &#x27;deleted_objects&#x27; ][ ] = $property_id;
              if( $schedule_settings[ &#x27;log_detail&#x27; ] == &#x27;on&#x27; ) {
                self::maybe_echo_log( sprintf( __( &#x27;Property ID %1s has been deleted. Total deleted so far: %2s&#x27;, &#x27;wpp&#x27; ), $property_id, count( $r[ &#x27;deleted_objects&#x27; ] ) ) );
              }
            } else {
              //** Unable to delete property for some reason.
            }
          }

          if( is_array( $r[ &#x27;deleted_objects&#x27; ] ) ) {
            $r[ &#x27;deleted_count&#x27; ] = count( $r[ &#x27;deleted_objects&#x27; ] );
          }

          // if( $r[ &#x27;total_found&#x27; ] != $property_delete_counter ) { $r[ &#x27;remaining&#x27; ] = ( $r[ &#x27;total_found&#x27; ] - $property_delete_counter ); }

        } else {
          $r[ &#x27;total_found&#x27; ] = 0;
        }

        return $r;
      }

      /**
       * Handle all admin ajax actions
       *
       * Success or failure is returned as string &#x27;true&#x27; or &#x27;false in $return[&#x27;success&#x27;]
       * Whatever is to be displayed return in $return[&#x27;ui&#x27;]
       *
       * @todo $data and $schedule_settings seem to be used intermittently, should consolidate into one
       * @todo see if raw_preview and source_evaluation do not do some of the same functions
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
       */
      public function admin_ajax_handler( $from_cron = false ) {
        global $wpp_property_import, $wp_properties, $wpdb, $wpp_import_result_stats;

        $wpp_action        = isset( $_REQUEST[ &#x27;wpp_action&#x27; ] ) ? $_REQUEST[ &#x27;wpp_action&#x27; ] : false;
        $action_type       = isset( $_REQUEST[ &#x27;wpp_action_type&#x27; ] ) ? $_REQUEST[ &#x27;wpp_action_type&#x27; ] : false;
        $do_not_use_cache  = isset( $_REQUEST[ &#x27;do_not_use_cache&#x27; ] ) ? true : false;
        $schedule_settings = false;

        //** wpp_schedule_import is passed when an actual import is being executed, it is supposed to contain the hash.  If it does not, schedule_id should be set. */
        $wpp_schedule_import = ( !empty( $_REQUEST[ &#x27;wpp_schedule_import&#x27; ] ) ? $_REQUEST[ &#x27;wpp_schedule_import&#x27; ] : false );

        //** $schedule_id should always be passed, otherwise we will not be able to use cache. If no ID, set it to false. */
        $schedule_id = ( !empty( $_REQUEST[ &#x27;schedule_id&#x27; ] ) ? $_REQUEST[ &#x27;schedule_id&#x27; ] : false );
        $result      = array(
          &#x27;schedule_exists&#x27; =&gt; !empty( $wpp_property_import[ &#x27;schedules&#x27; ][ $schedule_id ] ) ? true : false,
          &#x27;success&#x27;         =&gt; empty( $wpp_action ) ? &#x27;false&#x27; : &#x27;true&#x27;,
        );
        $data        = !empty( $wpp_property_import[ &#x27;schedules&#x27; ][ $schedule_id ] ) ? array( &#x27;wpp_property_import&#x27; =&gt; $wpp_property_import[ &#x27;schedules&#x27; ][ $schedule_id ] ) : array();

        // Start Timer.
        $_time = microtime( true );

        //** Load the import data, this is used by CRON and Browser Access */
        if( defined( &#x27;DOING_WPP_CRON&#x27; ) || ( $wpp_schedule_import &amp;&amp; $result[ &#x27;schedule_exists&#x27; ] ) ) {
          $doing_full_import = true;
        } elseif( $wpp_action == &#x27;execute_schedule_import&#x27; &amp;&amp; !empty( $_REQUEST[ &#x27;data&#x27; ] ) ) {
          //** Entire data array is passed, this happens when a schedule is Saved or &quot;Preview Import&quot; has been initiated */
          parse_str( $_REQUEST[ &#x27;data&#x27; ], $data );
          $data = stripslashes_deep( $data );
          //** When we are running a preview on an unsaved schedule ( schedule may exist, but changes made and not commited ) - which happens a lot when testing */
          if( $_REQUEST[ &#x27;raw_preview&#x27; ] == &#x27;true&#x27; || $action_type == &#x27;source_evaluation&#x27; || $_REQUEST[ &#x27;preview&#x27; ] == &#x27;true&#x27; ) {
            $preview_import = true;
            /* Generate temporary $schedule_id for this preview ONLY if it was not passed.  We return this later so same ID is used for this session.  */
            if( !$schedule_id ) {
              $schedule_id = time();
            }
          }
        } elseif( ( $wpp_action == &#x27;save_new_schedule&#x27; || $wpp_action == &#x27;update_schedule&#x27; ) &amp;&amp; !empty( $_REQUEST[ &#x27;data&#x27; ] ) ) {
          parse_str( $_REQUEST[ &#x27;data&#x27; ], $data );
          $data = stripslashes_deep( $data );
          //** Generate plain ( internal ) hash based on current timestamp. schedule_id may already be pased though. */
          if( !$schedule_id ) {
            $schedule_id = time();
          }
        }

        //** Regardless of schedule data loaded from DB or from $_POST, if its there its stored in $data[&#x27;wpp_property_import&#x27;] */
        if( $schedule_id &amp;&amp; !empty( $data[ &#x27;wpp_property_import&#x27; ] ) ) {

          //** Load the schedule_id into $data variable for convenience */
          $data[ &#x27;schedule_id&#x27; ] = $schedule_id;

          //** $schedule_settings should be referenced from now on in this function */
          $schedule_settings = $data[ &#x27;wpp_property_import&#x27; ];

          /** @todo this may need to be fixed to get source type from memory */
          $data[ &#x27;source_type&#x27; ] = $schedule_settings[ &#x27;source_type&#x27; ];
        }

        //** If enabled, enable query tracking */
        if( !empty( $schedule_settings[ &#x27;show_sql_queries&#x27; ] ) ) {
          define( &#x27;SAVEQUERIES&#x27;, true );
        }

        //** wpp_schedule_import is set when doing import via CRON or HTTP */
        if( !$wpp_schedule_import ) {
          ob_start();
        }

        /*
      The following switch goes through various actions that can be handled, and the results are loaded into an array
      which is returned in JSON format after the switch is complete

      The following are the currently used.

      $result[ui] = whatever will be displayed, can contain HTML
      $result[success]   = true or false
      $result[data_from_cache]  = if the current data is loaded from cache
      $result[message]  = a non-HTML message
      $result[schedule_id]  = if working with a schedule, it&#x27;s ID
      $result[hash]   = hash of schedule
      $result[common_tag_name]  = used when auto-matching and WPP tries to guess the tag name
      $result[auto_matched_tags]  = used when auto-matching , returns array of found tags
    */

        //** Handle actions */
        switch( $wpp_action ) {

          case &#x27;save_new_schedule&#x27;:

            //** Not sure if this is necessary, why not use global variable? andy@UD */
            $wpp_settings = get_option( &#x27;wpp_settings&#x27; );

            /** Load data from _REQUEST data */
            $new_schedule = $schedule_settings;

            //** Assign new hash to it based on time. */
            $schedule_hash          = md5( sha1( $schedule_id ) );
            $new_schedule[ &#x27;hash&#x27; ] = $schedule_hash;

            //** Commit to DB */
            $wpp_settings[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ] = $new_schedule;
            update_option( &#x27;wpp_settings&#x27;, $wpp_settings );

            //** Add hash to return json */
            $result[ &#x27;hash&#x27; ] = $new_schedule[ &#x27;hash&#x27; ];

          break;

          case &#x27;update_schedule&#x27;:
            $upd_schedule           = $schedule_settings;
            $wpp_settings           = get_option( &#x27;wpp_settings&#x27; );
            $schedule_hash          = md5( sha1( $schedule_id ) );
            $upd_schedule[ &#x27;hash&#x27; ] = $schedule_hash;
            //** Preserve lastrun settings ( not passed via $_POST ) */
            $upd_schedule[ &#x27;lastrun&#x27; ]                                                                                 = $wpp_settings[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ][ &#x27;lastrun&#x27; ];
            $wpp_settings[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ] = $upd_schedule;
            //** Remove any messed up schedules */
            foreach( $wpp_settings[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ] as $this_id =&gt; $data ) {
              if( strlen( $this_id ) != 10 || empty( $data ) ) {
                unset( $wpp_settings[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $this_id ] );
              }
            }
            update_option( &#x27;wpp_settings&#x27;, $wpp_settings );
            break;

          case &#x27;delete_schedule&#x27;:
            if( $schedule_id ) {
              $wpp_settings = get_option( &#x27;wpp_settings&#x27; );
              unset( $wpp_settings[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ] );
              update_option( &#x27;wpp_settings&#x27;, $wpp_settings );
              $result[ &#x27;success&#x27; ] = &#x27;true&#x27;;
              $import_directory    = self::create_import_directory( array( &#x27;ad_hoc_temp_dir&#x27; =&gt; $schedule_id ) );
              if( $import_directory[ &#x27;ad_hoc_temp_dir&#x27; ] ) {
                self::delete_by_path( $import_directory[ &#x27;ad_hoc_temp_dir&#x27; ], true );
              }
            }
            break;

          case &#x27;delete_all_orphan_attachments&#x27;:

            @ini_set( &#x27;memory_limit&#x27;, &#x27;512M&#x27; );
            set_time_limit( 0 );
            ignore_user_abort( true );

            // Will not catch fatal errors
            // set_error_handler(function( $err_severity, $err_msg ) { echo( &#x27;&lt;pre&gt;error_handler: &#x27; . $err_severity . &#x27;: &#x27; . $err_msg . &#x27;&lt;/pre&gt;&#x27; ); }, E_ERROR | E_USER_ERROR | E_CORE_ERROR | E_COMPILE_ERROR | E_RECOVERABLE_ERROR );

            register_shutdown_function( function () {
              // wp_schedule_single_event( time() + 3600, &#x27;hourly&#x27;, &#x27;my_shutdown_event&#x27; );

              $_error = error_get_last();

              if( $_error &amp;&amp; in_array( $_error[ &#x27;type&#x27; ], array( 1, 4, 16, 64 ) ) ) {
                wp_die( &#x27;&lt;pre&gt;delete_all_orphan_attachments: &#x27; . print_r( $_error, true ) . &#x27;&lt;/pre&gt;&#x27; );
              }

            } );

            $_result = array();

            foreach( (array) $wpdb-&gt;get_col( &quot;SELECT ID FROM {$wpdb-&gt;posts} WHERE LENGTH( post_content_filtered ) = 32 AND ( post_parent = 0 AND post_type =&#x27;attachment&#x27; ) LIMIT 0, 10000;&quot; ) as $orphan_image_id ) {

              if( wp_delete_attachment( $orphan_image_id, true ) ) {
                $_result[ ] = $orphan_image_id;
              }

            }

            if( is_array( $_result ) &amp;&amp; count( $_result ) &gt; 0 ) {
              self::delete_orphan_directories();
              $result[ &#x27;ok&#x27; ]      = true;
              $result[ &#x27;message&#x27; ] = sprintf( __( &#x27;Deleted %1s unattached property files that were created from an XML import.&#x27;, &#x27;wpp&#x27; ), count( $_result ) );
            } else {
              $result[ &#x27;ok&#x27; ]      = false;
              $result[ &#x27;message&#x27; ] = __( &#x27;Something went wrong, did not delete any unattached images.&#x27;, &#x27;wpp&#x27; );
            }

            //die( &#x27;&lt;pre&gt;&#x27; . print_r( $result, true ) . &#x27;&lt;/pre&gt;&#x27; );        

            break;

          case &#x27;delete_all_schedule_properties&#x27;:
            if( $schedule_id ) {
              set_time_limit( 0 );
              ignore_user_abort( true );
              $deleted_count  = array();

              $all_properties = $wpdb-&gt;get_col( $wpdb-&gt;prepare( &quot;SELECT ID FROM {$wpdb-&gt;posts} p LEFT JOIN {$wpdb-&gt;postmeta} pm ON p.ID = pm.post_id WHERE post_type = &#x27;property&#x27; AND meta_key = &#x27;wpp_import_schedule_id&#x27; and meta_value = %s  GROUP BY p.ID&quot;, $schedule_id ) );

              if( $all_properties ) {
                $operation_start = time();

                foreach( (array) $all_properties as $property_id ) {
                  if( wp_delete_post( $property_id, true ) ) {
                    $deleted_count[ ] = true;
                  }
                }

                $operation_length = Utility::format_numeric( time() - $operation_start );

                $deleted_count    = array_sum( $deleted_count );
                //** Remove last run stats from schedule */
                $wpp_settings  = get_option( &#x27;wpp_settings&#x27; );

                $this_schedule = $wpp_settings[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ];

                unset( $this_schedule[ &#x27;lastrun&#x27; ] );

                $wpp_settings[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ] = $this_schedule;

                update_option( &#x27;wpp_settings&#x27;, $wpp_settings );

                if( $deleted_count == count( $all_properties ) ) {
                  $result[ &#x27;ui&#x27; ] = sprintf( __( &#x27;All %1$s properties have been deleted in %2$s seconds.&#x27;, &#x27;wpp&#x27; ), $deleted_count, $operation_length );
                } else {
                  $result[ &#x27;ui&#x27; ] = sprintf( __( &#x27;Although %1$s properties were found, only %2$s have been deleted in %3$s seconds.&#x27;, &#x27;wpp&#x27; ), count( $all_properties ), $deleted_count, $operation_length );
                }

                $all_properties = null;

              } else {
                $result[ &#x27;ui&#x27; ] = __( &#x27;Something went wrong, no properties were found to delete.&#x27;, &#x27;wpp&#x27; );
              }
              $result[ &#x27;success&#x27; ] = &#x27;true&#x27;;
            }
            break;

          case &#x27;execute_schedule_import&#x27;:
            //** Not the most elegant solution, but some of these imports can take a while. Using cron is advised. */
            set_time_limit( 0 );
            @ini_set( &#x27;zlib.output_compression&#x27;, 0 );
            @ini_set( &#x27;implicit_flush&#x27;, 1 );
            @ob_implicit_flush( 1 );

            //** Try to increase memory_limit if it&#x27;s less than 512M */
            $memory_limit = @ini_get( &#x27;memory_limit&#x27; );
            if( (int) $memory_limit &lt; 512 &amp;&amp; $memory_limit != &#x27;-1&#x27; ) {
              @ini_set( &#x27;memory_limit&#x27;, &#x27;512M&#x27; );
            }

            self::maybe_echo_log( str_pad( &quot;Started loading XML from source.&quot;, 4096 ) );

            //** For now do not cache live source full imports */
            if( $doing_full_import || $data[ &#x27;source_type&#x27; ] == &#x27;rets&#x27; || $do_not_use_cache ) {
              //** Do not use cache data when doing full RETS import */
              $result[ &#x27;data_from_cache&#x27; ] = false;
            } else {

              //** Try to get source from cache if it exists.  If found, returned as SimpleXMLElement */
              $cached_data = self::get_cached_source( $schedule_id, $data[ &#x27;source_type&#x27; ] );

              if( !empty( $cached_data ) ) {
                $cache_age = time() - $cached_data[ &#x27;time&#x27; ];
                //** If cached file is over 30 minutes old, we do not use it */
                if( $cache_age &gt; 1800 ) {
                  $cached_data = false;
                  self::maybe_echo_log( &quot;Cached file is too old, data not used.&quot; );
                } else {
                  self::maybe_echo_log( &quot;Using data in cached file.&quot; );
                }
              }

            }

            $xml_data = &#x27;&#x27;;

            if( isset( $cached_data ) &amp;&amp; !empty( $cached_data ) ) {
              $xml_data = $cached_data[ &#x27;xml_data&#x27; ];
              //** Loaded from cache */
              $result[ &#x27;data_from_cache&#x27; ] = true;
              self::maybe_echo_log( &quot;Raw feed data loaded from cache.&quot; );
            } else {
              //** Set custom post type for URL queries that need to pass credentials via post */
              $request_method = !empty( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;postauth&#x27; ] ) ? &#x27;post&#x27; : &#x27;get&#x27;;
              //** Try to open the provided file, if RETS feed, data converted into XML and images are downloaded. If source eval, RETS only gets first result. */
              self::maybe_echo_memory_usage( sprintf( __( &#x27;before %s&#x27;, &#x27;wpp&#x27; ), &#x27;wpp_make_request()&#x27; ), $schedule_id );
              $response = self::wpp_make_request( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;url&#x27; ], $request_method, $data );
              self::maybe_echo_memory_usage( sprintf( __( &#x27;after %s&#x27;, &#x27;wpp&#x27; ), &#x27;wpp_make_request()&#x27; ), $schedule_id );
              self::maybe_echo_log( &quot;Raw feed data loaded from live source.&quot; );
              $result[ &#x27;data_from_cache&#x27; ] = false;
              //** If error object returned, keep processing, it will be echoed later */
              if( !is_wp_error( $response ) &amp;&amp; !empty( $response[ &#x27;body&#x27; ] ) ) {
                //** If response exists load the raw contents into a variable. */
                $xml_data = $response[ &#x27;body&#x27; ];
              }
            }

            self::maybe_echo_memory_usage( __( &#x27;before XML object initialization from response (string)&#x27;, &#x27;wpp&#x27; ), $schedule_id );
            //* Remove namespaces since there is little support for them */
            $xml_data = str_replace( &#x27;xmlns=&#x27;, &#x27;nothing=&#x27;, $xml_data );
            $xml      = @simplexml_load_string( $xml_data, &#x27;SimpleXMLElement&#x27;, LIBXML_NOCDATA );
            self::maybe_echo_memory_usage( __( &#x27;after XML object initialization&#x27;, &#x27;wpp&#x27; ), $schedule_id );

            //** Main function where we load the XML data and convert into object */
            if( !empty( $xml ) ) {
              self::maybe_echo_log( &quot;XML Object loaded successfully from raw data.&quot; );
              //** Create temp folder and images. */
              if( $schedule_temp_path = self::create_import_directory( array( &#x27;ad_hoc_temp_dir&#x27; =&gt; $schedule_id ) ) ) {
                self::maybe_echo_log( sprintf( __( &#x27;Created temporary directory for import: %1$s.&#x27;, &#x27;wpp&#x27; ), $schedule_temp_path[ &#x27;ad_hoc_temp_dir&#x27; ] ) );
                $data[ &#x27;temporary_directory&#x27; ] = $schedule_temp_path[ &#x27;ad_hoc_temp_dir&#x27; ];
                //** Determine cache file name */
                if( $data[ &#x27;source_type&#x27; ] ) {
                  $cache_file_name = $data[ &#x27;source_type&#x27; ] . &#x27;_cache.xml&#x27;;
                } else {
                  $cache_file_name = &#x27;cache.xml&#x27;; /* This should not realy happen */
                }
                $cache_file = $data[ &#x27;temporary_directory&#x27; ] . &#x27;/&#x27; . $cache_file_name;
                //** Cache the source */
                if( file_put_contents( $cache_file, $xml_data ) ) {
                  $xml_file_size         = self::format_size( filesize( $cache_file ) );
                  $result[ &#x27;file_size&#x27; ] = $xml_file_size;
                  self::maybe_echo_log( &quot;XML data ( {$xml_file_size} ), loaded from source, cached in: &quot; . $cache_file );
                  $cache_file_url = $schedule_temp_path[ &#x27;ad_hoc_temp_url&#x27; ] . &#x27;/&#x27; . $cache_file_name;
                } else {
                  self::maybe_echo_log( &#x27;Unable to to create cache of source into temorary directory: &#x27; . $data[ &#x27;temporary_directory&#x27; ] );
                }
              }
              //** All good to go, we can proceed with cycles */
              $process_import = true;
            } else {
              if( is_wp_error( $response ) ) {
                $mes = sprintf( __( &#x27;Could not load XML Object from raw data: %1s.&#x27;, &#x27;wpp&#x27; ), $response-&gt;get_error_message() );
              } elseif( empty( $xml ) &amp;&amp; $xml !== false ) {
                $mes = __( &#x27;Could not load XML Object from raw data - empty result returned. Check your settings.&#x27;, &#x27;wpp&#x27; );
              } else {
                $mes = __( &#x27;Could not load XML Object from raw data. Looks like data has errors and can not be converted to XML Object.&#x27;, &#x27;wpp&#x27; );
              }
              self::maybe_echo_log( $mes );
              $result[ &#x27;success&#x27; ] = &#x27;false&#x27;;
              $result[ &#x27;message&#x27; ] = $mes;
              break; /* break throws the logic to the end of the $wpp_action function, and returns all $result data */
            }

            $root_element_xpath = $data[ &#x27;wpp_property_import&#x27; ][ &#x27;root_element&#x27; ];

            self::maybe_echo_memory_usage( __( &#x27;before getting the list of XML objects (listings)&#x27;, &#x27;wpp&#x27; ), $schedule_id );

            //** If no root element xpath passed, we return the raw data */
            if( !empty( $root_element_xpath ) ) {
              $objects = @$xml-&gt;xpath( $root_element_xpath );
            } else {
              $objects            = $xml;
              $root_element_xpath = false;
            }

            self::maybe_echo_memory_usage( __( &#x27;after getting the list of XML objects (listings)&#x27;, &#x27;wpp&#x27; ), $schedule_id );

            if( $wpp_schedule_import ) {
              if( $objects ) {
                self::maybe_echo_log( &quot;Extracted &quot; . count( $objects ) . &quot; total objects from the repeating property elements query.&quot; );
              } else {
                self::maybe_echo_log( &quot;Failed to extract any objects from the repeating property elements query. Quitting.&quot; );

                return;
              }
            }

            //** Handle raw preview or no objects. */
            if( !$objects || ( isset( $_REQUEST[ &#x27;raw_preview&#x27; ] ) &amp;&amp; $_REQUEST[ &#x27;raw_preview&#x27; ] == &#x27;true&#x27; ) ) {
              if( $result[ &#x27;data_from_cache&#x27; ] ) {
                $result[ &#x27;ui&#x27; ] .= __( &#x27;Data loaded from cache.&#x27;, &#x27;wpp&#x27; ) . &quot;\n\n&quot;;
              }

              if( $root_element_xpath ) {
                if( $objects ) {
                  $result[ &#x27;ui&#x27; ] .= count( $objects ) . __( &#x27; object(s) found with XPath Rule: &#x27;, &#x27;wpp&#x27; ) . $root_element_xpath . &quot;\n\n&quot;;
                  $result[ &#x27;preview_bar_message&#x27; ] = sprintf( __( &#x27;%1s objects identified: &lt;a href=&quot;%2s&quot; target=&quot;_blank&quot;&gt;download processed XML file&lt;/a&gt; ( %3s ).&#x27;, &#x27;wpp&#x27; ), count( $objects ), $cache_file_url, $result[ &#x27;file_size&#x27; ] );
                } else {
                  $result[ &#x27;ui&#x27; ] .= __( &#x27;Root Element XPath Rule: &#x27;, &#x27;wpp&#x27; ) . $root_element_xpath . &quot;\n\n&quot;;
                }
              } else {
                $result[ &#x27;ui&#x27; ] .= __( &#x27;No Root Element XPath Rule, displaying most root elements.&#x27;, &#x27;wpp&#x27; ) . &quot;\n\n&quot;;
              }

              if( !$objects ) {
                $result[ &#x27;ui&#x27; ] .= __( &#x27;No objects found.&#x27;, &#x27;wpp&#x27; ) . &quot;\n\n&quot;;
              } else {

                //** Analayze data, always - shouldn&#x27;t take too long once its loaded. */
                if( $auto_matched_tags = self::analyze_feed( $xml, $data[ &#x27;wpp_property_import&#x27; ][ &#x27;root_element&#x27; ] ) ) {
                  $result[ &#x27;auto_matched_tags&#x27; ] = $auto_matched_tags;
                }

                $truncate_limit = 50000;

                $total_length   = strlen( print_r( $objects, true ) );
                if( $total_length &gt; $truncate_limit ) {
                  $result[ &#x27;ui&#x27; ] .= sprintf( __( &#x27;Preview truncated: showing: %1s of full feed:&#x27;, &#x27;wpp&#x27; ), ( round( ( $truncate_limit / $total_length ), 4 ) * 100 ) . &#x27;%&#x27; ) . &quot;\n\n&quot;;
                }

                $result[ &#x27;ui&#x27; ] .= htmlentities( substr( print_r( $objects, true ), 0, $truncate_limit ) );
                $result[ &#x27;ui&#x27; ] .= &quot;\n\n\n&quot; . sprintf( __( &#x27;Available tags in source: %1s&#x27;, &#x27;wpp&#x27; ), &quot;\n\n&quot; . print_r( $result[ &#x27;auto_matched_tags&#x27; ], true ) ) . &quot;\n\n&quot;;
                $result[ &#x27;success&#x27; ] = &#x27;true&#x27;;
              }

              //** Blank out auto matched tags */
              /* $result[&#x27;auto_matched_tags&#x27;] = &#x27;none&#x27;; */
              break; /* break throws the logic to the end of the $wpp_action function, and returns all $result data */
            }

            unset( $xml );

            //** Load schedule data from DB, if it isn&#x27;t already loaded, such as by a preview. */
            if( !$schedule_settings ) {
              $schedule_settings = $wp_properties[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ];
            }

            //** Build array of slugs that may have multiple values */
            $allow_multiple = array( &#x27;images&#x27; );

            foreach( (array) $wp_properties[ &#x27;taxonomies&#x27; ] as $slug =&gt; $tax ) {
              $allow_multiple[ ] = $slug;
            }
            $allow_multiple = apply_filters( &#x27;wpp_import_attributes_allow_multiple&#x27;, $allow_multiple );

            //** Stop here if we are only evaluating, and return tags */
            if( isset( $action_type ) &amp;&amp; $action_type == &#x27;source_evaluation&#x27; ) {
              //$result[ &#x27;common_tag_name&#x27; ] = &#x27;property&#x27;;
              $result[ &#x27;success&#x27; ]         = &#x27;true&#x27;;
              break; /* break throws the logic to the end of the $wpp_action function, and returns all $result data */
            }
            /** End source_evaluation */

            //** Add certain rules automatically */
            if( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;source_type&#x27; ] == &#x27;wpp&#x27; ) {
              //** Add parent GPID */
              array_push( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;map&#x27; ], array(
                &#x27;wpp_attribute&#x27; =&gt; &#x27;parent_gpid&#x27;,
                &#x27;xpath_rule&#x27;    =&gt; &#x27;parent_gpid&#x27;
              ) );
            } elseif( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;source_type&#x27; ] == &#x27;rets&#x27; ) {
              //** Add System (Primary) key field */
              array_push( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;map&#x27; ], array(
                &#x27;wpp_attribute&#x27; =&gt; &#x27;wpp::rets_pk&#x27;,
                &#x27;xpath_rule&#x27;    =&gt; $data[ &#x27;wpp_property_import&#x27; ][ &#x27;rets_pk&#x27; ]
              ) );
            }

            $wpp_import_result_stats[ ] = &quot;Extracted &quot; . count( $objects ) . &quot; total objects from the repeating property elements query.&quot;;

            //** Cycle through individual objects and load queried information into $import_data array; */
            if( $objects &amp;&amp; $schedule_settings[ &#x27;log_detail&#x27; ] == &#x27;on&#x27; ) {
              self::maybe_echo_log( &quot;Beginning object cycle.&quot; );
            }

            self::maybe_echo_memory_usage( __( &#x27;before parsing the list of XML objects (listings)&#x27;, &#x27;wpp&#x27; ), $schedule_id );
            $counter = 0;

            foreach( (array) $objects as $import_object ) {

              $import_data[ $counter ] = array();

              //** Process every rule and run query against the object */
              foreach( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;map&#x27; ] as $rule ) {

                $return         = null;
                $rule_attribute = $rule[ &#x27;wpp_attribute&#x27; ];
                $xpath_rule     = stripslashes( $rule[ &#x27;xpath_rule&#x27; ] );
                $conditions     = array();

                if( empty( $xpath_rule ) ) {
                  continue;
                }

                if( strpos( $xpath_rule, &#x27;free_text:&#x27; ) !== false ) {

                  //* Handle plain text */
                  $import_data[ $counter ][ $rule_attribute ][ ] = trim( str_replace( &#x27;free_text:&#x27;, &#x27;&#x27;, $xpath_rule ) );

                } elseif( strpos( $xpath_rule, &#x27;uppercase:&#x27; ) !== false ) {

                  $xpath_rule = trim( trim( trim( str_replace( &#x27;uppercase:&#x27;, &#x27;&#x27;, $xpath_rule ) ), &quot;&#x27;&quot; ), &#x27;&quot;&#x27; );
                  //* Handle regular xpath */
                  $return                    = @$import_object-&gt;xpath( $xpath_rule );
                  $conditions[ &#x27;uppercase&#x27; ] = true;

                } elseif( strpos( $xpath_rule, &#x27;concat_list&#x27; ) !== false ) {
                  //* Import label/value pairs for non-existant meta_keys   */

                  //** Breaks xpath rule into array */
                  $xpath_atts = shortcode_parse_atts( $xpath_rule, array() );

                  //* Get Root Path */
                  $concat_results = @$import_object-&gt;xpath( $xpath_atts[ &#x27;root_path&#x27; ] );
                  if( is_array( $concat_results ) ) {
                    foreach( $concat_results as $single_result ) {
                      $label                                         = ( $xpath_atts[ &#x27;label_path&#x27; ] ) ? @$single_result-&gt;xpath( $xpath_atts[ &#x27;label_path&#x27; ] ) : array();
                      $label                                         = trim( ( string ) $label[ 0 ] );
                      $value                                         = ( $xpath_atts[ &#x27;value_path&#x27; ] ) ? @$single_result-&gt;xpath( $xpath_atts[ &#x27;value_path&#x27; ] ) : array();
                      $value                                         = trim( ( string ) $value[ 0 ] );
                      $value                                         = self::format_single_value( array( &#x27;value&#x27; =&gt; $value, &#x27;rule_attribute&#x27; =&gt; $rule_attribute, &#x27;schedule_settings&#x27; =&gt; $schedule_settings ) );
                      $import_data[ $counter ][ $rule_attribute ][ ] = $label . ( !empty( $label ) &amp;&amp; !empty( $value ) ? $xpath_atts[ &#x27;concat_character&#x27; ] : &#x27;&#x27; ) . $value;
                    }
                    if( !empty( $xpath_atts[ &#x27;paste_together&#x27; ] ) ) {
                      $import_data[ $counter ][ $rule_attribute ] = (array) implode( $xpath_atts[ &#x27;paste_together&#x27; ], (array) $import_data[ $counter ][ $rule_attribute ] );
                    }
                  }
                  $concat_results = null;
                  continue;

                } elseif( strpos( $xpath_rule, &#x27;concat:&#x27; ) !== false ) {

                  //* concat: &#x27;expression one&#x27; some text &#x27;expression two&#x27;  */
                  $xpath_rule  = str_replace( &#x27;concat:&#x27;, &#x27;&#x27;, $xpath_rule );
                  $num_matched = preg_match_all( &quot;/&#x27;([^&#x27;]*)&#x27;/&quot;, $xpath_rule, $matches, PREG_SET_ORDER );

                  //* concat matches found  */
                  if( $matches ) {
                    $to_concat = array();
                    foreach( $matches as $match_rule ) {
                      //* get the requeted attributes from concat list and load into temporary array*/
                      $concat_results = @$import_object-&gt;xpath( $match_rule[ 1 ] );
                      foreach( $concat_results as $concat_result ) {
                        $this_value = ( string ) $concat_result[ 0 ];
                        $this_value = self::format_single_value( array( &#x27;value&#x27; =&gt; $this_value, &#x27;rule_attribute&#x27; =&gt; $rule_attribute, &#x27;schedule_settings&#x27; =&gt; $schedule_settings ) );
                        //* load single-item results into another temp array*/
                        $to_concat[ $match_rule[ 1 ] ] = $this_value;
                      }
                    }
                    foreach( $to_concat as $match_key =&gt; $match_value ) {
                      //* replace the original rule with the real XML values if they exist */
                      $xpath_rule = str_replace( &quot;&#x27;&quot; . $match_key . &quot;&#x27;&quot;, $match_value, $xpath_rule );
                    }
                    $to_concat = null;
                    //* remove extra apostraphes and trim line */
                    $import_data[ $counter ][ $rule_attribute ][ ] = trim( str_replace( &quot;&#x27;&quot;, &#x27;&#x27;, $xpath_rule ) );
                    continue;
                  }

                } else {
                  //* Handle regular xpath */
                  $return = @$import_object-&gt;xpath( $xpath_rule );
                }

                //* If nothing returned at all, go to next rule */
                if( !$return ) {
                  continue;
                }

                //* Cycle through returns and save them into $import_data */
                foreach( $return as $attribute ) {
                  //* Add first matched value to rule_attribute */
                  $this_value                                    = ( string ) $attribute[ 0 ];
                  $args                                          = array( &#x27;value&#x27; =&gt; $this_value, &#x27;rule_attribute&#x27; =&gt; $rule_attribute, &#x27;schedule_settings&#x27; =&gt; $schedule_settings );
                  $args                                          = array_filter( array_merge( $args, $conditions ) );
                  $this_value                                    = self::format_single_value( $args );
                  $import_data[ $counter ][ $rule_attribute ][ ] = $this_value;
                }

              } //** end single rule cycle */

              //**  All Rules have been processed. Cycle back through rules and concatenate any values that are not allowed to have multiple values */
              if( !empty( $import_data[ $counter ] ) ) {
                foreach( $import_data[ $counter ] as $rule_attribute =&gt; $values ) {
                  if( !in_array( $rule_attribute, $allow_multiple ) ) {
                    $values = ( array ) $values;
                    if( count( $values ) &gt; 1 ) {
                      //** Make sure featured-image is not being concatenated */
                      //** Notice, we must ignore the current condition for RETS, because we get RETS images later during image import job. */
                      if( $rule_attribute == &#x27;featured-image&#x27; &amp;&amp; $schedule_settings[ &#x27;source_type&#x27; ] != &#x27;rets&#x27; ) {
                        //** Make sure there is a regular image array */
                        if( !is_array( $import_data[ $counter ][ &#x27;images&#x27; ] ) ) {
                          $import_data[ $counter ][ &#x27;images&#x27; ] = array();
                        }
                        //** Move all but the first featured image into regular image array, into the beginning, because its probably important */
                        $import_data[ $counter ][ &#x27;images&#x27; ] = array_merge( array_slice( $values, 1 ), $import_data[ $counter ][ &#x27;images&#x27; ] );
                        //** Remove all but the first image for the featured image array */
                        $import_data[ $counter ][ $rule_attribute ] = array_slice( $values, 0, 1 );
                      } else {
                        $import_data[ $counter ][ $rule_attribute ] = null;
                        unset( $import_data[ $counter ][ $rule_attribute ] );
                        $import_data[ $counter ][ $rule_attribute ][ 0 ] = implode( apply_filters( &#x27;wpp_import_attributes_implode_non_multiple&#x27;, &quot;\n&quot; ), $values );
                      }
                    }
                  }
                }
              }

              $import_data[ $counter ][ &#x27;unique_id&#x27; ] = $data[ &#x27;wpp_property_import&#x27; ][ &#x27;unique_id&#x27; ];
              $import_data[ $counter ]                = apply_filters( &#x27;wpp_xml_import_do_rule&#x27;, $import_data[ $counter ], $import_object, $data[ &#x27;wpp_property_import&#x27; ] );

              //** If skipping properties without images, cycle back through and remove any properties without images */
              //** Notice, we must ignore the current condition for RETS, because we get RETS images later during image import job. */
              if( $schedule_settings[ &#x27;source_type&#x27; ] != &#x27;rets&#x27; &amp;&amp; isset( $schedule_settings[ &#x27;minimum_images&#x27; ] ) &amp;&amp; $schedule_settings[ &#x27;minimum_images&#x27; ] &gt; 0 ) {
                $total_images = count( $import_data[ $counter ][ &#x27;images&#x27; ] ) + count( $import_data[ $counter ][ &#x27;featured-image&#x27; ] );
                if( $total_images &lt; $schedule_settings[ &#x27;minimum_images&#x27; ] ) {
                  $import_data[ $counter ] = null;
                  unset( $import_data[ $counter ] );
                  $no_image_skip[ ] = true;
                }
              }

              //** If preview, stop after first processed property */
              if( $preview_import ) {
                $result[ &#x27;success&#x27; ] = &#x27;true&#x27;;
                $result[ &#x27;ui&#x27; ]      = &quot;XPath Rule: {$root_element_xpath}\n\n&quot; . htmlentities( print_r( $import_data[ $counter ], true ) );
                break; /* break throws the logic to the end of the $wpp_action function, and returns all $result data */
              }

              if( $schedule_settings[ &#x27;log_detail&#x27; ] == &#x27;on&#x27; ) {
                if( is_array( $import_data[ $counter ] ) ) {
                  $extracted_attributes = count( array_keys( $import_data[ $counter ] ) );
                } else {
                  $extracted_attributes = 0;
                }
                self::maybe_echo_log( sprintf( __( &#x27;XPath rules for object #%1d processed with %2d extracted attributes.&#x27;, &#x27;wpp&#x27; ), ( $counter + 1 ), $extracted_attributes ) );
              }

              $counter++;

              if( !empty( $schedule_settings[ &#x27;limit_scanned_properties&#x27; ] ) &amp;&amp; $schedule_settings[ &#x27;limit_scanned_properties&#x27; ] == $counter ) {
                self::maybe_echo_log( sprintf( __( &#x27;Stopping import due to specified pre-QC limit of %1d.&#x27;, &#x27;wpp&#x27; ), $counter ) );
                //$wpp_import_result_stats[ ] = $import_created . &quot; new properties imported, stopping due to pre-QC limit.&quot;;
                break;
              }
            } //** end $objects loop */

            unset( $objects );

            self::maybe_echo_memory_usage( __( &#x27;after parsing the list of XML objects (listings)&#x27;, &#x27;wpp&#x27; ), $schedule_id );

            //** In case didn&#x27;t get stopped in the loop above */
            if( $preview_import ) {
              break;
            }

            //** Check how many properties had no images */
            if( isset( $no_image_skip ) &amp;&amp; is_array( $no_image_skip ) ) {
              $no_image_skip = array_sum( $no_image_skip );
              self::maybe_echo_log( &quot;Skipped {$no_image_skip} properties because they had no images.&quot; );
              $wpp_import_result_stats[ ] = &quot;{$no_image_skip} properties skipped because they have no images.&quot;;
            }

            self::maybe_echo_log( &quot;All XPath rules processed, &quot; . count( $import_data ) . &quot; properties remain.&quot; );
            $wpp_import_result_stats[ ] = count( $import_data ) . &quot; properties remaining after processing XPath rules on objects.&quot;;

            self::maybe_echo_log( sprintf( __( &#x27;Importing %1s&#x27;, &#x27;wpp&#x27; ), htmlspecialchars( $schedule_settings[ &#x27;url&#x27; ] ) ) );

            $import_updated = $import_created = $existing_images = 0;

            //** Do the actual import **/
            if( $process_import &amp;&amp; !empty( $import_data ) ) {

              UD_F::log( &#x27;Running XML Import job &#x27; . $schedule_id . &#x27; at &#x27; . date( &quot;F j, Y, g:i a&quot;, time() ) );

              /*
          $_process = self::add_process(array(
            &quot;type&quot; =&gt; &quot;import&quot;,
            &quot;parent&quot; =&gt; $schedule_id,
            &quot;meta&quot; =&gt; array(
              &#x27;id&#x27; =&gt; $schedule_id
            )
          ));

          UD_F::log( sprintf( __( &#x27;Started process #%1s.&#x27;, &#x27;wpp&#x27; ), $_process-&gt;id ) );
          */

              //** Dump all properties and their attachments before importing anything new */
              if( $schedule_settings[ &#x27;remove_all_before_import&#x27; ] == &#x27;on&#x27; ) {
                $all_properties = $wpdb-&gt;get_col( &quot;SELECT ID FROM {$wpdb-&gt;posts} WHERE post_type = &#x27;property&#x27;&quot; );
                self::maybe_echo_log( &quot;Deleting all old properties. &quot; . count( $all_properties ) . &quot; found.&quot; );
                $property_delete_counter = 0;
                foreach( (array) $all_properties as $property_id ) {
                  if( wp_delete_post( $property_id, true ) ) {
                    $property_delete_counter++;
                  }
                }
                if( $property_delete_counter ) {
                  self::maybe_echo_log( &quot;{$property_delete_counter} properties deleted.&quot; );
                  $wpp_import_result_stats[ ] = &quot;All existing properties ( &quot; . $property_delete_counter . &quot; ) deleted.&quot;;
                }
                $all_properties          = null;
                $property_delete_counter = null;
              } elseif( $schedule_settings[ &#x27;remove_all_from_this_source&#x27; ] == &#x27;on&#x27; ) {

                //** Remove all objects that originated from this feed */
                $result = self::delete_feed_properties( $schedule_id, $schedule_settings );

                if( $result[ &#x27;deleted_count&#x27; ] &gt; 0 ) {
                  $wpp_import_result_stats[ ] = sprintf( __( &#x27;Deleted all ( %1s ) properties that originated from this feed.&#x27;, &#x27;wpp&#x27; ), $result[ &#x27;deleted_count&#x27; ] );
                  self::maybe_echo_log( sprintf( __( &#x27;Deleted all ( %1s ) properties that originated from this feed.&#x27;, &#x27;wpp&#x27; ), $result[ &#x27;deleted_count&#x27; ] ) );
                } elseif( $result[ &#x27;total_found&#x27; ] == 0 ) {
                  self::maybe_echo_log( __( &#x27;Did not find any properties that have been imported from this feed to remove.&#x27;, &#x27;wpp&#x27; ) );
                }
                $result = null;
                //** End: $schedule_settings[&#x27;remove_all_from_this_source&#x27;] == &#x27;on&#x27; */
              } else {
                self::maybe_echo_log( __( &#x27;Did not remove any old properties.&#x27;, &#x27;wpp&#x27; ) );
              }

              // Handle the actual import
              self::maybe_echo_log( &#x27;Beginning object cycle. We have &#x27; . count( $import_data ) . &#x27; objects.&#x27; );
              self::maybe_echo_memory_usage( &#x27;&#x27;, $schedule_id );

              //** Cycle through each XML object **/
              foreach( (array) $import_data as $zero_counter =&gt; $single_object_data ) {

                //** Updated counter to not be zero based */
                $counter = ( $zero_counter + 1 );

                if( !empty( $schedule_settings[ &#x27;limit_properties&#x27; ] ) &amp;&amp; $schedule_settings[ &#x27;limit_properties&#x27; ] == $import_created ) {
                  self::maybe_echo_log( sprintf( __( &#x27;Stopping import due to specified post-QC limit of %1d.&#x27;, &#x27;wpp&#x27; ), $counter ) );
                  $wpp_import_result_stats[ ] = $import_created . &quot; new properties imported, stopping due to limit.&quot;;
                  break;
                }

                $unique_id = $single_object_data[ $schedule_settings[ &#x27;unique_id&#x27; ] ][ 0 ];

                //** Skip object import if no unique ID value exists ( @todo may need to add an option to not do this, some feeds may not have unique attributes - potanin@UD ) */
                if( empty( $unique_id ) ) {
                  self::maybe_echo_log( &quot;Skipping property, unique ID not found. &quot; );
                  continue;
                }

                /** Perform single object importing */
                //self::maybe_echo_memory_usage( sprintf( __( &#x27;before %s&#x27;, &#x27;wpp&#x27; ), &#x27;import_object()&#x27; ), $schedule_id );
                $iobject = self::import_object( $single_object_data, $schedule_id, $counter );
                self::maybe_echo_memory_usage( sprintf( __( &#x27;after %s&#x27;, &#x27;wpp&#x27; ), &#x27;import_object()&#x27; ), $schedule_id );

                if( is_wp_error( $iobject ) ) {
                  //** Error occured */
                  self::maybe_echo_log( &#x27;Error on single object import: &#x27; . $iobject-&gt;get_error_message() );
                  //** Stop this object import */
                  continue;
                } elseif( is_numeric( $iobject[ 0 ] ) ) {
                  // Actual post_id stored in $iobject[0]
                  $imported_objects[ ] = $iobject[ 0 ];
                  if( $iobject[ 1 ] == &#x27;u&#x27; ) {
                    $import_updated += 1;
                  } else if( $iobject[ 1 ] == &#x27;c&#x27; ) {
                    $import_created += 1;
                  }
                  do_action( &#x27;wpp::xmli::after_import_object&#x27;, $iobject, $single_object_data, $schedule_id );
                } else {
                  // This happens if the property was not inserted, or deleted.
                }

                $iobject = null;
                unset( $iobject );
                unset( $import_data[ $zero_counter ] );
              }

              self::maybe_echo_log( sprintf( __( &#x27;Object cycle done. Completed %1d cycles.&#x27;, &#x27;wpp&#x27; ), $counter - 1 ) );
              self::maybe_echo_memory_usage( &#x27;&#x27;, $schedule_id );

              //** Remove any objects that are no longer in source ( do not remove non existant if we only did a limited import ) */
              if( empty( $schedule_settings[ &#x27;limit_properties&#x27; ] ) &amp;&amp;
                empty( $schedule_settings[ &#x27;limit_scanned_properties&#x27; ] ) &amp;&amp;
                $schedule_settings[ &#x27;remove_non_existant&#x27; ] == &#x27;on&#x27; &amp;&amp;
                $schedule_settings[ &#x27;remove_all_from_this_source&#x27; ] != &#x27;on&#x27;
              ) {
                $result = self::delete_feed_properties( $schedule_id, $schedule_settings, $imported_objects );

                if( $result[ &#x27;deleted_count&#x27; ] &gt; 0 ) {
                  $wpp_import_result_stats[ ] = sprintf( __( &#x27;Deleted ( %1s ) properties that are no longer in the feed.&#x27;, &#x27;wpp&#x27; ), $result[ &#x27;deleted_count&#x27; ] );
                  self::maybe_echo_log( sprintf( __( &#x27;Deleted ( %1s ) properties that are no longer in the feed.&#x27;, &#x27;wpp&#x27; ), $result[ &#x27;deleted_count&#x27; ] ) );
                } elseif( $result[ &#x27;total_found&#x27; ] == 0 ) {
                  self::maybe_echo_log( __( &#x27;Did not find any properties that have been imported from this feed to remove.&#x27;, &#x27;wpp&#x27; ) );
                }
                $result = null;
              } //** End: $schedule_settings[&#x27;remove_non_existant&#x27;] == &#x27;on&#x27; */

              //** Reassociate WP parent IDs **//
              //self::reassociate_parent_ids();

              //** Delete temporary files and folder */
              if( $data[ &#x27;temporary_directory&#x27; ] ) {
                if( $rescleanup = self::delete_by_path( $data[ &#x27;temporary_directory&#x27; ], true ) ) {
                  self::maybe_echo_log( __( &#x27;Deleted the import temporary directory.&#x27;, &#x27;wpp&#x27; ) );
                } else {
                  self::maybe_echo_log( $rescleanup === 0 ? __( &#x27;Import temporary directory is not been created&#x27;, &#x27;wpp&#x27; ) : __( &#x27;Unable to delete the import temporary directory&#x27;, &#x27;wpp&#x27; ) );
                }
              }

              UD_F::log( &#x27;Completed XML Import job &#x27; . $schedule_id . &#x27; at &#x27; . date( &quot;F j, Y, g:i a&quot;, time() ) . &#x27;, ( &#x27; . $import_created . &#x27; )  created and ( &#x27; . $import_updated . &#x27; ) objects updated. &#x27; );

              if( $import_created ) {
                $wpp_import_result_stats[ ]                                      = &quot;Total of &quot; . $import_created . &quot; new properties added.&quot;;
                $wpp_import_result_stats[ &#x27;quantifiable&#x27; ][ &#x27;added_properties&#x27; ] = $import_created;
              }

              if( $import_updated ) {
                $wpp_import_result_stats[ ]                                        = &quot;Total of &quot; . $import_updated . &quot; properties updated.&quot;;
                $wpp_import_result_stats[ &#x27;quantifiable&#x27; ][ &#x27;updated_properties&#x27; ] = $import_updated;
              }

              //** Handle updating settings after import is complete */
              if( $schedule_id ) {
                //** Cannot get get_option() because it uses cached values, and since the importer could have taken a while, changes may have been made to options */
                $wpp_settings                                                                                              = maybe_unserialize( $wpdb-&gt;get_var( &quot;SELECT option_value FROM {$wpdb-&gt;options} WHERE option_name =&#x27;wpp_settings&#x27;&quot; ) );
                $schedule_settings[ &#x27;lastrun&#x27; ][ &#x27;time&#x27; ]                                                                  = time();
                $schedule_settings[ &#x27;lastrun&#x27; ][ &#x27;u&#x27; ]                                                                     = ( !empty( $import_updated ) ) ? $import_updated : 0;
                $schedule_settings[ &#x27;lastrun&#x27; ][ &#x27;c&#x27; ]                                                                     = ( !empty( $import_created ) ) ? $import_created : 0;
                $wpp_settings[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ] = $schedule_settings;
                update_option( &#x27;wpp_settings&#x27;, $wpp_settings );
                $wpp_settings = null;
              }

            }

            self::delete_orphan_directories();

            do_action( &#x27;wpp_xml_import_complete&#x27; );

            //** Finally, we&#x27;re just going to run our scheduled task if needed */
            if( isset( $schedule_id ) &amp;&amp; wp_next_scheduled( &#x27;wpp_manage_pending_images&#x27;, array( &#x27;wpp_manage_pending_images&#x27; =&gt; $schedule_id ) ) ) {
              self::maybe_run_cron( &#x27;wpp_manage_pending_images&#x27;, array( &#x27;wpp_manage_pending_images&#x27; =&gt; $schedule_id ) );
              self::maybe_echo_log( &#x27;Properties have been imported with pending images. An additional process has been launched that will download and publish the properties.&#x27; );
            }

            //** Print out queries up to this point, and blank out the query log */
            if( $schedule_settings[ &#x27;show_sql_queries&#x27; ] &amp;&amp; !empty( $wpdb-&gt;queries ) ) {
              foreach( (array) $wpdb-&gt;queries as $query_data ) {
                self::maybe_echo_log( $query_data[ 0 ] );
              }
            }

            break; /* end case: execute_schedule_import */

          case &#x27;add_edit_schedule&#x27;:
            $edit_current = array();
            if( !empty( $_REQUEST[ &#x27;schedule_id&#x27; ] ) ) {
              //** Existing Schedule */
              $edit_current = $wpp_property_import[ &#x27;schedules&#x27; ][ $_REQUEST[ &#x27;schedule_id&#x27; ] ];
              $new_schedule = false;
            } else {
              //** New Schedule - load defaults */
              $edit_current[ &#x27;map&#x27; ][ 1 ][ &#x27;wpp_attribute&#x27; ] = &#x27;post_title&#x27;;
              $new_schedule                                  = true;
            }
            self::edit_schedule_template( $edit_current, $new_schedule );
            break;

        } //** end: $wpp_action switch */

        //** Load some attributes into return if they exist */
        if( $schedule_hash ) {
          $result[ &#x27;hash&#x27; ] = $schedule_hash;
        }

        if( $schedule_id ) {
          $result[ &#x27;schedule_id&#x27; ] = $schedule_id;
        }

        //** if not doing an import, this this function is used to generate a JSON responde for UI */
        if( !$wpp_schedule_import &amp;&amp; !isset( $result[ &#x27;ui&#x27; ] ) ) {
          $result[ &#x27;ui&#x27; ] = ob_get_contents();
          ob_end_clean();
        }

        // Check encoding. Not necessary because we still force UTF8, for debugging purposes
        if( $wp_properties[ &#x27;configuration&#x27; ][ &#x27;developer_mode&#x27; ] == &#x27;true&#x27; ) {
          $encoding = Utility::detect_encoding( $result[ &#x27;ui&#x27; ] );
          if( is_wp_error( $encoding ) ) {
            $result[ &#x27;encoding&#x27; ] = $encoding-&gt;get_error_message();
          } elseif( !empty( $encoding ) ) {
            $result[ &#x27;encoding&#x27; ] = $encoding;
          } else {
            $result[ &#x27;encoding&#x27; ] = &#x27;UTF-8&#x27;;
          }
        }

        // Response Time.
        $result[ &#x27;took&#x27; ] = ( microtime( true ) - $_time );

        //** Check if this is being called from an AJAX request  */
        if( !empty( $_SERVER[ &#x27;HTTP_X_REQUESTED_WITH&#x27; ] ) &amp;&amp; strtolower( $_SERVER[ &#x27;HTTP_X_REQUESTED_WITH&#x27; ] ) == &#x27;xmlhttprequest&#x27; ) {
          $json_encode = UD_API::json_encode( $result );
          die( $json_encode );
        } else {
          $result[ &#x27;ui&#x27; ] = utf8_encode( $result[ &#x27;ui&#x27; ] );

          return $result;
        }

        /** Important - do not die() this function unless we have an AJAX request */

      }

      /**
       * Traverse through XML DOM
       *
       * Everything handles via this page. Other functions are done via AJAX.
       *
       * @todo Could be improved
       * Copyright 2010 - 2014 Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
       */
      static public function traverse( DomNode $node, $level = 0 ) {
        global $wpp_property_import;
        $this_tag = self::handle_node( $node, $level );
        if( $node-&gt;hasChildNodes() ) {
          $children = $node-&gt;childNodes;
          foreach( $children as $kid ) {
            if( $kid-&gt;nodeType == XML_ELEMENT_NODE ) {
              self::traverse( $kid, $level + 1 );
            } else {
              $wpp_property_import[ &#x27;runtime&#x27; ][ &#x27;tags&#x27; ][ ] = $this_tag;
            }
          }
        } else {
          // means that there&#x27;s no value
          $wpp_property_import[ &#x27;runtime&#x27; ][ &#x27;tags&#x27; ][ ] = $this_tag;
        }
      }

      /**
       * Functions used by traverse()
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
       */
      static public function handle_node( DomNode $node, $level ) {
        global $wpp_property_import;
        if( $node-&gt;nodeType == XML_ELEMENT_NODE ) {
          return $node-&gt;tagName;
        }
      }

      /**
       * Import overview page.
       *
       * Everything handles via this page. Other functions are done via AJAX.
       *
       * @Page ID: property_page_wpp_property_import
       * Copyright 2010 - 2014 Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
       */
      static public function page_main() {
        global $wp_properties, $wpdb, $wpp_property_import, $current_screen, $wp_messages;

        if( isset( $_REQUEST[ &#x27;message&#x27; ] ) ) {

          switch( $_REQUEST[ &#x27;message&#x27; ] ) {

            case &#x27;imported&#x27;:
              $wp_messages[ &#x27;notice&#x27; ][ ] = __( &#x27;Schedule imported from file.&#x27;, &#x27;wpp&#x27; );
              break;

          }
        }

        $cron_path      = preg_replace( &#x27;%core[/\\\\]premium[/\\\\]class_wpp_property_import.php%ix&#x27;, &#x27;cron.php&#x27;, __FILE__ );
        $media_progress = self::get_media_progress();


        //echo( &#x27;&lt;pre&gt;&#x27; . print_r( $media_progress, true ) . &#x27;&lt;/pre&gt;&#x27; );

        ?&gt;

        &lt;div class=&quot;wrap&quot; data-requires=&quot;wpp.importer.overview&quot; data-version=&quot;&lt;?php echo self::$version; ?&gt;&quot;&gt;

          &lt;h2 class=&quot;nav-tab-wrapper&quot;&gt;
		        &lt;a href=&quot;#schedules&quot; class=&quot;nav-tab nav-tab-active&quot;&gt;&lt;?php _e( &#x27;Schedules&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt;
		        &lt;a href=&quot;#reports&quot; class=&quot;nav-tab&quot;&gt;&lt;?php _e( &#x27;Reports&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt;
		        &lt;a href=&quot;#logs&quot; class=&quot;nav-tab&quot;&gt;&lt;?php _e( &#x27;Logs&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt;
					  &lt;a href=&quot;#settings&quot; class=&quot;nav-tab&quot;&gt;&lt;?php _e( &#x27;Settings&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt;
			    &lt;/h2&gt;

          &lt;a id=&quot;wpp_property_import_add_import&quot; class=&quot;button add-new-h2&quot; href=&quot;#add_new_schedule&quot;&gt;&lt;?php _e( &#x27;Add New&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt;

          &lt;span class=&quot;wpp_xi_loader&quot;&gt;&lt;/span&gt;

          &lt;div id=&quot;side-sortables&quot; class=&quot;accordion-container&quot;&gt;
            &lt;ul class=&quot;outer-border&quot;&gt;
                    &lt;li class=&quot;control-section accordion-section  add-page top&quot; id=&quot;add-page&quot;&gt;
                    &lt;h3 class=&quot;accordion-section-title hndle&quot; tabindex=&quot;0&quot; title=&quot;Pages&quot;&gt;Pages&lt;/h3&gt;
                    &lt;div class=&quot;accordion-section-content &quot; style=&quot;display: none;&quot;&gt;
                      &lt;div class=&quot;inside&quot;&gt;
                          &lt;div id=&quot;posttype-page&quot; class=&quot;posttypediv&quot;&gt;
            &lt;ul id=&quot;posttype-page-tabs&quot; class=&quot;posttype-tabs add-menu-item-tabs&quot;&gt;
              &lt;li class=&quot;tabs&quot;&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;tabs-panel-posttype-page-most-recent&quot; href=&quot;/manage/nav-menus.php?page-tab=most-recent#tabs-panel-posttype-page-most-recent&quot;&gt;
                  Most Recent				&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;page-all&quot; href=&quot;/manage/nav-menus.php?page-tab=all#page-all&quot;&gt;
                  View All				&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;tabs-panel-posttype-page-search&quot; href=&quot;/manage/nav-menus.php?page-tab=search#tabs-panel-posttype-page-search&quot;&gt;
                  Search				&lt;/a&gt;
              &lt;/li&gt;
            &lt;/ul&gt;&lt;!-- .posttype-tabs --&gt;

            &lt;div id=&quot;tabs-panel-posttype-page-most-recent&quot; class=&quot;tabs-panel tabs-panel-active&quot;&gt;
              &lt;ul id=&quot;pagechecklist-most-recent&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                &lt;li&gt;&lt;label class=&quot;menu-item-title&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;menu-item-checkbox&quot; name=&quot;menu-item[-1][menu-item-object-id]&quot; value=&quot;2&quot;&gt; Sample Page&lt;/label&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-db-id&quot; name=&quot;menu-item[-1][menu-item-db-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-object&quot; name=&quot;menu-item[-1][menu-item-object]&quot; value=&quot;page&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-parent-id&quot; name=&quot;menu-item[-1][menu-item-parent-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-type&quot; name=&quot;menu-item[-1][menu-item-type]&quot; value=&quot;post_type&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-title&quot; name=&quot;menu-item[-1][menu-item-title]&quot; value=&quot;Sample Page&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-url&quot; name=&quot;menu-item[-1][menu-item-url]&quot; value=&quot;http://imperialrealestategroup.dev/sample-page/&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-target&quot; name=&quot;menu-item[-1][menu-item-target]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-attr_title&quot; name=&quot;menu-item[-1][menu-item-attr_title]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-classes&quot; name=&quot;menu-item[-1][menu-item-classes]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-xfn&quot; name=&quot;menu-item[-1][menu-item-xfn]&quot; value=&quot;&quot;&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;div class=&quot;tabs-panel tabs-panel-inactive&quot; id=&quot;tabs-panel-posttype-page-search&quot;&gt;
                    &lt;p class=&quot;quick-search-wrap&quot;&gt;
                &lt;input type=&quot;search&quot; class=&quot;quick-search input-with-default-title&quot; title=&quot;Search&quot; value=&quot;&quot; name=&quot;quick-search-posttype-page&quot; autocomplete=&quot;off&quot;&gt;
                &lt;span class=&quot;spinner&quot;&gt;&lt;/span&gt;
                &lt;input type=&quot;submit&quot; name=&quot;submit&quot; id=&quot;submit-quick-search-posttype-page&quot; class=&quot;button button-small quick-search-submit hide-if-js&quot; value=&quot;Search&quot;&gt;			&lt;/p&gt;

              &lt;ul id=&quot;page-search-checklist&quot; data-wp-lists=&quot;list:page&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                    &lt;/ul&gt;
            &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;div id=&quot;page-all&quot; class=&quot;tabs-panel tabs-panel-view-all tabs-panel-inactive&quot;&gt;
                    &lt;ul id=&quot;pagechecklist&quot; data-wp-lists=&quot;list:page&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                &lt;li&gt;&lt;label class=&quot;menu-item-title&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;menu-item-checkbox add-to-top&quot; name=&quot;menu-item[-2][menu-item-object-id]&quot; value=&quot;-2&quot;&gt; Home&lt;/label&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-db-id&quot; name=&quot;menu-item[-2][menu-item-db-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-object&quot; name=&quot;menu-item[-2][menu-item-object]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-parent-id&quot; name=&quot;menu-item[-2][menu-item-parent-id]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-type&quot; name=&quot;menu-item[-2][menu-item-type]&quot; value=&quot;custom&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-title&quot; name=&quot;menu-item[-2][menu-item-title]&quot; value=&quot;Home&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-url&quot; name=&quot;menu-item[-2][menu-item-url]&quot; value=&quot;http://imperialrealestategroup.dev/&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-target&quot; name=&quot;menu-item[-2][menu-item-target]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-attr_title&quot; name=&quot;menu-item[-2][menu-item-attr_title]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-classes&quot; name=&quot;menu-item[-2][menu-item-classes]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-xfn&quot; name=&quot;menu-item[-2][menu-item-xfn]&quot; value=&quot;&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;label class=&quot;menu-item-title&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;menu-item-checkbox&quot; name=&quot;menu-item[-4][menu-item-object-id]&quot; value=&quot;2&quot;&gt; Sample Page&lt;/label&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-db-id&quot; name=&quot;menu-item[-4][menu-item-db-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-object&quot; name=&quot;menu-item[-4][menu-item-object]&quot; value=&quot;page&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-parent-id&quot; name=&quot;menu-item[-4][menu-item-parent-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-type&quot; name=&quot;menu-item[-4][menu-item-type]&quot; value=&quot;post_type&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-title&quot; name=&quot;menu-item[-4][menu-item-title]&quot; value=&quot;Sample Page&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-url&quot; name=&quot;menu-item[-4][menu-item-url]&quot; value=&quot;http://imperialrealestategroup.dev/sample-page/&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-target&quot; name=&quot;menu-item[-4][menu-item-target]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-attr_title&quot; name=&quot;menu-item[-4][menu-item-attr_title]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-classes&quot; name=&quot;menu-item[-4][menu-item-classes]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-xfn&quot; name=&quot;menu-item[-4][menu-item-xfn]&quot; value=&quot;&quot;&gt;&lt;/li&gt;
              &lt;/ul&gt;
                  &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;p class=&quot;button-controls&quot;&gt;
              &lt;span class=&quot;list-controls&quot;&gt;
                &lt;a href=&quot;/manage/nav-menus.php?page-tab=all&amp;amp;selectall=1#posttype-page&quot; class=&quot;select-all&quot;&gt;Select All&lt;/a&gt;
              &lt;/span&gt;

              &lt;span class=&quot;add-to-menu&quot;&gt;
                &lt;input type=&quot;submit&quot; class=&quot;button-secondary submit-add-to-menu right&quot; value=&quot;Add to Menu&quot; name=&quot;add-post-type-menu-item&quot; id=&quot;submit-posttype-page&quot;&gt;
                &lt;span class=&quot;spinner&quot;&gt;&lt;/span&gt;
              &lt;/span&gt;
            &lt;/p&gt;

          &lt;/div&gt;&lt;!-- /.posttypediv --&gt;
                        &lt;/div&gt;&lt;!-- .inside --&gt;
                    &lt;/div&gt;&lt;!-- .accordion-section-content --&gt;
                  &lt;/li&gt;&lt;!-- .accordion-section --&gt;
                            &lt;li class=&quot;control-section accordion-section hide-if-js  add-post&quot; id=&quot;add-post&quot;&gt;
                    &lt;h3 class=&quot;accordion-section-title hndle&quot; tabindex=&quot;0&quot; title=&quot;Posts&quot;&gt;Posts&lt;/h3&gt;
                    &lt;div class=&quot;accordion-section-content &quot;&gt;
                      &lt;div class=&quot;inside&quot;&gt;
                          &lt;div id=&quot;posttype-post&quot; class=&quot;posttypediv&quot;&gt;
            &lt;ul id=&quot;posttype-post-tabs&quot; class=&quot;posttype-tabs add-menu-item-tabs&quot;&gt;
              &lt;li class=&quot;tabs&quot;&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;tabs-panel-posttype-post-most-recent&quot; href=&quot;/manage/nav-menus.php?post-tab=most-recent#tabs-panel-posttype-post-most-recent&quot;&gt;
                  Most Recent				&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;post-all&quot; href=&quot;/manage/nav-menus.php?post-tab=all#post-all&quot;&gt;
                  View All				&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;tabs-panel-posttype-post-search&quot; href=&quot;/manage/nav-menus.php?post-tab=search#tabs-panel-posttype-post-search&quot;&gt;
                  Search				&lt;/a&gt;
              &lt;/li&gt;
            &lt;/ul&gt;&lt;!-- .posttype-tabs --&gt;

            &lt;div id=&quot;tabs-panel-posttype-post-most-recent&quot; class=&quot;tabs-panel tabs-panel-active&quot;&gt;
              &lt;ul id=&quot;postchecklist-most-recent&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                &lt;li&gt;&lt;label class=&quot;menu-item-title&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;menu-item-checkbox&quot; name=&quot;menu-item[-5][menu-item-object-id]&quot; value=&quot;1&quot;&gt; Hello world!&lt;/label&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-db-id&quot; name=&quot;menu-item[-5][menu-item-db-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-object&quot; name=&quot;menu-item[-5][menu-item-object]&quot; value=&quot;post&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-parent-id&quot; name=&quot;menu-item[-5][menu-item-parent-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-type&quot; name=&quot;menu-item[-5][menu-item-type]&quot; value=&quot;post_type&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-title&quot; name=&quot;menu-item[-5][menu-item-title]&quot; value=&quot;Hello world!&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-url&quot; name=&quot;menu-item[-5][menu-item-url]&quot; value=&quot;http://imperialrealestategroup.dev/2014/01/10/hello-world/&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-target&quot; name=&quot;menu-item[-5][menu-item-target]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-attr_title&quot; name=&quot;menu-item[-5][menu-item-attr_title]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-classes&quot; name=&quot;menu-item[-5][menu-item-classes]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-xfn&quot; name=&quot;menu-item[-5][menu-item-xfn]&quot; value=&quot;&quot;&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;div class=&quot;tabs-panel tabs-panel-inactive&quot; id=&quot;tabs-panel-posttype-post-search&quot;&gt;
                    &lt;p class=&quot;quick-search-wrap&quot;&gt;
                &lt;input type=&quot;search&quot; class=&quot;quick-search input-with-default-title&quot; title=&quot;Search&quot; value=&quot;&quot; name=&quot;quick-search-posttype-post&quot; autocomplete=&quot;off&quot;&gt;
                &lt;span class=&quot;spinner&quot;&gt;&lt;/span&gt;
                &lt;input type=&quot;submit&quot; name=&quot;submit&quot; id=&quot;submit-quick-search-posttype-post&quot; class=&quot;button button-small quick-search-submit hide-if-js&quot; value=&quot;Search&quot;&gt;			&lt;/p&gt;

              &lt;ul id=&quot;post-search-checklist&quot; data-wp-lists=&quot;list:post&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                    &lt;/ul&gt;
            &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;div id=&quot;post-all&quot; class=&quot;tabs-panel tabs-panel-view-all tabs-panel-inactive&quot;&gt;
                    &lt;ul id=&quot;postchecklist&quot; data-wp-lists=&quot;list:post&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                &lt;li&gt;&lt;label class=&quot;menu-item-title&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;menu-item-checkbox&quot; name=&quot;menu-item[-6][menu-item-object-id]&quot; value=&quot;1&quot;&gt; Hello world!&lt;/label&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-db-id&quot; name=&quot;menu-item[-6][menu-item-db-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-object&quot; name=&quot;menu-item[-6][menu-item-object]&quot; value=&quot;post&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-parent-id&quot; name=&quot;menu-item[-6][menu-item-parent-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-type&quot; name=&quot;menu-item[-6][menu-item-type]&quot; value=&quot;post_type&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-title&quot; name=&quot;menu-item[-6][menu-item-title]&quot; value=&quot;Hello world!&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-url&quot; name=&quot;menu-item[-6][menu-item-url]&quot; value=&quot;http://imperialrealestategroup.dev/2014/01/10/hello-world/&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-target&quot; name=&quot;menu-item[-6][menu-item-target]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-attr_title&quot; name=&quot;menu-item[-6][menu-item-attr_title]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-classes&quot; name=&quot;menu-item[-6][menu-item-classes]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-xfn&quot; name=&quot;menu-item[-6][menu-item-xfn]&quot; value=&quot;&quot;&gt;&lt;/li&gt;
              &lt;/ul&gt;
                  &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;p class=&quot;button-controls&quot;&gt;
              &lt;span class=&quot;list-controls&quot;&gt;
                &lt;a href=&quot;/manage/nav-menus.php?post-tab=all&amp;amp;selectall=1#posttype-post&quot; class=&quot;select-all&quot;&gt;Select All&lt;/a&gt;
              &lt;/span&gt;

              &lt;span class=&quot;add-to-menu&quot;&gt;
                &lt;input type=&quot;submit&quot; class=&quot;button-secondary submit-add-to-menu right&quot; value=&quot;Add to Menu&quot; name=&quot;add-post-type-menu-item&quot; id=&quot;submit-posttype-post&quot;&gt;
                &lt;span class=&quot;spinner&quot;&gt;&lt;/span&gt;
              &lt;/span&gt;
            &lt;/p&gt;

          &lt;/div&gt;&lt;!-- /.posttypediv --&gt;
                        &lt;/div&gt;&lt;!-- .inside --&gt;
                    &lt;/div&gt;&lt;!-- .accordion-section-content --&gt;
                  &lt;/li&gt;&lt;!-- .accordion-section --&gt;
                            &lt;li class=&quot;control-section accordion-section hide-if-js  add-property&quot; id=&quot;add-property&quot;&gt;
                    &lt;h3 class=&quot;accordion-section-title hndle&quot; tabindex=&quot;0&quot; title=&quot;Properties&quot;&gt;Properties&lt;/h3&gt;
                    &lt;div class=&quot;accordion-section-content &quot;&gt;
                      &lt;div class=&quot;inside&quot;&gt;
                          &lt;div id=&quot;posttype-property&quot; class=&quot;posttypediv&quot;&gt;
            &lt;ul id=&quot;posttype-property-tabs&quot; class=&quot;posttype-tabs add-menu-item-tabs&quot;&gt;
              &lt;li class=&quot;tabs&quot;&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;tabs-panel-posttype-property-most-recent&quot; href=&quot;/manage/nav-menus.php?property-tab=most-recent#tabs-panel-posttype-property-most-recent&quot;&gt;
                  Most Recent				&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;property-all&quot; href=&quot;/manage/nav-menus.php?property-tab=all#property-all&quot;&gt;
                  View All				&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;tabs-panel-posttype-property-search&quot; href=&quot;/manage/nav-menus.php?property-tab=search#tabs-panel-posttype-property-search&quot;&gt;
                  Search				&lt;/a&gt;
              &lt;/li&gt;
            &lt;/ul&gt;&lt;!-- .posttype-tabs --&gt;

            &lt;div id=&quot;tabs-panel-posttype-property-most-recent&quot; class=&quot;tabs-panel tabs-panel-active&quot;&gt;
              &lt;ul id=&quot;propertychecklist-most-recent&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                &lt;li&gt;&lt;label class=&quot;menu-item-title&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;menu-item-checkbox&quot; name=&quot;menu-item[-7][menu-item-object-id]&quot; value=&quot;12&quot;&gt; Test Listing&lt;/label&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-db-id&quot; name=&quot;menu-item[-7][menu-item-db-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-object&quot; name=&quot;menu-item[-7][menu-item-object]&quot; value=&quot;property&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-parent-id&quot; name=&quot;menu-item[-7][menu-item-parent-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-type&quot; name=&quot;menu-item[-7][menu-item-type]&quot; value=&quot;post_type&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-title&quot; name=&quot;menu-item[-7][menu-item-title]&quot; value=&quot;Test Listing&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-url&quot; name=&quot;menu-item[-7][menu-item-url]&quot; value=&quot;http://imperialrealestategroup.dev/listings/test-listing/&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-target&quot; name=&quot;menu-item[-7][menu-item-target]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-attr_title&quot; name=&quot;menu-item[-7][menu-item-attr_title]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-classes&quot; name=&quot;menu-item[-7][menu-item-classes]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-xfn&quot; name=&quot;menu-item[-7][menu-item-xfn]&quot; value=&quot;&quot;&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;div class=&quot;tabs-panel tabs-panel-inactive&quot; id=&quot;tabs-panel-posttype-property-search&quot;&gt;
                    &lt;p class=&quot;quick-search-wrap&quot;&gt;
                &lt;input type=&quot;search&quot; class=&quot;quick-search input-with-default-title&quot; title=&quot;Search&quot; value=&quot;&quot; name=&quot;quick-search-posttype-property&quot; autocomplete=&quot;off&quot;&gt;
                &lt;span class=&quot;spinner&quot;&gt;&lt;/span&gt;
                &lt;input type=&quot;submit&quot; name=&quot;submit&quot; id=&quot;submit-quick-search-posttype-property&quot; class=&quot;button button-small quick-search-submit hide-if-js&quot; value=&quot;Search&quot;&gt;			&lt;/p&gt;

              &lt;ul id=&quot;property-search-checklist&quot; data-wp-lists=&quot;list:property&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                    &lt;/ul&gt;
            &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;div id=&quot;property-all&quot; class=&quot;tabs-panel tabs-panel-view-all tabs-panel-inactive&quot;&gt;
                    &lt;ul id=&quot;propertychecklist&quot; data-wp-lists=&quot;list:property&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                &lt;li&gt;&lt;label class=&quot;menu-item-title&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;menu-item-checkbox&quot; name=&quot;menu-item[-8][menu-item-object-id]&quot; value=&quot;12&quot;&gt; Test Listing&lt;/label&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-db-id&quot; name=&quot;menu-item[-8][menu-item-db-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-object&quot; name=&quot;menu-item[-8][menu-item-object]&quot; value=&quot;property&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-parent-id&quot; name=&quot;menu-item[-8][menu-item-parent-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-type&quot; name=&quot;menu-item[-8][menu-item-type]&quot; value=&quot;post_type&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-title&quot; name=&quot;menu-item[-8][menu-item-title]&quot; value=&quot;Test Listing&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-url&quot; name=&quot;menu-item[-8][menu-item-url]&quot; value=&quot;http://imperialrealestategroup.dev/listings/test-listing/&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-target&quot; name=&quot;menu-item[-8][menu-item-target]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-attr_title&quot; name=&quot;menu-item[-8][menu-item-attr_title]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-classes&quot; name=&quot;menu-item[-8][menu-item-classes]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-xfn&quot; name=&quot;menu-item[-8][menu-item-xfn]&quot; value=&quot;&quot;&gt;&lt;/li&gt;
              &lt;/ul&gt;
                  &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;p class=&quot;button-controls&quot;&gt;
              &lt;span class=&quot;list-controls&quot;&gt;
                &lt;a href=&quot;/manage/nav-menus.php?property-tab=all&amp;amp;selectall=1#posttype-property&quot; class=&quot;select-all&quot;&gt;Select All&lt;/a&gt;
              &lt;/span&gt;

              &lt;span class=&quot;add-to-menu&quot;&gt;
                &lt;input type=&quot;submit&quot; class=&quot;button-secondary submit-add-to-menu right&quot; value=&quot;Add to Menu&quot; name=&quot;add-post-type-menu-item&quot; id=&quot;submit-posttype-property&quot;&gt;
                &lt;span class=&quot;spinner&quot;&gt;&lt;/span&gt;
              &lt;/span&gt;
            &lt;/p&gt;

          &lt;/div&gt;&lt;!-- /.posttypediv --&gt;
                        &lt;/div&gt;&lt;!-- .inside --&gt;
                    &lt;/div&gt;&lt;!-- .accordion-section-content --&gt;
                  &lt;/li&gt;&lt;!-- .accordion-section --&gt;
                            &lt;li class=&quot;control-section accordion-section   add-custom-links&quot; id=&quot;add-custom-links&quot;&gt;
                    &lt;h3 class=&quot;accordion-section-title hndle&quot; tabindex=&quot;0&quot; title=&quot;Links&quot;&gt;Links&lt;/h3&gt;
                    &lt;div class=&quot;accordion-section-content &quot;&gt;
                      &lt;div class=&quot;inside&quot;&gt;
                          &lt;div class=&quot;customlinkdiv&quot; id=&quot;customlinkdiv&quot;&gt;
            &lt;input type=&quot;hidden&quot; value=&quot;custom&quot; name=&quot;menu-item[-9][menu-item-type]&quot;&gt;
            &lt;p id=&quot;menu-item-url-wrap&quot;&gt;
              &lt;label class=&quot;howto&quot; for=&quot;custom-menu-item-url&quot;&gt;
                &lt;span&gt;URL&lt;/span&gt;
                &lt;input id=&quot;custom-menu-item-url&quot; name=&quot;menu-item[-9][menu-item-url]&quot; type=&quot;text&quot; class=&quot;code menu-item-textbox&quot; value=&quot;http://&quot;&gt;
              &lt;/label&gt;
            &lt;/p&gt;

            &lt;p id=&quot;menu-item-name-wrap&quot;&gt;
              &lt;label class=&quot;howto&quot; for=&quot;custom-menu-item-name&quot;&gt;
                &lt;span&gt;Link Text&lt;/span&gt;
                &lt;input id=&quot;custom-menu-item-name&quot; name=&quot;menu-item[-9][menu-item-title]&quot; type=&quot;text&quot; class=&quot;regular-text menu-item-textbox input-with-default-title&quot; title=&quot;Menu Item&quot;&gt;
              &lt;/label&gt;
            &lt;/p&gt;

            &lt;p class=&quot;button-controls&quot;&gt;
              &lt;span class=&quot;add-to-menu&quot;&gt;
                &lt;input type=&quot;submit&quot; class=&quot;button-secondary submit-add-to-menu right&quot; value=&quot;Add to Menu&quot; name=&quot;add-custom-menu-item&quot; id=&quot;submit-customlinkdiv&quot;&gt;
                &lt;span class=&quot;spinner&quot;&gt;&lt;/span&gt;
              &lt;/span&gt;
            &lt;/p&gt;

          &lt;/div&gt;&lt;!-- /.customlinkdiv --&gt;
                        &lt;/div&gt;&lt;!-- .inside --&gt;
                    &lt;/div&gt;&lt;!-- .accordion-section-content --&gt;
                  &lt;/li&gt;&lt;!-- .accordion-section --&gt;
                            &lt;li class=&quot;control-section accordion-section   add-category&quot; id=&quot;add-category&quot;&gt;
                    &lt;h3 class=&quot;accordion-section-title hndle&quot; tabindex=&quot;0&quot; title=&quot;Categories&quot;&gt;Categories&lt;/h3&gt;
                    &lt;div class=&quot;accordion-section-content &quot;&gt;
                      &lt;div class=&quot;inside&quot;&gt;
                          &lt;div id=&quot;taxonomy-category&quot; class=&quot;taxonomydiv&quot;&gt;
            &lt;ul id=&quot;taxonomy-category-tabs&quot; class=&quot;taxonomy-tabs add-menu-item-tabs&quot;&gt;
              &lt;li class=&quot;tabs&quot;&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;tabs-panel-category-pop&quot; href=&quot;/manage/nav-menus.php?category-tab=most-used#tabs-panel-category-pop&quot;&gt;
                  Most Used				&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;tabs-panel-category-all&quot; href=&quot;/manage/nav-menus.php?category-tab=all#tabs-panel-category-all&quot;&gt;
                  View All				&lt;/a&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;a class=&quot;nav-tab-link&quot; data-type=&quot;tabs-panel-search-taxonomy-category&quot; href=&quot;/manage/nav-menus.php?category-tab=search#tabs-panel-search-taxonomy-category&quot;&gt;
                  Search				&lt;/a&gt;
              &lt;/li&gt;
            &lt;/ul&gt;&lt;!-- .taxonomy-tabs --&gt;

            &lt;div id=&quot;tabs-panel-category-pop&quot; class=&quot;tabs-panel tabs-panel-active&quot;&gt;
              &lt;ul id=&quot;categorychecklist-pop&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                &lt;li&gt;&lt;label class=&quot;menu-item-title&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;menu-item-checkbox&quot; name=&quot;menu-item[-10][menu-item-object-id]&quot; value=&quot;1&quot;&gt; Uncategorized&lt;/label&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-db-id&quot; name=&quot;menu-item[-10][menu-item-db-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-object&quot; name=&quot;menu-item[-10][menu-item-object]&quot; value=&quot;category&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-parent-id&quot; name=&quot;menu-item[-10][menu-item-parent-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-type&quot; name=&quot;menu-item[-10][menu-item-type]&quot; value=&quot;taxonomy&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-title&quot; name=&quot;menu-item[-10][menu-item-title]&quot; value=&quot;Uncategorized&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-url&quot; name=&quot;menu-item[-10][menu-item-url]&quot; value=&quot;http://imperialrealestategroup.dev/category/uncategorized/&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-target&quot; name=&quot;menu-item[-10][menu-item-target]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-attr_title&quot; name=&quot;menu-item[-10][menu-item-attr_title]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-classes&quot; name=&quot;menu-item[-10][menu-item-classes]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-xfn&quot; name=&quot;menu-item[-10][menu-item-xfn]&quot; value=&quot;&quot;&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;div id=&quot;tabs-panel-category-all&quot; class=&quot;tabs-panel tabs-panel-view-all tabs-panel-inactive&quot;&gt;
                    &lt;ul id=&quot;categorychecklist&quot; data-wp-lists=&quot;list:category&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                &lt;li&gt;&lt;label class=&quot;menu-item-title&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;menu-item-checkbox&quot; name=&quot;menu-item[-11][menu-item-object-id]&quot; value=&quot;1&quot;&gt; Uncategorized&lt;/label&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-db-id&quot; name=&quot;menu-item[-11][menu-item-db-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-object&quot; name=&quot;menu-item[-11][menu-item-object]&quot; value=&quot;category&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-parent-id&quot; name=&quot;menu-item[-11][menu-item-parent-id]&quot; value=&quot;0&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-type&quot; name=&quot;menu-item[-11][menu-item-type]&quot; value=&quot;taxonomy&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-title&quot; name=&quot;menu-item[-11][menu-item-title]&quot; value=&quot;Uncategorized&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-url&quot; name=&quot;menu-item[-11][menu-item-url]&quot; value=&quot;http://imperialrealestategroup.dev/category/uncategorized/&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-target&quot; name=&quot;menu-item[-11][menu-item-target]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-attr_title&quot; name=&quot;menu-item[-11][menu-item-attr_title]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-classes&quot; name=&quot;menu-item[-11][menu-item-classes]&quot; value=&quot;&quot;&gt;&lt;input type=&quot;hidden&quot; class=&quot;menu-item-xfn&quot; name=&quot;menu-item[-11][menu-item-xfn]&quot; value=&quot;&quot;&gt;&lt;/li&gt;
              &lt;/ul&gt;
                  &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;div class=&quot;tabs-panel tabs-panel-inactive&quot; id=&quot;tabs-panel-search-taxonomy-category&quot;&gt;
                    &lt;p class=&quot;quick-search-wrap&quot;&gt;
                &lt;input type=&quot;search&quot; class=&quot;quick-search input-with-default-title&quot; title=&quot;Search&quot; value=&quot;&quot; name=&quot;quick-search-taxonomy-category&quot; autocomplete=&quot;off&quot;&gt;
                &lt;span class=&quot;spinner&quot;&gt;&lt;/span&gt;
                &lt;input type=&quot;submit&quot; name=&quot;submit&quot; id=&quot;submit-quick-search-taxonomy-category&quot; class=&quot;button button-small quick-search-submit hide-if-js&quot; value=&quot;Search&quot;&gt;			&lt;/p&gt;

              &lt;ul id=&quot;category-search-checklist&quot; data-wp-lists=&quot;list:category&quot; class=&quot;categorychecklist form-no-clear&quot;&gt;
                    &lt;/ul&gt;
            &lt;/div&gt;&lt;!-- /.tabs-panel --&gt;

            &lt;p class=&quot;button-controls&quot;&gt;
              &lt;span class=&quot;list-controls&quot;&gt;
                &lt;a href=&quot;/manage/nav-menus.php?category-tab=all&amp;amp;selectall=1#taxonomy-category&quot; class=&quot;select-all&quot;&gt;Select All&lt;/a&gt;
              &lt;/span&gt;

              &lt;span class=&quot;add-to-menu&quot;&gt;
                &lt;input type=&quot;submit&quot; class=&quot;button-secondary submit-add-to-menu right&quot; value=&quot;Add to Menu&quot; name=&quot;add-taxonomy-menu-item&quot; id=&quot;submit-taxonomy-category&quot;&gt;
                &lt;span class=&quot;spinner&quot;&gt;&lt;/span&gt;
              &lt;/span&gt;
            &lt;/p&gt;

          &lt;/div&gt;&lt;!-- /.taxonomydiv --&gt;
                        &lt;/div&gt;&lt;!-- .inside --&gt;
                    &lt;/div&gt;&lt;!-- .accordion-section-content --&gt;
                  &lt;/li&gt;&lt;!-- .accordion-section --&gt;
                            &lt;li class=&quot;control-section accordion-section hide-if-js  add-post_tag&quot; id=&quot;add-post_tag&quot;&gt;
                    &lt;h3 class=&quot;accordion-section-title hndle&quot; tabindex=&quot;0&quot; title=&quot;Tags&quot;&gt;Tags&lt;/h3&gt;
                    &lt;div class=&quot;accordion-section-content &quot;&gt;
                      &lt;div class=&quot;inside&quot;&gt;
                        &lt;p&gt;No items.&lt;/p&gt;							&lt;/div&gt;&lt;!-- .inside --&gt;
                    &lt;/div&gt;&lt;!-- .accordion-section-content --&gt;
                  &lt;/li&gt;&lt;!-- .accordion-section --&gt;
                            &lt;li class=&quot;control-section accordion-section   add-post_format bottom&quot; id=&quot;add-post_format&quot;&gt;
                    &lt;h3 class=&quot;accordion-section-title hndle&quot; tabindex=&quot;0&quot; title=&quot;Format&quot;&gt;Format&lt;/h3&gt;
                    &lt;div class=&quot;accordion-section-content  bottom&quot;&gt;
                      &lt;div class=&quot;inside&quot;&gt;
                        &lt;p&gt;No items.&lt;/p&gt;							&lt;/div&gt;&lt;!-- .inside --&gt;
                    &lt;/div&gt;&lt;!-- .accordion-section-content --&gt;
                  &lt;/li&gt;&lt;!-- .accordion-section --&gt;
                            &lt;li class=&quot;control-section accordion-section hide-if-js  add-property_feature&quot; id=&quot;add-property_feature&quot;&gt;
                    &lt;h3 class=&quot;accordion-section-title hndle&quot; tabindex=&quot;0&quot; title=&quot;Features&quot;&gt;Features&lt;/h3&gt;
                    &lt;div class=&quot;accordion-section-content &quot;&gt;
                      &lt;div class=&quot;inside&quot;&gt;
                        &lt;p&gt;No items.&lt;/p&gt;							&lt;/div&gt;&lt;!-- .inside --&gt;
                    &lt;/div&gt;&lt;!-- .accordion-section-content --&gt;
                  &lt;/li&gt;&lt;!-- .accordion-section --&gt;
                            &lt;li class=&quot;control-section accordion-section hide-if-js  add-community_feature&quot; id=&quot;add-community_feature&quot;&gt;
                    &lt;h3 class=&quot;accordion-section-title hndle&quot; tabindex=&quot;0&quot; title=&quot;Community Features&quot;&gt;Community Features&lt;/h3&gt;
                    &lt;div class=&quot;accordion-section-content &quot;&gt;
                      &lt;div class=&quot;inside&quot;&gt;
                        &lt;p&gt;No items.&lt;/p&gt;							&lt;/div&gt;&lt;!-- .inside --&gt;
                    &lt;/div&gt;&lt;!-- .accordion-section-content --&gt;
                  &lt;/li&gt;&lt;!-- .accordion-section --&gt;
                      &lt;/ul&gt;&lt;!-- .outer-border --&gt;
          &lt;/div&gt;

          &lt;?php if( $_working || $_pending ) { ?&gt;
            &lt;div class=&quot;updated fade&quot;&gt;
              &lt;p&gt;&lt;?php echo &quot;There are currently &quot; . number_format_i18n( count( $_working ) ) . &quot; active and &quot; . number_format_i18n( count( $_pending ) ) . &quot; pending image imports.&quot;; ?&gt;&lt;/p&gt;
            &lt;/div&gt;
          &lt;?php } ?&gt;

          &lt;?php if( isset( $wp_messages[ &#x27;error&#x27; ] ) &amp;&amp; $wp_messages[ &#x27;error&#x27; ] ) { ?&gt;
            &lt;div class=&quot;error&quot;&gt;
          &lt;?php foreach ($wp_messages[ &#x27;error&#x27; ] as $error_message) { ?&gt;
              &lt;p&gt;&lt;?php echo $error_message; ?&gt;
            &lt;?php }; ?&gt;
          &lt;/div&gt;
          &lt;?php } ?&gt;

          &lt;?php if( isset( $wp_messages[ &#x27;notice&#x27; ] ) &amp;&amp; $wp_messages[ &#x27;notice&#x27; ] ) { ?&gt;
            &lt;div class=&quot;updated fade&quot;&gt;
            &lt;?php foreach ($wp_messages[ &#x27;notice&#x27; ] as $notice_message): ?&gt;
              &lt;p&gt;&lt;?php echo $notice_message; ?&gt;
            &lt;?php endforeach; ?&gt;
            &lt;/div&gt;
          &lt;?php } ?&gt;

          &lt;div id=&quot;wpp_property_import_ajax&quot;&gt;&lt;/div&gt;

          &lt;div class=&quot;wpp-media-progress&quot;&gt;&lt;/div&gt;

          &lt;?php if (!empty( $wpp_property_import[ &#x27;schedules&#x27; ] )) { ?&gt;

            &lt;?php if( count( $wpp_property_import[ &#x27;schedules&#x27; ] ) &gt; 1 ) { ?&gt;
              &lt;ul class=&quot;subsubsub wpp_import_overview_page_element&quot;&gt;
                &lt;li class=&quot;all&quot;&gt;&lt;?php _e( &#x27;Sort by:&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt; &lt;/li&gt;
                &lt;li class=&quot;wpp_i_sort_schedules&quot; sort_direction=&quot;ASC&quot; sort_by=&quot;lastrun&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;?php _e( &#x27;Last Run&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt; |&lt;/li&gt;
                &lt;li class=&quot;wpp_i_sort_schedules&quot; sort_direction=&quot;ASC&quot; sort_by=&quot;created&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;?php _e( &#x27;Created Properties&#x27;, &#x27;wpp&#x27; ); ?&gt; &lt;/a&gt; |&lt;/li&gt;
                &lt;li class=&quot;wpp_i_sort_schedules&quot; sort_direction=&quot;ASC&quot; sort_by=&quot;updated&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;?php _e( &#x27;Updated Properties&#x27;, &#x27;wpp&#x27; ); ?&gt; &lt;/a&gt; | &lt;/li&gt;
                &lt;li class=&quot;wpp_i_sort_schedules&quot; sort_direction=&quot;ASC&quot; sort_by=&quot;total_properties&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;?php _e( &#x27;Total Properties&#x27;, &#x27;wpp&#x27; ); ?&gt; &lt;/a&gt; | &lt;/li&gt;
                &lt;li class=&quot;wpp_i_sort_schedules&quot; sort_direction=&quot;ASC&quot; sort_by=&quot;limit&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;?php _e( &#x27;Limit&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt;&lt;/li&gt;
              &lt;/ul&gt;
            &lt;?php } ?&gt;

            &lt;table id=&quot;wpp_property_import_overview&quot; class=&quot;widefat wpp_import_overview_page_element&quot;&gt;
              &lt;thead&gt;
                &lt;tr&gt;
                  &lt;th&gt;&lt;?php _e( &quot;Saved Import Schedules&quot;, &#x27;wpp&#x27; ); ?&gt;&lt;/th&gt;
                &lt;/tr&gt;
              &lt;/thead&gt;
            &lt;tbody&gt;
            &lt;?php foreach( (array) $wpp_property_import[ &#x27;schedules&#x27; ] as $sch_id =&gt; $sch ) {

              if( empty( $sch_id ) ) {
                continue;
              }

              $this_row_data = array();

              if( $sch[ &#x27;lastrun&#x27; ][ &#x27;time&#x27; ] ) {
                $vital_stats[ $sch_id ][ ] = __( &#x27;Last run &#x27;, &#x27;wpp&#x27; ) . human_time_diff( $sch[ &#x27;lastrun&#x27; ][ &#x27;time&#x27; ] ) . __( &#x27; ago.&#x27;, &#x27;wpp&#x27; );
                $this_row_data[ ]          = &quot;lastrun=\&quot;{$sch[ &#x27;lastrun&#x27; ][&#x27;time&#x27;]}\&quot; &quot;;
              }

              if( $sch[ &#x27;lastrun&#x27; ][ &#x27;u&#x27; ] ) {
                $vital_stats[ $sch_id ][ ] = __( &#x27;Updated &#x27;, &#x27;wpp&#x27; ) . $sch[ &#x27;lastrun&#x27; ][ &#x27;u&#x27; ] . __( &#x27; objects.&#x27;, &#x27;wpp&#x27; );
                $this_row_data[ ]          = &quot;updated=\&quot;{$sch[ &#x27;lastrun&#x27; ][&#x27;u&#x27;]}\&quot; &quot;;
              }

              if( $sch[ &#x27;lastrun&#x27; ][ &#x27;c&#x27; ] ) {
                $vital_stats[ $sch_id ][ ] = __( &#x27;Created &#x27;, &#x27;wpp&#x27; ) . $sch[ &#x27;lastrun&#x27; ][ &#x27;c&#x27; ] . __( &#x27; objects.&#x27;, &#x27;wpp&#x27; );
                $this_row_data[ ]          = &quot;created=\&quot;{$sch[ &#x27;lastrun&#x27; ][&#x27;c&#x27;]}\&quot; &quot;;
              }

              if( $sch[ &#x27;limit_properties&#x27; ] ) {
                $vital_stats[ $sch_id ][ ] = __( &#x27;Limited to &#x27;, &#x27;wpp&#x27; ) . $sch[ &#x27;limit_properties&#x27; ] . __( &#x27; objects.&#x27;, &#x27;wpp&#x27; );
                $this_row_data[ ]          = &quot;limit=\&quot;{$sch[&#x27;limit_properties&#x27;]}\&quot; &quot;;
              }

              if( $total_properties = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT COUNT( ID ) FROM {$wpdb-&gt;posts} p LEFT JOIN {$wpdb-&gt;postmeta} pm ON p.ID = pm.post_id WHERE post_type = &#x27;property&#x27; AND meta_key = &#x27;wpp_import_schedule_id&#x27; and meta_value = %s &quot;, $sch_id ) ) ) {
                $vital_stats[ $sch_id ][ ] = __( &#x27;Total Properties: &#x27;, &#x27;wpp&#x27; ) . Utility::format_numeric( $total_properties );
                $this_row_data[ ]          = &quot;total_properties=\&quot;{$total_properties}\&quot; &quot;;
              } else {
                $total_properties = false;
              }


              ?&gt;
              &lt;tr &lt;?php echo implode( &#x27;&#x27;, $this_row_data ); ?&gt; class=&quot;wpp_i_schedule_row&quot; schedule_id=&quot;&lt;?php echo $sch_id; ?&gt;&quot; import_title=&quot;&lt;?php echo esc_attr( $sch[ &#x27;name&#x27; ] ); ?&gt;&quot;&gt;
                &lt;td class=&quot;post-title column-title&quot;&gt;
                  &lt;ul&gt;
                    &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;#&lt;?php echo $sch_id; ?&gt;&quot; schedule_id=&quot;&lt;?php echo $sch_id; ?&gt;&quot; class=&quot;wpp_property_import_edit_report&quot;&gt;&lt;?php echo $sch[ &#x27;name&#x27; ]; ?&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
                    &lt;li&gt;
                      &lt;?php _e( &#x27;Source URL:&#x27;, &#x27;wpp&#x27; ); ?&gt;
                      &lt;span class=&quot;wpp_i_overview_special_data&quot;&gt;&lt;?php echo $sch[ &#x27;url&#x27; ]; ?&gt;&lt;/span&gt;
                    &lt;/li&gt;

                    &lt;li&gt;
                      &lt;?php _e( &#x27;Schedule ID:&#x27;, &#x27;wpp&#x27; ); ?&gt;
                      &lt;span class=&quot;&quot; data-schedule-&quot;&lt;?php echo $sch_id; ?&gt;&quot;&gt;&lt;?php echo $sch_id; ?&gt;&lt;/span&gt;
                    &lt;/li&gt;

                    &lt;?php if( $media_progress[ $sch_id ][ &#x27;pending&#x27; ] ) { ?&gt;
                      &lt;li&gt;
                        Pending Media: &lt;?php echo number_format_i18n( $media_progress[ $sch_id ][ &#x27;pending&#x27; ] ); ?&gt; |
                        &lt;a href=&quot;&lt;?php echo get_bloginfo( &#x27;home&#x27; ) . &quot;/?wpp_manage_pending_images=&quot; . $sch[ &#x27;hash&#x27; ] . &quot;&amp;echo_log=true&quot;; ?&gt;&quot; target=&quot;_blank&quot;/&gt;&lt;?php _e( &#x27;Import Media&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt;
                      &lt;/li&gt;
                    &lt;?php } ?&gt;

                    &lt;?php if( $media_progress[ $sch_id ][ &#x27;working&#x27; ] ) { ?&gt;
                      &lt;li&gt;
                        Working: &lt;?php echo number_format_i18n( $media_progress[ $sch_id ][ &#x27;working&#x27; ] ); ?&gt;
                        Last Update: &lt;?php echo human_time_diff( strtotime( $media_progress[ $sch_id ][ &#x27;modified&#x27; ] ), strtotime( current_time( &#x27;mysql&#x27; ) ) ) . &#x27; ago&#x27;; ?&gt;
                        &lt;a href=&quot;&lt;?php echo get_bloginfo( &#x27;home&#x27; ) . &quot;/?wpp_kill_pending_image_processes=&quot; . $sch[ &#x27;hash&#x27; ] . &quot;&amp;echo_log=true&quot;; ?&gt;&quot; target=&quot;_blank&quot;/&gt;&lt;?php _e( &#x27;Kill Processes&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt;
                      &lt;/li&gt;
                    &lt;?php } ?&gt;

                    &lt;li&gt;&lt;?php _e( &#x27;Cron Command:&#x27;, &#x27;wpp&#x27; ); ?&gt;
                      &lt;span class=&quot;wpp_i_overview_special_data&quot;&gt;php -q &lt;?php echo $cron_path . &#x27; do_xml_import &#x27; . $sch[ &#x27;hash&#x27; ] . ( is_multisite() ? &quot; &quot; . parse_url( get_bloginfo( &#x27;url&#x27; ), PHP_URL_HOST ) . parse_url( get_bloginfo( &#x27;url&#x27; ), PHP_URL_PATH ) : &#x27;&#x27; ); ?&gt;&lt;/span&gt;
                    &lt;/li&gt;

                    &lt;?php if( $vital_stats[ $sch_id ] ) { ?&gt;
                      &lt;li&gt;&lt;span class=&quot;wpp_i_overview_special_data&quot;&gt;&lt;?php echo implode( &#x27; | &#x27;, $vital_stats[ $sch_id ] ); ?&gt;&lt;/span&gt;&lt;/li&gt;
                    &lt;?php } ?&gt;
                    &lt;li&gt;
                      &lt;a href=&quot;#&lt;?php echo $sch_id; ?&gt;&quot; schedule_id=&quot;&lt;?php echo $sch_id; ?&gt;&quot; class=&quot;wpp_property_import_edit_report&quot;&gt;&lt;?php _e( &#x27;Edit&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt; |
                      &lt;a href=&quot;#&quot; schedule_id=&quot;&lt;?php echo $sch_id; ?&gt;&quot; class=&quot;wpp_property_import_delete_report&quot;&gt;&lt;?php _e( &#x27;Delete&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt; |
                      &lt;a href=&quot;&lt;?php echo get_bloginfo( &#x27;home&#x27; ) . &quot;/?wpp_schedule_import=&quot; . $sch[ &#x27;hash&#x27; ] . &quot;&amp;echo_log=true&quot;; ?&gt;&quot; target=&quot;_blank&quot;/&gt;&lt;?php _e( &#x27;Run Import&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt;
                      |
                      &lt;a href=&quot;&lt;?php echo wp_nonce_url( &quot;edit.php?post_type=property&amp;page=wpp_property_import&amp;wpp_action=download-wpp-import-schedule&amp;schedule_id={$sch_id}&quot;, &#x27;download-wpp-import-schedule&#x27; ); ?&gt;&quot; class=&quot;&quot;&gt;&lt;?php _e( &#x27;Save to File&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt; |
                      &lt;?php if( $total_properties &gt; 0 ) { ?&gt;
                        &lt;a href=&quot;#&quot; schedule_id=&quot;&lt;?php echo $sch_id; ?&gt;&quot; class=&quot;wppi_delete_all_feed_properties&quot;&gt;&lt;?php _e( &#x27;Delete All Properties&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/a&gt;
                      &lt;?php } ?&gt;
                      &lt;span class=&quot;wpp_loader&quot;&gt;&lt;/span&gt;
                      &lt;div class=&quot;run_progressbar&quot; style=&quot;width:500px&quot;&gt;&lt;/div&gt;
                    &lt;/li&gt;
                  &lt;/ul&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
            &lt;?php } ?&gt;
            &lt;/tbody&gt;
          &lt;/table&gt;

          &lt;?php } else { ?&gt;
            &lt;p class=&quot;wpp_import_overview_page_element&quot;&gt;&lt;?php echo __( &#x27;You do not have any saved schedules. Create one now.&#x27;, &#x27;wpp&#x27; ); ?&gt;
          &lt;?php } ?&gt;

          &lt;div class=&quot;wpp_import_import_schedule wpp_import_overview_page_element&quot;&gt;
            &lt;form method=&quot;post&quot; action=&quot;&lt;?php echo admin_url( &#x27;edit.php?post_type=property&amp;page=wpp_property_import&#x27; ); ?&gt;&quot; enctype=&quot;multipart/form-data&quot;&gt;

            &lt;input type=&quot;hidden&quot; name=&quot;wpp_action&quot; value=&quot;import_wpp_schedule&quot;/&gt;
            &lt;input type=&quot;hidden&quot; name=&quot;_wpnonce&quot; value=&quot;&lt;?php echo wp_create_nonce( &#x27;wpp_import_import_schedule&#x27; ); ?&gt;&quot;/&gt;
            &lt;?php _e( &quot;Import Schedule&quot;, &#x27;wpp&#x27; ); ?&gt;: &lt;input name=&quot;wpp_import[import_schedule]&quot; type=&quot;file&quot;/&gt;

            &lt;input type=&quot;submit&quot; value=&quot;&lt;?php _e( &#x27;Upload File&#x27;, &#x27;wpp&#x27; ); ?&gt;&quot; class=&quot;btn&quot;/&gt;
            &lt;/form&gt;
          &lt;/div&gt;

        &lt;/div&gt;

      &lt;?php

      }

      /**
       * Renders Add/Edit Schedule page
       *
       * @param array $settings
       * @param bool  $new_schedule
       */
      static public function edit_schedule_template( $settings, $new_schedule = false ) {
        global $wp_properties, $wpp_property_import;

        ?&gt;

        &lt;div class=&quot;wpp_property_import_setup&quot; import_type=&quot;&lt;?php echo( $settings[ &#x27;source_type&#x27; ] ? $settings[ &#x27;source_type&#x27; ] : &#x27;xml&#x27; ); ?&gt;&quot;&gt;
          &lt;form id=&quot;wpp_property_import_setup&quot; action=&quot;#&quot;&gt;
          &lt;table class=&quot;form-table&quot;&gt;
            &lt;tbody&gt;
            &lt;tr&gt;
              &lt;th&gt;
                &lt;label for=&quot;wpp_property_import_name&quot;&gt;&lt;?php _e( &#x27;Import name&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
              &lt;/th&gt;
              &lt;td&gt;
                &lt;input class=&quot;regular-text wpp_property_import_name&quot; id=&quot;wpp_property_import_name&quot; name=&quot;wpp_property_import[name]&quot; type=&quot;text&quot; value=&quot;&lt;?php echo $settings[ &#x27;name&#x27; ] ?&gt;&quot;/&gt;
              &lt;/td&gt;
            &lt;/tr&gt;

            &lt;tr class=&quot;step_one&quot;&gt;
              &lt;th&gt;
                &lt;label for=&quot;wpp_property_import_remote_url&quot;&gt;&lt;?php _e( &#x27;Source&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
              &lt;/th&gt;
            &lt;td&gt;
              &lt;ul class=&quot;wppi_source_option_preview_wrapper&quot;&gt;
                &lt;li&gt;
                  &lt;label for=&quot;wpp_property_import_remote_url&quot;&gt;&lt;?php _e( &#x27;URL&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
                  &lt;input class=&quot;regular-text wpp_property_import_remote_url&quot; name=&quot;wpp_property_import[url]&quot; type=&quot;text&quot; id=&quot;wpp_property_import_remote_url&quot; value=&quot;&lt;?php echo esc_attr( $settings[ &#x27;url&#x27; ] ); ?&gt;&quot;/&gt;

                  &lt;label for=&quot;wpp_property_import_source_type&quot;&gt;&lt;?php _e( &#x27;Type:&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
                  &lt;select id=&quot;wpp_property_import_source_type&quot; name=&quot;wpp_property_import[source_type]&quot;&gt;
                    &lt;option value=&quot;&quot;&gt;  &lt;/option&gt;
                    &lt;option &lt;?php selected( $settings[ &#x27;source_type&#x27; ], &#x27;xml&#x27; ); ?&gt; value=&quot;xml&quot;&gt;&lt;?php _e( &quot;XML / JSON&quot;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                    &lt;option &lt;?php selected( $settings[ &#x27;source_type&#x27; ], &#x27;csv&#x27; ); ?&gt; value=&quot;csv&quot;&gt;&lt;?php _e( &quot;CSV&quot;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                    &lt;option &lt;?php selected( $settings[ &#x27;source_type&#x27; ], &#x27;gs&#x27; ); ?&gt;   value=&quot;gs&quot;&gt;&lt;?php _e( &quot;Google Spreadsheet&quot;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                    &lt;option &lt;?php selected( $settings[ &#x27;source_type&#x27; ], &#x27;wpp&#x27; ); ?&gt;   value=&quot;wpp&quot;&gt;&lt;?php _e( &quot;WP-Property Feed&quot;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                    &lt;option &lt;?php selected( $settings[ &#x27;source_type&#x27; ], &#x27;rets&#x27; ); ?&gt;   value=&quot;rets&quot;&gt;&lt;?php _e( &quot;RETS&quot;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                  &lt;/select&gt;
                  &lt;span id=&quot;wpp_property_import_source_status&quot; class=&quot;button&quot;&gt;&lt;/span&gt;
                &lt;/li&gt;
                &lt;li class=&quot;wpp_i_source_feedback&quot;&gt;&lt;/li&gt;
            &lt;/ul&gt;

            &lt;ul class=&quot;wpp_something_advanced_wrapper wppi_source_option_preview_wrapper&quot;&gt;

              &lt;li class=&quot;wpp_i_source_specific wpp_i_advanced_source_settings&quot; wpp_i_source_type=&quot;xml&quot;&gt;
                &lt;input type=&quot;checkbox&quot; id=&quot;wpp_property_import_use_postauth_checkbox&quot; name=&quot;wpp_property_import[postauth]&quot; &lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;postauth&#x27; ] ); ?&gt;/&gt;
                &lt;label class=&quot;description&quot; for=&quot;wpp_property_import_use_postauth_checkbox&quot;&gt;&lt;?php echo __( &#x27;Send GET variables as POST data.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_gs_options wpp_i_advanced_source_settings&quot; wpp_i_source_type=&quot;gs&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;regular-text&quot; name=&quot;wpp_property_import[google_username]&quot; id=&#x27;wpp_property_import_username&#x27; value=&quot;&lt;?php echo $settings[ &#x27;google_username&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_username&quot;&gt;&lt;?php _e( &#x27;Google Username&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_gs_options wpp_i_advanced_source_settings&quot; wpp_i_source_type=&quot;gs&quot;&gt;
                &lt;input type=&quot;password&quot; class=&quot;regular-text&quot; name=&quot;wpp_property_import[google_password]&quot; id=&#x27;wpp_property_import_password&#x27; value=&quot;&lt;?php echo $settings[ &#x27;google_password&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_password&quot;&gt;&lt;?php _e( &#x27;Google Password&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_gs_options wpp_i_advanced_source_settings&quot; wpp_i_source_type=&quot;gs&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;regular-text&quot; name=&quot;wpp_property_import[google_extra_query]&quot; id=&#x27;wpp_property_import_extra_query&#x27; value=&quot;&lt;?php echo $settings[ &#x27;google_extra_query&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_extra_query&quot;&gt;&lt;?php _e( &#x27;Google Extra Query Vars&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;&lt;br/&gt;
                &lt;span class=&quot;description&quot;&gt;&lt;?php _e( &#x27;See the &lt;a href=&quot;http://code.google.com/apis/spreadsheets/data/3.0/reference.html#ListParameters&quot; target=&quot;_blank&quot;&gt;Google Spreadsheet API docs&lt;/a&gt; for the format of this field ( should be name value pairs, without the beginning &quot;?&quot; )&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_rets_options&quot; wpp_i_source_type=&quot;rets&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;regular-text wpp_required&quot; name=&quot;wpp_property_import[rets_username]&quot; id=&#x27;wpp_property_import_rets_username&#x27; value=&quot;&lt;?php echo $settings[ &#x27;rets_username&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_rets_username&quot;&gt;&lt;?php _e( &#x27;RETS Username.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_rets_options&quot; wpp_i_source_type=&quot;rets&quot;&gt;
                &lt;input type=&quot;password&quot; class=&quot;regular-text wpp_required&quot; name=&quot;wpp_property_import[rets_password]&quot; id=&#x27;wpp_property_import_rets_password&#x27; value=&quot;&lt;?php echo $settings[ &#x27;rets_password&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_rets_password&quot;&gt;&lt;?php _e( &#x27;RETS Password.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_rets_options wpp_i_advanced_source_settings&quot; wpp_i_source_type=&quot;rets&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;regular-text&quot; placeholder=&quot;Property&quot; name=&quot;wpp_property_import[rets_resource]&quot; id=&#x27;wpp_property_import_rets_resource&#x27; value=&quot;&lt;?php echo $settings[ &#x27;rets_resource&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_rets_class&quot;&gt;&lt;?php _e( &#x27;Property Resource.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;span class=&quot;description&quot;&gt;&lt;?php _e( &#x27;Default is &quot;Property&quot;&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;&lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_rets_options&quot; wpp_i_source_type=&quot;rets&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;regular-text wpp_required&quot; name=&quot;wpp_property_import[rets_class]&quot; id=&#x27;wpp_property_import_rets_class&#x27; value=&quot;&lt;?php echo $settings[ &#x27;rets_class&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_rets_class&quot;&gt;&lt;?php _e( &#x27;Property Resource Class.&#x27;, &#x27;wpp&#x27; ); ?&gt; &lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_rets_options&quot; wpp_i_source_type=&quot;rets&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;regular-text wpp_required&quot; placeholder=&quot;ListingKey&quot; name=&quot;wpp_property_import[rets_pk]&quot; id=&#x27;wpp_property_import_rets_pk&#x27; value=&quot;&lt;?php echo $settings[ &#x27;rets_pk&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_rets_pk&quot;&gt;&lt;?php _e( &#x27;Primary Key for Resource.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;span class=&quot;description&quot;&gt;&lt;?php _e( &#x27;Also referred to as &quot;Key Field&quot;. Default is &quot;ListingKey&quot;&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;&lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_rets_options wpp_i_advanced_source_settings&quot; wpp_i_source_type=&quot;rets&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;regular-text&quot; placeholder=&quot;Photo&quot; name=&quot;wpp_property_import[rets_photo]&quot; id=&#x27;wpp_property_import_rets_photo&#x27; value=&quot;&lt;?php echo $settings[ &#x27;rets_photo&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_rets_photo&quot;&gt;&lt;?php _e( &#x27;Photo Object.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;span class=&quot;description&quot;&gt;&lt;?php _e( &#x27;Default is &quot;Photo&quot;&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;&lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_rets_options wpp_i_advanced_source_settings&quot; wpp_i_source_type=&quot;rets&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;regular-text&quot; placeholder=&quot;WP-Property/1.0&quot; name=&quot;wpp_property_import[rets_agent]&quot; id=&#x27;wpp_property_import_rets_agent&#x27; value=&quot;&lt;?php echo $settings[ &#x27;rets_agent&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_rets_agent&quot;&gt;&lt;?php _e( &#x27;User-Agent String.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;span class=&quot;description&quot;&gt;&lt;?php _e( &#x27;May be required by your RETS&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;&lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_rets_options wpp_i_advanced_source_settings&quot; wpp_i_source_type=&quot;rets&quot;&gt;
                &lt;input type=&quot;text&quot; class=&quot;regular-text&quot; name=&quot;wpp_property_import[rets_agent_password]&quot; id=&#x27;wpp_property_import_rets_agent_password&#x27; value=&quot;&lt;?php echo $settings[ &#x27;rets_agent_password&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_rets_agent_password&quot;&gt;&lt;?php _e( &#x27;User-Agent Password.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;span class=&quot;description&quot;&gt;&lt;?php _e( &#x27;May be required by your RETS&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;&lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_rets_options wpp_i_advanced_source_settings&quot; wpp_i_source_type=&quot;rets&quot;&gt;
                &lt;?php /** @todo Remove inline styling - adding for now as quick fix -- williams@UD */ ?&gt;
                &lt;select style=&quot;width:25em;&quot; name=&quot;wpp_property_import[rets_version]&quot; id=&#x27;wpp_property_import_rets_version&#x27;&gt;
                  &lt;?php foreach( array( &#x27;RETS/1.0&#x27; =&gt; &#x27;1.0&#x27;, &#x27;RETS/1.5&#x27; =&gt; &#x27;1.5&#x27;, &#x27;RETS/1.7&#x27; =&gt; &#x27;1.7&#x27;, &#x27;RETS/1.7.2&#x27; =&gt; &#x27;1.7.2&#x27;, ) as $key =&gt; $option ) { ?&gt;
                    &lt;option value=&#x27;&lt;?php echo $key; ?&gt;&#x27; &lt;?php echo( $settings[ &#x27;rets_version&#x27; ] == $key ? &#x27;selected=&quot;selected&quot;&#x27; : &#x27;&#x27; ); ?&gt;&gt;&lt;?php echo $option; ?&gt;&lt;/option&gt;
                  &lt;?php } ?&gt;
                &lt;/select&gt;
                &lt;label for=&quot;wpp_property_import_rets_version&quot;&gt;&lt;?php _e( &#x27;RETS Version.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;span class=&quot;description&quot;&gt;&lt;?php _e( &#x27;Version is set by your RETS provider.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;&lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_i_source_specific wpp_property_import_rets_options&quot; wpp_i_source_type=&quot;rets&quot;&gt;
                &lt;?php /* &lt;textarea placeholder=&quot;(ListingStatus=|Active)&quot; name=&quot;wpp_property_import[rets_query]&quot; id=&#x27;wpp_property_import_rets_query&#x27; style=&quot;width:25em;max-width: 90%;&quot;&gt;&lt;?php echo esc_textarea( $settings[ &#x27;rets_query&#x27; ] ); ?&gt;&lt;/textarea&gt;*/ ?&gt;
                &lt;input type=&quot;text&quot; class=&quot;regular-text&quot; placeholder=&quot;(ListingStatus=|Active)&quot; style=&quot;width: 35em;&quot; name=&quot;wpp_property_import[rets_query]&quot; id=&#x27;wpp_property_import_rets_query&#x27; value=&quot;&lt;?php echo $settings[ &#x27;rets_query&#x27; ] ?&gt;&quot;/&gt;
                &lt;label for=&quot;wpp_property_import_rets_query&quot;&gt;&lt;?php _e( &#x27;Property Query.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;span class=&quot;description&quot;&gt;&lt;?php _e( &#x27;Accepts &lt;a href=&quot;https://www.flexmls.com/support/rets/tutorials/dmql/&quot; target=&quot;_blank&quot;&gt;DMQL&lt;/a&gt; - Default is &quot;(ListingStatus=|Active)&quot;&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;
                &lt;/label&gt;
              &lt;/li&gt;
              &lt;li class=&quot;wpp_show_advanced_wrapper&quot;&gt;
                &lt;span class=&quot;wpp_show_advanced&quot; advanced_option_class=&quot;wpp_i_advanced_source_settings&quot; show_type_source=&quot;wpp_property_import_source_type&quot; show_type_element_attribute=&quot;wpp_i_source_type&quot;&gt;&lt;?php _e( &#x27;Toggle Advanced Source Options&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;
              &lt;/li&gt;
            &lt;/ul&gt;

            &lt;ul class=&quot;wppi_source_option_preview_wrapper&quot;&gt;
              &lt;li&gt;
                &lt;label for=&quot;wpp_property_import_choose_root_element&quot; class=&quot;description&quot;&gt;&lt;?php echo __( &#x27;Root XPath Query:&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
                &lt;input type=&#x27;text&#x27; id=&quot;wpp_property_import_choose_root_element&quot; name=&quot;wpp_property_import[root_element]&quot; value=&quot;&lt;?php echo esc_attr( $settings[ &#x27;root_element&#x27; ] ); ?&gt;&quot; class=&quot;wpp_property_import_choose_root_element&quot;/&gt;
                &lt;span class=&quot;wpp_link wpp_toggle_contextual_help&quot; wpp_scroll_to=&quot;#tab-link-xpath-query-to-property-elements&quot;&gt;&lt;?php _e( &#x27;What is this?&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;
              &lt;/li&gt;
            &lt;/ul&gt;

            &lt;ul class=&quot;wppi_source_option_preview_wrapper&quot;&gt;
              &lt;li&gt;
                &lt;ul&gt;
                  &lt;li&gt;
                    &lt;input type=&quot;button&quot; id=&quot;wpp_i_preview_raw_data&quot; value=&quot;&lt;?php _e( &#x27;Preview Raw Data&#x27;, &#x27;wpp&#x27; ); ?&gt;&quot; class=&quot;button-secondary&quot;/&gt;
                    &lt;span class=&quot;wpp_i_preview_raw_data_result&quot;&gt;&lt;/span&gt;
                    &lt;span class=&quot;wpp_i_close_preview hidden wpp_link&quot;&gt;&lt;?php _e( &#x27;Close Preview&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;
                  &lt;/li&gt;
                  &lt;li&gt;
                    &lt;div class=&quot;wppi_raw_preview_result&quot;&gt;&lt;/div&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;

            &lt;/td&gt;
          &lt;/tr&gt;

          &lt;tr&gt;
            &lt;th&gt;
              &lt;label for=&quot;wpp_property_import_property_type&quot;&gt;&lt;?php _e( &#x27;Default Property Type&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
            &lt;/th&gt;
            &lt;td&gt;
              &lt;select name=&quot;wpp_property_import[property_type]&quot; id=&quot;wpp_property_import_property_type&quot;&gt;
                &lt;?php foreach( $wp_properties[ &#x27;property_types&#x27; ] as $property_slug =&gt; $property_title ): ?&gt;
                  &lt;option value=&quot;&lt;?php echo $property_slug; ?&gt;&quot; &lt;?php selected( $property_slug, $settings[ &#x27;property_type&#x27; ] ); ?&gt;&gt;&lt;?php echo $property_title; ?&gt;&lt;/option&gt;
                &lt;?php endforeach; ?&gt;
              &lt;/select&gt;
              &lt;span class=&quot;description&quot;&gt;&lt;?php _e( &#x27;Will be defaulted to if no xPath rule exists for the &quot;Property Type&quot;.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;
            &lt;/td&gt;
          &lt;/tr&gt;

          &lt;tr&gt;

            &lt;th&gt;
              &lt;label for=&quot;wpp_property_import_settings&quot;&gt;&lt;?php _e( &#x27;Advanced Options&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
            &lt;/th&gt;
            &lt;td&gt;

              &lt;input type=&quot;hidden&quot; name=&quot;wpp_property_import[is_scheduled]&quot; value=&quot;on&quot;/&gt;

              &lt;ul class=&quot;wpp_property_import_settings hidden&quot;&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;label class=&quot;description&quot; for=&quot;wpp_property_limit_scanned_properties&quot;&gt;&lt;?php echo __( &#x27;&lt;b&gt;Pre-QC Limit:&lt;/b&gt; Limit import to the first&#x27;, &#x27;wpp&#x27; ); ?&gt;
                    &lt;input type=&quot;text&quot; class=&quot;wpp_xmli_enforce_integer&quot; id=&quot;wpp_property_limit_scanned_properties&quot; name=&quot;wpp_property_import[limit_scanned_properties]&quot; value=&quot;&lt;?php echo( empty( $settings[ &#x27;limit_scanned_properties&#x27; ] ) ? &#x27;&#x27; : $settings[ &#x27;limit_scanned_properties&#x27; ] ); ?&gt;&quot;/&gt;
                    &lt;?php echo __( &#x27;properties in the feed.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                    &lt;span wpp_scroll_to=&quot;h3.limit_import&quot; class=&quot;wpp_link wpp_toggle_contextual_help&quot;&gt;&lt;?php _e( &#x27;More about limits.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;
                  &lt;/label&gt;
                &lt;/li&gt;
                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;label class=&quot;description&quot;&gt;&lt;?php _e( &#x27;&lt;b&gt;Post-QC Limit:&lt;/b&gt; Limit import to the first&#x27;, &#x27;wpp&#x27; ); ?&gt;
                    &lt;input type=&quot;text&quot; class=&quot;wpp_xmli_enforce_integer&quot; id=&quot;wpp_property_limit_properties&quot; name=&quot;wpp_property_import[limit_properties]&quot; value=&quot;&lt;?php echo( empty( $settings[ &#x27;limit_properties&#x27; ] ) ? &#x27;&#x27; : $settings[ &#x27;limit_properties&#x27; ] ); ?&gt;&quot;/&gt;
                    &lt;?php echo __( &#x27;created properties that have passed quality standards.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;label class=&quot;description&quot;&gt;&lt;?php _e( &#x27;Number of image importing threads spawned&#x27;, &#x27;wpp&#x27; ); ?&gt;
                    &lt;input type=&quot;text&quot; class=&quot;wpp_xmli_enforce_integer&quot; id=&quot;wpp_property_limit_properties&quot; name=&quot;wpp_property_import[num_worker_threads]&quot; value=&quot;&lt;?php echo( empty( $settings[ &#x27;num_worker_threads&#x27; ] ) ? &#x27;&#x27; : $settings[ &#x27;num_worker_threads&#x27; ] ); ?&gt;&quot;/&gt;
                    &lt;span class=&quot;description&quot;&gt;&lt;?php _e( &#x27;Default is 10. Not recommended to increase the number.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;?php printf(
                    __( &#x27;Only import images that are over %1spx in width, and %2spx in height.&#x27;, &#x27;wpp&#x27; ),
                    &#x27;&lt;input type=&quot;text&quot; value=&quot;&#x27; . $settings[ &quot;min_image_width&quot; ] . &#x27;&quot; name=&quot;wpp_property_import[min_image_width]&quot; /&gt;&#x27;,
                    &#x27;&lt;input type=&quot;text&quot; value=&quot;&#x27; . $settings[ &quot;min_image_height&quot; ] . &#x27;&quot;  name=&quot;wpp_property_import[min_image_height]&quot; /&gt;&#x27;
                  );
                  ?&gt;
                  &lt;span class=&quot;description&quot;&gt;&lt;?php _e( &#x27;Minimum sizes are ignored if blank.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;label class=&quot;description&quot;&gt;&lt;?php echo __( &#x27;Imported properties must have at least &#x27;, &#x27;wpp&#x27; ); ?&gt;
                    &lt;input type=&quot;text&quot; id=&quot;wpp_i_minimum_images&quot; class=&quot;wpp_xmli_enforce_integer&quot; name=&quot;wpp_property_import[minimum_images]&quot; value=&quot;&lt;?php echo( empty( $settings[ &#x27;minimum_images&#x27; ] ) ? &#x27;&#x27; : $settings[ &#x27;minimum_images&#x27; ] ); ?&gt;&quot;/&gt;&lt;?php echo __( &#x27;, but no more than &#x27;, &#x27;wpp&#x27; ); ?&gt;
                    &lt;input type=&quot;text&quot; id=&quot;wpp_i_limit_images&quot; name=&quot;wpp_property_import[limit_images]&quot; value=&quot;&lt;?php echo( empty( $settings[ &#x27;limit_images&#x27; ] ) ? &#x27;&#x27; : $settings[ &#x27;limit_images&#x27; ] ); ?&gt;&quot;/&gt;
                    &lt;?php echo __( &#x27; valid images.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;label class=&quot;description&quot; for=&quot;wpp_property_reimport_delay&quot;&gt;&lt;?php echo __( &#x27;Do not update properties that have been imported less than &#x27;, &#x27;wpp&#x27; ); ?&gt;
                    &lt;input type=&quot;text&quot; id=&quot;wpp_property_reimport_delay&quot; name=&quot;wpp_property_import[reimport_delay]&quot; value=&quot;&lt;?php echo( empty( $settings[ &#x27;reimport_delay&#x27; ] ) ? 0 : $settings[ &#x27;reimport_delay&#x27; ] ); ?&gt;&quot;/&gt;
                    &lt;?php echo __( &#x27;hour(s) ago.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;label class=&quot;description&quot;&gt;
                    &lt;input type=&quot;checkbox&quot; name=&quot;wpp_property_import[automatically_feature_first_image]&quot; value=&quot;on&quot;&lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;automatically_feature_first_image&#x27; ] ); ?&gt; /&gt;
                    &lt;?php echo __( &#x27;Automatically set the first image as the thumbnail.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;input type=&quot;checkbox&quot; id=&quot;wpp_property_import_remove_non_existant_properties&quot; name=&quot;wpp_property_import[remove_non_existant]&quot; value=&quot;on&quot;&lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;remove_non_existant&#x27; ] ); ?&gt; /&gt;
                  &lt;label class=&quot;description&quot; for=&quot;wpp_property_import_remove_non_existant_properties&quot;&gt;
                    &lt;?php echo __( &#x27;Remove properties that are no longer in source XML from this site\&#x27;s database. This can now be done if the the import configuration does not have a Pre-QC or Post-QC Limit.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;input type=&quot;checkbox&quot; id=&quot;wpp_property_remove_images&quot; name=&quot;wpp_property_import[remove_images]&quot; value=&quot;on&quot; &lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;remove_images&#x27; ] ); ?&gt;/&gt;
                  &lt;label class=&quot;description&quot; for=&quot;wpp_property_remove_images&quot;&gt;&lt;?php echo __( &#x27;When updating an existing property, remove all old images before downloading new ones.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;input type=&quot;checkbox&quot; id=&quot;wpp_send_email_updates&quot; name=&quot;wpp_property_import[send_email_updates]&quot; value=&quot;on&quot; &lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;send_email_updates&#x27; ] ); ?&gt;/&gt;
                  &lt;label class=&quot;description&quot; for=&quot;wpp_send_email_updates&quot;&gt;
                    &lt;?php printf( __( &#x27;Send email updates to the site admin e-mail address ( %1s ) when import schedules are executed and completed.&#x27;, &#x27;wpp&#x27; ), get_option( &#x27;admin_email&#x27; ) ); ?&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;input type=&quot;checkbox&quot; id=&quot;wpp_property_import_remove_all_from_this_source&quot; name=&quot;wpp_property_import[remove_all_from_this_source]&quot; value=&quot;on&quot;&lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;remove_all_from_this_source&#x27; ] ); ?&gt; /&gt;
                  &lt;label class=&quot;description&quot; for=&quot;wpp_property_import_remove_all_from_this_source&quot;&gt;
                    &lt;?php echo __( &#x27;Remove all properties that were originally imported from this feed on import.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;input type=&quot;checkbox&quot; id=&quot;wpp_property_import_remove_all_before_import&quot; name=&quot;wpp_property_import[remove_all_before_import]&quot; value=&quot;on&quot;&lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;remove_all_before_import&#x27; ] ); ?&gt; /&gt;
                  &lt;label class=&quot;description&quot; for=&quot;wpp_property_import_remove_all_before_import&quot;&gt;
                    &lt;?php echo __( &#x27;Completely remove &lt;b&gt;all&lt;/b&gt; existing properties prior to import.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;input type=&quot;checkbox&quot; id=&quot;wpp_property_fix_caps&quot; name=&quot;wpp_property_import[fix_caps]&quot; value=&quot;on&quot;&lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;fix_caps&#x27; ] ); ?&gt; /&gt;
                  &lt;label class=&quot;description&quot; for=&quot;wpp_property_fix_caps&quot;&gt;
                    &lt;?php echo __( &#x27;Fix strings that are in all caps.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;input type=&quot;checkbox&quot; id=&quot;wpp_property_force_remove_formatting&quot; name=&quot;wpp_property_import[force_remove_formatting]&quot; value=&quot;on&quot;&lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;force_remove_formatting&#x27; ] ); ?&gt; /&gt;
                  &lt;label class=&quot;description&quot; for=&quot;wpp_property_force_remove_formatting&quot;&gt;
                    &lt;?php echo __( &#x27;Scan for any formatting tags and strip them out.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;?php if( class_exists( &#x27;class_wpp_slideshow&#x27; ) ) { ?&gt;
                  &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                    &lt;input type=&quot;checkbox&quot; id=&quot;wpp_property_automatically_load_slideshow_images&quot; name=&quot;wpp_property_import[automatically_load_slideshow_images]&quot; value=&quot;on&quot;&lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;automatically_load_slideshow_images&#x27; ] ); ?&gt; /&gt;
                    &lt;label class=&quot;description&quot; for=&quot;wpp_property_automatically_load_slideshow_images&quot;&gt;
                      &lt;?php echo __( &#x27;Automatically load imported images into property slideshow.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                    &lt;/label&gt;
                  &lt;/li&gt;
                &lt;?php } ?&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;input type=&quot;checkbox&quot; id=&quot;wpp_import_revalidate_addreses_on_completion&quot; name=&quot;wpp_property_import[revalidate_addreses_on_completion]&quot; value=&quot;on&quot;&lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;revalidate_addreses_on_completion&#x27; ] ); ?&gt; /&gt;
                  &lt;label class=&quot;description&quot; for=&quot;wpp_import_revalidate_addreses_on_completion&quot;&gt;
                    &lt;?php echo __( &#x27;Geolocate imported listings, if geolocation not already done.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                  &lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;input type=&quot;checkbox&quot; id=&quot;wpp_import_log_detail&quot; name=&quot;wpp_property_import[log_detail]&quot; value=&quot;on&quot; &lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;log_detail&#x27; ] ); ?&gt; /&gt;
                  &lt;label class=&quot;description&quot; for=&quot;wpp_import_log_detail&quot;&gt;&lt;?php echo __( &#x27;Enable detailed logging to assist with troubleshooting.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
                &lt;/li&gt;

                &lt;li class=&quot;wpp_xi_advanced_setting&quot;&gt;
                  &lt;label class=&quot;description&quot;&gt;
                    &lt;input type=&quot;checkbox&quot; name=&quot;wpp_property_import[show_sql_queries]&quot; value=&quot;on&quot; &lt;?php echo checked( &#x27;on&#x27;, $settings[ &#x27;show_sql_queries&#x27; ] ); ?&gt; /&gt;
                    &lt;?php echo __( &#x27;Show SQL Queries and errors.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/label&gt;
                &lt;/li&gt;

                &lt;?php do_action( &#x27;wpp_import_advanced_options&#x27;, $settings ); ?&gt;

              &lt;/ul&gt;

              &lt;span class=&quot;wpp_property_toggle_import_settings wpp_link&quot;&gt;&lt;?php _e( &#x27;Toggle Advanced Options&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt; &lt;span class=&quot;wpp_property_toggle_import_settings wpp_xi_advanced_option_counter&quot;&gt;&lt;/span&gt;

            &lt;/td&gt;
          &lt;/tr&gt;

          &lt;tr&gt;
            &lt;th&gt;&lt;?php _e( &#x27;Automatic Matching&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/th&gt;
            &lt;td&gt;
              &lt;input type=&quot;button&quot; value=&quot;&lt;?php _e( &#x27;Automatically Match&#x27;, &#x27;wpp&#x27; ); ?&gt;&quot; class=&#x27;button&#x27; id=&quot;wpp_import_auto_match&quot;/&gt;
              &lt;span&gt;&lt;?php _e( &#x27;This will work for WP-Property exports and imports, but will have mixed results with uniquely formatted feeds.&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;
            &lt;/td&gt;
          &lt;/tr&gt;

          &lt;tr&gt;
            &lt;th&gt;&lt;?php _e( &#x27;Attribute Map&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/th&gt;
            &lt;td&gt;
              &lt;p&gt;
                &lt;?php _e( &#x27;Use XPath rules to setup the paths to the individual XML attributes to match them up with WP-Property attributes.&#x27;, &#x27;wpp&#x27; ); ?&gt;
                &lt;span class=&quot;wpp_xi_sort_rules wpp_link&quot;&gt;&lt;?php _e( &#x27;Sort Attribute Rules&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/span&gt;.
              &lt;/p&gt;
              &lt;table id=&quot;wpp_property_import_attribute_mapper&quot; auto_increment=&quot;true&quot; class=&quot;ud_ui_dynamic_table widefat&quot;&gt;
                &lt;thead&gt;
                &lt;tr&gt;
                  &lt;th style=&quot;width: 5%;&quot;&gt;&lt;input style=&quot;margin:0;&quot; type=&quot;checkbox&quot; id=&quot;check_all&quot;&gt;&lt;/th&gt;
                  &lt;th style=&quot;width: 150px;&quot;&gt;&lt;?php echo __( &#x27;WP-Property Attribute&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/th&gt;
                  &lt;th style=&quot;width: auto;&quot;&gt;&lt;?php echo __( &#x27;XPath Rule&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/th&gt;
                &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                &lt;?php foreach( $settings[ &#x27;map&#x27; ] as $index =&gt; $attr ) { ?&gt;
                  &lt;tr class=&quot;wpp_dynamic_table_row&quot;&gt;
                    &lt;td&gt;
                      &lt;input type=&quot;checkbox&quot; name=&quot;wpp_property_import[map][&lt;?php echo( $index ); ?&gt;][check]&quot;&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                      &lt;select name=&quot;wpp_property_import[map][&lt;?php echo( $index ); ?&gt;][wpp_attribute]&quot; class=&#x27;wpp_import_attribute_dropdown&#x27;&gt;
                        &lt;option&gt;&lt;/option&gt;
                        &lt;optgroup label=&quot;&lt;?php _e( &#x27;WordPress Attributes&#x27;, &#x27;wpp&#x27; ); ?&gt;&quot;&gt;
                          &lt;?php foreach( $wpp_property_import[ &#x27;post_table_columns&#x27; ] as $column_name =&gt; $column_label ) { ?&gt;
                            &lt;option value=&quot;&lt;?php echo $column_name; ?&gt;&quot; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], $column_name ); ?&gt; &gt;&lt;?php echo $column_label; ?&gt;&lt;/option&gt;
                          &lt;?php } ?&gt;
                          &lt;option value=&quot;images&quot; &lt;?php echo ( $attr[ &#x27;wpp_attribute&#x27; ] == &#x27;images&#x27; ) ? &#x27;selected=&quot;selected&quot;&#x27; : &#x27;&#x27;; ?&gt; &gt;Images ( allows multiple )&lt;/option&gt;
                          &lt;option value=&quot;featured-image&quot; &lt;?php echo ( $attr[ &#x27;wpp_attribute&#x27; ] == &#x27;featured-image&#x27; ) ? &#x27;selected=&quot;selected&quot;&#x27; : &#x27;&#x27;; ?&gt; &gt;Featured Image&lt;/option&gt;
                        &lt;/optgroup&gt;
                        &lt;optgroup label=&quot;&lt;?php _e( &#x27;Taxonomies&#x27;, &#x27;wpp&#x27; ); ?&gt;&quot;&gt;
                          &lt;?php foreach( $wp_properties[ &#x27;taxonomies&#x27; ] as $tax_slug =&gt; $tax ) { ?&gt;
                            &lt;option value=&quot;&lt;?php echo $tax_slug; ?&gt;&quot; &lt;?php echo ( $attr[ &#x27;wpp_attribute&#x27; ] == $tax_slug ) ? &#x27;selected=&quot;selected&quot;&#x27; : &#x27;&#x27;; ?&gt; &gt;&lt;?php echo $tax[ &#x27;label&#x27; ]; ?&gt;
                              ( allows multiple )&lt;/option&gt;
                          &lt;?php } ?&gt;
                        &lt;/optgroup&gt;
                        &lt;optgroup label=&quot;&lt;?php _e( &#x27;Attributes&#x27;, &#x27;wpp&#x27; ); ?&gt;&quot;&gt;
                          &lt;?php foreach( Utility::get_total_attribute_array() as $property_stat_slug =&gt; $property_stat_label ): ?&gt;
                            &lt;option value=&quot;&lt;?php echo $property_stat_slug; ?&gt;&quot; &lt;?php echo ( $attr[ &#x27;wpp_attribute&#x27; ] == $property_stat_slug ) ? &#x27;selected=&quot;selected&quot;&#x27; : &#x27;&#x27;; ?&gt; &gt;&lt;?php echo $property_stat_label; ?&gt;&lt;/option&gt;
                          &lt;?php endforeach; ?&gt;
                        &lt;/optgroup&gt;
                        &lt;optgroup label=&quot;&lt;?php _e( &#x27;Address&#x27;, &#x27;wpp&#x27; ); ?&gt;&quot;&gt;
                          &lt;option value=&#x27;street_number&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;street_number&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;Street Number&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                          &lt;option value=&#x27;route&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;route&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;Street&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                          &lt;option value=&#x27;city&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;city&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;City&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                          &lt;option value=&#x27;county&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;county&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;County&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                          &lt;option value=&#x27;state&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;state&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;State&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                          &lt;option value=&#x27;country &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;country&#x27; ); ?&gt;&#x27;&gt;&lt;?php _e( &#x27;Country&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                          &lt;option value=&#x27;postal_code&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;postal_code&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;Postal Code&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                          &lt;option value=&#x27;latitude&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;latitude&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;Latitude&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                          &lt;option value=&#x27;longitude&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;longitude&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;Longitude&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                        &lt;/optgroup&gt;

                        &lt;optgroup label=&quot;&lt;?php _e( &#x27;WP-Property Attributes&#x27;, &#x27;wpp&#x27; ); ?&gt;&quot;&gt;
                          &lt;option value=&#x27;property_type&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;property_type&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;Property Type&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                          &lt;?php if( class_exists( &#x27;class_agents&#x27; ) ) { ?&gt;
                            &lt;option value=&#x27;wpp_agents&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;wpp_agents&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;Property Agent&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                          &lt;?php } ?&gt;
                          &lt;option value=&#x27;wpp_gpid&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;wpp_gpid&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;Global Property ID&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                          &lt;option value=&#x27;display_address&#x27; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], &#x27;display_address&#x27; ); ?&gt;&gt;&lt;?php _e( &#x27;Display Address&#x27;, &#x27;wpp&#x27; ); ?&gt;&lt;/option&gt;
                        &lt;/optgroup&gt;
                      &lt;/select&gt;
                    &lt;/td&gt;
                    &lt;td&gt;&lt;input style=&quot;width: 100%;&quot; name=&quot;wpp_property_import[map][&lt;?php echo( $index ) ?&gt;][xpath_rule]&quot; type=&quot;text&quot; class=&#x27;xpath_rule&#x27; value=&quot;&lt;?php echo esc_attr( $attr[ &#x27;xpath_rule&#x27; ] ); ?&gt;&quot;/&gt;&lt;/td&gt;
                  &lt;/tr&gt;
                &lt;?php } ?&gt;
                &lt;/tbody&gt;
                &lt;tfoot&gt;
                &lt;tr&gt;
                  &lt;td colspan=&quot;3&quot;&gt;
                    &lt;div class=&quot;alignleft&quot;&gt;
                      &lt;input type=&quot;button&quot; class=&quot;wpp_import_delete_row button-secondary&quot; value=&quot;&lt;?php _e( &#x27;Delete Selected&#x27;, &#x27;wpp&#x27; ) ?&gt;&quot;/&gt;
                      &lt;input type=&quot;button&quot; class=&quot;wpp_add_row button-secondary&quot; value=&quot;&lt;?php _e( &#x27;Add Row&#x27;, &#x27;wpp&#x27; ) ?&gt;&quot;/&gt;

                      &lt;?php if( !$settings ) {
                        $p_d = &#x27;disabled=&quot;disabled&quot;&#x27;;
                      } ?&gt;

                      &lt;span class=&quot;wpp_i_unique_id_wrapper&quot;&gt;
                        &lt;select id=&quot;wpp_property_import_unique_id&quot; name=&quot;wpp_property_import[unique_id]&quot;&gt;
                          &lt;?php $total_attribute_array = Utility::get_total_attribute_array(); ?&gt;
                          &lt;?php foreach( $settings[ &#x27;map&#x27; ] as $attr ) { ?&gt;
                            &lt;option value=&quot;&lt;?php echo $attr[ &#x27;wpp_attribute&#x27; ]; ?&gt;&quot; &lt;?php selected( $attr[ &#x27;wpp_attribute&#x27; ], $settings[ &#x27;unique_id&#x27; ] ); ?&gt;&gt;&lt;?php echo $total_attribute_array[ $attr[ &#x27;wpp_attribute&#x27; ] ]; ?&gt;
                              ( &lt;?php echo $attr[ &#x27;wpp_attribute&#x27; ]; ?&gt; )&lt;/option&gt;
                          &lt;?php } ?&gt;
                        &lt;/select&gt;
                        &lt;span class=&quot;description&quot;&gt;&lt;/span&gt;
                      &lt;/span&gt;

                    &lt;/div&gt;

                    &lt;div class=&quot;alignright&quot;&gt;
                      &lt;?php $save_button_id = ( $new_schedule ? &#x27;id=&quot;wpp_property_import_save&quot;&#x27; : &#x27;id=&quot;wpp_property_import_update&quot; schedule_id=&quot;&#x27; . $_REQUEST[ &#x27;schedule_id&#x27; ] . &#x27;&quot;&#x27; ); ?&gt;
                      &lt;input type=&quot;button&quot; &lt;?php echo $save_button_id ?&gt; class=&quot;button-primary&quot; value=&quot;&lt;?php _e( &#x27;Save Configuration&#x27;, &#x27;wpp&#x27; ) ?&gt;&quot; &lt;?php echo $p_d ?&gt; /&gt;

                    &lt;/div&gt;
                  &lt;/td&gt;
                &lt;/tr&gt;

                &lt;/tfoot&gt;

              &lt;/table&gt;
            &lt;/td&gt;
          &lt;/tr&gt;

            &lt;tr class=&quot;wpp_i_import_actions &lt;?php echo( $settings ? &#x27;&#x27; : &#x27;hidden&#x27; ); ?&gt;&quot;&gt;
              &lt;th&gt;&lt;/th&gt;
              &lt;td&gt;
                &lt;div class=&quot;wpp_i_import_actions_bar&quot;&gt;
                  &lt;input type=&quot;hidden&quot; id=&quot;import_hash&quot; value=&quot;&lt;?php echo $settings[ &#x27;hash&#x27; ]; ?&gt;&quot;/&gt;
                  &lt;input type=&quot;button&quot; id=&quot;wpp_i_preview_action&quot; value=&quot;&lt;?php _e( &#x27;Preview Import&#x27;, &#x27;wpp&#x27; ); ?&gt;&quot; class=&quot;button-secondary&quot; &lt;?php echo $p_d; ?&gt;&gt;
                  &lt;input type=&quot;button&quot; id=&quot;wpp_i_do_full_import&quot; value=&quot;&lt;?php _e( &#x27;Process Import&#x27;, &#x27;wpp&#x27; ); ?&gt;&quot; class=&quot;button-secondary&quot; &lt;?php echo $p_d; ?&gt;&gt;
                  &lt;input type=&quot;button&quot; id=&quot;wpp_i_do_media_import&quot; value=&quot;&lt;?php _e( &#x27;Process Media Import&#x27;, &#x27;wpp&#x27; ); ?&gt;&quot; class=&quot;button-secondary hidden&quot; &lt;?php echo $p_d; ?&gt;&gt;
                  &lt;div class=&quot;wpp_i_ajax_message&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;wpp_i_import_preview&quot;&gt;
                  &lt;div id=&quot;wpp_import_object_preview&quot; class=&quot;hidden&quot;&gt;&lt;div class=&quot;wp-tab-panel&quot;&gt;&lt;/div&gt;&lt;/div&gt;
                &lt;/div&gt;
              &lt;/td&gt;
            &lt;/tr&gt;

          &lt;/tbody&gt;
          &lt;/table&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;?php
      }

      /**
       * Imports an object into WP-Property
       *
       * @todo Take note that remove_images removed all attachments, not just images.
       * @todo Should set post status to &quot;draft&quot; until it is verified.
       * @todo May want to move more of the core save_property() into filters, so they can be used here, and elsewhere
       * @todo Need way of settings property type
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
       */
      static public function import_object( $data, $schedule_id, $counter = false ) {
        global $wpp_property_import, $wpdb, $wp_properties, $wpp_cache;

        //** Be sure we have the stable DB connection. */
        if( $wp_properties[ &#x27;configuration&#x27; ][ &#x27;developer_mode&#x27; ] == &#x27;true&#x27; ) {
          $wpdb-&gt;show_errors();
        } else {
          $wpdb-&gt;suppress_errors();
        }
        $wpdb-&gt;db_connect();

        if( !empty( $wpdb-&gt;error ) ) {
          $error = is_wp_error( $wpdb-&gt;error ) ? $wpdb-&gt;error-&gt;get_error_message() : $wpdb-&gt;error;
          self::maybe_echo_log( __( &quot;Database connection failed. Error: {$error}&quot;, &#x27;wpp&#x27; ) );
        }

        // Load schedule settings
        $schedule_settings = $wp_properties[ &#x27;configuration&#x27; ][ &#x27;feature_settings&#x27; ][ &#x27;property_import&#x27; ][ &#x27;schedules&#x27; ][ $schedule_id ];

        // Load wp_posts columns and their labels
        $post_table_columns = array_keys( (array) $wpp_property_import[ &#x27;post_table_columns&#x27; ] );

        //** Load WPP taxonomies */
        $taxonomies = array();
        foreach( $wp_properties[ &#x27;taxonomies&#x27; ] as $slug =&gt; $tax ) {
          $taxonomies[ ] = $slug;
        }

        // Load defaults for new properties
        $defaults = apply_filters( &#x27;wpp_import_object_defaults&#x27;, $defaults = array(
          &#x27;post_title&#x27;   =&gt; isset( $data[ &#x27;post_title&#x27; ][ 0 ] ) ? $data[ &#x27;post_title&#x27; ][ 0 ] : &#x27;&#x27;,
          &#x27;post_content&#x27; =&gt; isset( $data[ &#x27;post_content&#x27; ][ 0 ] ) ? $data[ &#x27;post_content&#x27; ][ 0 ] : &#x27;&#x27;,
          &#x27;post_status&#x27;  =&gt; &#x27;publish&#x27;,
          &#x27;post_type&#x27;    =&gt; &#x27;property&#x27;,
          &#x27;ping_status&#x27;  =&gt; get_option( &#x27;default_ping_status&#x27; ),
          &#x27;post_parent&#x27;  =&gt; 0
        ), $data );

        //* Handle WPP Import in a special way */
        if( $schedule_settings[ &#x27;source_type&#x27; ] == &quot;wpp&quot; ) {
          $wpp_gpid    = $data[ &#x27;wpp_gpid&#x27; ][ 0 ];
          $post_exists = Utility::get_property_from_gpid( $wpp_gpid );
        }

        $unique_id_attribute = $data[ &#x27;unique_id&#x27; ];
        $unique_id_value     = $data[ $unique_id_attribute ][ 0 ];

        if( !$post_exists ) {
          if( !isset( $wpp_cache ) || !is_array( $wpp_cache ) || !isset( $wpp_cache[ &#x27;existing_posts_by_meta&#x27; ] ) ) {
            $wpp_cache = array(
              &#x27;existing_posts_by_meta&#x27; =&gt; array(),
              &#x27;existing_posts_by_main&#x27; =&gt; array()
            );
            /** First, get our values by meta*/
            $existing_posts_by_meta = $wpdb-&gt;get_results( &quot;
          SELECT DISTINCT post_id, meta_value
          FROM {$wpdb-&gt;postmeta}
          WHERE post_id IN (
              SELECT DISTINCT post_id FROM {$wpdb-&gt;postmeta}
              WHERE meta_key=&#x27;wpp_import_schedule_id&#x27;
                AND meta_value=&#x27;{$schedule_id}&#x27;
            )
            AND meta_key=&#x27;{$unique_id_attribute}&#x27;
        &quot;, ARRAY_A );
            if( is_array( $existing_posts_by_meta ) &amp;&amp; count( $existing_posts_by_meta ) ) {
              foreach( $existing_posts_by_meta as $row ) {
                $wpp_cache[ &#x27;existing_posts_by_meta&#x27; ][ $row[ &#x27;meta_value&#x27; ] ] = $row[ &#x27;post_id&#x27; ];
              }
            }
            /** Now, do the same for the main table */
            if( in_array( $unique_id_attribute, $post_table_columns ) ) {
              $existing_posts_by_main = @$wpdb-&gt;query( &quot;
            SELECT DISTINCT ID, {$unique_id_attribute} AS unique_value
            FROM {$wpdb-&gt;posts}
            WHERE ID IN (
                SELECT DISTINCT post_id FROM {$wpdb-&gt;postmeta}
                WHERE meta_key=&#x27;wpp_import_schedule_id&#x27;
                  AND meta_value=&#x27;{$schedule_id}&#x27;
              )
          &quot;, ARRAY_A );
              if( is_array( $existing_posts_by_main ) &amp;&amp; count( $existing_posts_by_main ) ) {
                foreach( $existing_posts_by_main as $row ) {
                  $wpp_cache[ &#x27;existing_posts_by_main&#x27; ][ $row[ &#x27;unique_value&#x27; ] ] = $row[ &#x27;ID&#x27; ];
                }
              }
            }
          }

          /** Ok, actually, now do the comparison */
          if( isset( $wpp_cache[ &#x27;existing_posts_by_meta&#x27; ][ $unique_id_value ] ) ) {
            $post_exists = $wpp_cache[ &#x27;existing_posts_by_meta&#x27; ][ $unique_id_value ];
          }
          if( isset( $wpp_cache[ &#x27;existing_posts_by_main&#x27; ][ $unique_id_value ] ) ) {
            $post_exists = $wpp_cache[ &#x27;existing_posts_by_main&#x27; ][ $unique_id_value ];
          }
        }

        //** Property Skipping. Only applicable to existing properties. */
        if( !empty( $post_exists ) ) {
          do_action( &#x27;wpp_import_property_before_skip&#x27;, $post_exists, $data );
          $last_import               = get_post_meta( $post_exists, &#x27;wpp_import_time&#x27;, true );
          $time_since_last_import    = time() - $last_import;
          $reimport_delay_in_seconds = !empty( $schedule_settings[ &#x27;reimport_delay&#x27; ] ) ? (int) $schedule_settings[ &#x27;reimport_delay&#x27; ] * 60 * 60 : false;
          if( $reimport_delay_in_seconds &amp;&amp; $time_since_last_import &lt; $reimport_delay_in_seconds ) {
            $skip = true;
          }
          $disable_update = get_post_meta( $post_exists, &#x27;wpp::disable_xmli_update&#x27;, true );
          $disable_update = in_array( $disable_update, array( &#x27;1&#x27;, &#x27;true&#x27; ) ) ? true : false;
          //** Allow override of skip or not */
          switch( true ) {
            case apply_filters( &#x27;wpp_import_skip_import&#x27;, $skip, $post_exists, $schedule_settings ):
              self::maybe_echo_log( &#x27;#&#x27; . $counter . &quot; - skipping property, last import &quot; . human_time_diff( $last_import ) . &quot; ago. &lt;a href=&#x27;&quot; . get_permalink( $post_exists ) . &quot;&#x27; target=&#x27;_blank&#x27;&gt;#{$post_exists}&lt;/a&gt;&quot; );

              //** Stop this import and return to next object */
              return array( $post_exists, $mode );
            case apply_filters( &#x27;wpp_import_disable_update&#x27;, $disable_update, $post_exists, $schedule_settings ):
              self::maybe_echo_log( &#x27;#&#x27; . $counter . &quot; - skipping property, because &#x27;Ignore updates on XMLI process&#x27; option is checked for the current one. &lt;a href=&#x27;&quot; . get_permalink( $post_exists ) . &quot;&#x27; target=&#x27;_blank&#x27;&gt;#{$post_exists}&lt;/a&gt;&quot; );

              //** Stop this import and return to next object */
              return array( $post_exists, $mode );
            default:
              self::maybe_echo_log( &quot;Importing. Unique ID: ( {$unique_id_value} )&quot; );
              break;
          }
        }

        //** Ok, if we&#x27;re actually a RETS resource, or if we have images that need downloaded, then we&#x27;re going to be pending */
        if( $schedule_settings[ &#x27;source_type&#x27; ] == &#x27;rets&#x27; ||
          ( isset( $data[ &#x27;images&#x27; ] ) &amp;&amp; is_array( $data[ &#x27;images&#x27; ] ) &amp;&amp; count( $data[ &#x27;images&#x27; ] ) ) ||
          ( isset( $data[ &#x27;featured-image&#x27; ] ) &amp;&amp; is_array( $data[ &#x27;featured-image&#x27; ] ) &amp;&amp; count( $data[ &#x27;featured-image&#x27; ] ) )
        ) {

          if( empty( $post_exists ) ) {

            // First, change our post status to &quot;pending&quot;
            $defaults[ &#x27;post_status&#x27; ] = &#x27;pending&#x27;;

          } else {
            //** Just make sure we&#x27;re not updating the post status */
            unset( $defaults[ &#x27;post_status&#x27; ] );
          }

          //** Setup our new image data holders */
          $data[ &#x27;wpp::image_status&#x27; ] = &#x27;pending&#x27;;

          $data[ &#x27;wpp::images&#x27; ] = json_encode( array(
            &#x27;images&#x27;         =&gt; ( isset( $data[ &#x27;images&#x27; ] ) &amp;&amp; is_array( $data[ &#x27;images&#x27; ] ) &amp;&amp; count( $data[ &#x27;images&#x27; ] ) ? $data[ &#x27;images&#x27; ] : null ),
            &#x27;featured-image&#x27; =&gt; ( isset( $data[ &#x27;featured-image&#x27; ] ) &amp;&amp; is_array( $data[ &#x27;featured-image&#x27; ] ) &amp;&amp; count( $data[ &#x27;featured-image&#x27; ] ) ? $data[ &#x27;featured-image&#x27; ] : null ),
          ) );

          /** Unset anything that might be there */
          unset( $data[ &#x27;images&#x27; ] );
          unset( $data[ &#x27;featured-image&#x27; ] );

          /** Set if we have the process already scheduled */
          self::maybe_schedule_cron( &#x27;wpp_manage_pending_images&#x27;, array(
            &#x27;wpp_manage_pending_images&#x27; =&gt; $schedule_id
          ) );

        }

        //** Insert/Update post */
        if( !empty( $post_exists ) ) {
          //** Existing property */
          if( $schedule_settings[ &#x27;log_detail&#x27; ] == &#x27;on&#x27; ) {
            self::maybe_echo_log( __( &#x27;Updating existing listing.&#x27;, &#x27;wpp&#x27; ) );
          }
          //** Set ID to match old post ( so duplicate doesn&#x27;t get created ) */
          $defaults[ &#x27;ID&#x27; ] = $post_exists;
          //** Update post with default data ( which may be overwritten later during full import ) */
          $post_id = wp_update_post( $defaults );
          if( is_numeric( $post_id ) ) {
            /** Post ID exists */
            $mode         = &#x27;u&#x27;;
            $property_url = get_permalink( $post_id );
            self::maybe_echo_log( $counter . &quot; - updated &lt;a href=&#x27;{$property_url}&#x27; target=&#x27;_blank&#x27;&gt;#{$post_id}&lt;/a&gt;.&quot; );
            $exclude_from_supermap = get_post_meta( $post_id, &#x27;exclude_from_supermap&#x27;, true );
          } else {
            return new WP_Error( &#x27;fail&#x27;, __( &quot;Attempted to update property, but wp_update_post() did not return an ID. &quot;, &#x27;wpp&#x27; ) );
          }
        } else {
          if( $schedule_settings[ &#x27;log_detail&#x27; ] == &#x27;on&#x27; ) {
            self::maybe_echo_log( __( &#x27;Creating new listing.&#x27;, &#x27;wpp&#x27; ) );
          }
          if( $schedule_settings[ &#x27;show_sql_queries&#x27; ] == &#x27;true&#x27; ) {
            $wpdb-&gt;show_errors();
          }
          //** New property. */
          $post_id = wp_insert_post( $defaults, true );
          if( $post_id &amp;&amp; !is_wp_error( $post_id ) ) {
            $mode         = &#x27;c&#x27;;
            $property_url = get_permalink( $post_id );
            self::maybe_echo_log( &#x27;#&#x27; . $counter . &quot; - created &lt;a href=&#x27;{$property_url}&#x27; target=&#x27;_blank&#x27;&gt;#{$post_id}&lt;/a&gt;&quot; );
          }
        }

        // At this point a blank property is either created or the existing $post_id is set, should be no reason it not be set, but just in case. */
        if( is_wp_error( $post_id ) ) {
          return new WP_Error( &#x27;fail&#x27;, sprintf( __( &#x27;Object import failed. Error: %1s.&#x27;, &#x27;wpp&#x27; ), $post_id-&gt;get_error_message() ) );
        }

        if( !is_numeric( $post_id ) &amp;&amp; empty( $defaults[ &#x27;post_title&#x27; ] ) ) {
          return new WP_Error( &#x27;fail&#x27;, __( &#x27;Object import failed - no Property Title detected or set, a requirement to creating a property.&#x27;, &#x27;wpp&#x27; ) );
        }

        if( !$post_id ) {
          return new WP_Error( &#x27;fail&#x27;, __( &#x27;Object import failed.  Post cold not be created nor updated, and post_id was not found or created.&#x27;, &#x27;wpp&#x27; ) );
        }

        unset( $data[ &#x27;unique_id&#x27; ] );

        // Remove any orphaned image.
        if( $schedule_settings[ &#x27;remove_images&#x27; ] == &#x27;on&#x27; ) {
          $removed_images = 0;

          foreach( (array) $wpdb-&gt;get_results( $wpdb-&gt;prepare( &quot;SELECT * FROM {$wpdb-&gt;posts} WHERE post_type = &#x27;attachment&#x27; AND post_parent = %d &quot;, $post_id ) ) as $image_row ) {

            if( wp_delete_attachment( $image_row-&gt;ID, true ) ) {
              $removed_images++;
            }

          }

          if( $removed_images ) {
            self::maybe_echo_log( &quot;Removed ( {$removed_images} ) old images.&quot; );
          }

        }

        //** Keep track of all attributes that have values and have been imported */
        $processed_attributes = array();

        //** Cycle through attributes ( which include meta value, images and taxonomies ) */
        foreach( (array) $data as $attribute =&gt; $values ) {

          $attribute_data = Utility::get_attribute_data( $attribute );

          //** If no values, stop processing this attribute */
          if( empty( $values ) ) {
            continue;
          }

          //** Convert value to array format if it isn&#x27;t */
          if( !is_array( $values ) ) {
            $values = array( $values );
          }

          //** Get array of keys we will not encode on import */
          $keys_to_not_encode = apply_filters( &#x27;wpp_import_do_not_encode_attributes&#x27;, array( &#x27;wpp_agents&#x27; ) );

          //** Values are in array format, cycle through them */
          foreach( $values as $value ) {

            /** don&#x27;t encode urls or attributes in exclusion array */
            if( !Utility::isURL( $value ) &amp;&amp; ( !in_array( $attribute, $keys_to_not_encode ) &amp;&amp; $attribute_data[ &#x27;storage_type&#x27; ] != &#x27;post_table&#x27; ) ) {
              $original_value = $value;
              $value          = Utility::encode_mysql_input( $value, $attribute );
            }

            //** Handle Agent Matching */
            if( $attribute == &#x27;wpp_agents&#x27; ) {
              $agent_match_bridge = ( $schedule_settings[ &#x27;wpp_agent_attribute_match&#x27; ] ? $schedule_settings[ &#x27;wpp_agent_attribute_match&#x27; ] : &#x27;display_name&#x27; );
              $users_columns      = array(
                &#x27;ID&#x27;,
                &#x27;user_login&#x27;,
                &#x27;user_pass&#x27;,
                &#x27;user_nicename&#x27;,
                &#x27;user_email&#x27;,
                &#x27;user_url&#x27;,
                &#x27;user_registered&#x27;,
                &#x27;user_activation_key&#x27;,
                &#x27;user_status&#x27;,
                &#x27;display_name&#x27;,
              );

              //** Attempt to find agent ID based on provided data */
              $possible_match = false;

              if( in_array( $agent_match_bridge, $users_columns ) ) {
                $possible_match = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT ID FROM {$wpdb-&gt;users} WHERE  {$agent_match_bridge} = &#x27;%s&#x27; LIMIT 0, 1&quot;, $value ) );
              }

              if( !is_numeric( $possible_match ) ) {
                //** Try meta table */
                $possible_match = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT user_id FROM {$wpdb-&gt;usermeta} WHERE  meta_key=&#x27;{$agent_match_bridge}&#x27; AND meta_value= &#x27;%s&#x27;  LIMIT 0, 1 &quot;, $value ) );
              }

              if( is_numeric( $possible_match ) ) {
                if( $schedule_settings[ &#x27;log_detail&#x27; ] == &#x27;on&#x27; ) {
                  self::maybe_echo_log( &quot;Property agent found based on {$agent_match_bridge} with ID of $possible_match - adding to {$post_id}  property.&quot; );
                }
                delete_post_meta( $post_id, &#x27;wpp_agents&#x27; );
                add_post_meta( $post_id, &#x27;wpp_agents&#x27;, $possible_match );
              }
              $possible_match = null;

              //** Handle taxonomies */
            } elseif( in_array( $attribute, ( array ) $taxonomies ) ) {
              $value = explode( &#x27;,&#x27;, (string) $value );
              foreach( $value as $v ) {
                $v = trim( $v );
                if( !empty( $v ) ) {
                  $to_add_taxonomies[ $attribute ][ ] = apply_filters( &#x27;wpp_xml_import_value_on_import&#x27;, $v, $attribute, &#x27;taxonomy&#x27;, $post_id );
                }
              }

              //** Handle Main Post Table data */
            } elseif( in_array( $attribute, $post_table_columns ) ) {
              /** Handle values that are stored in main posts table */
              $wpdb-&gt;update( $wpdb-&gt;posts, array( $attribute =&gt; apply_filters( &#x27;wpp_xml_import_value_on_import&#x27;, $value, $attribute, &#x27;post_table&#x27;, $post_id ) ), array( &#x27;ID&#x27; =&gt; $post_id ) );

              //** Handle regular meta fields */
            } else {
              $value = apply_filters( &#x27;wpp_xml_import_value_on_import&#x27;, $value, $attribute, &#x27;meta_field&#x27;, $post_id );
              if( !empty( $value ) ) {
                update_post_meta( $post_id, $attribute, $value );
              }
            }

          }

          /** Add processed attribute to array */
          $processed_attributes[ ] = $attribute;

        } /* end: foreach( $data as $attribute =&gt; $values )  */

        //** Add all taxonomies */
        if( !empty( $to_add_taxonomies ) ) {
          foreach( $to_add_taxonomies as $tax_slug =&gt; $terms ) {
            //** We are not appending, but replacing all of them */
            if( !taxonomy_exists( $tax_slug ) ) {
              continue;
            }
            $tt_ids = wp_set_object_terms( $post_id, $terms, $tax_slug );
          }
        }

        //** Set property_type to default if not set from individual property */
        if( !in_array( &#x27;property_type&#x27;, $processed_attributes ) ) {
          update_post_meta( $post_id, &#x27;property_type&#x27;, $schedule_settings[ &#x27;property_type&#x27; ] );
        }

        //** Take note of which import schedule this property came from for future association */
        update_post_meta( $post_id, &#x27;wpp_import_schedule_id&#x27;, $schedule_id );

        //** Update last imported timestamp to current */
        update_post_meta( $post_id, &#x27;wpp_import_time&#x27;, time() );

        //** Set GPID for property if one isnt set */
        Utility::maybe_set_gpid( $post_id );

        update_post_meta( $post_id, &#x27;exclude_from_supermap&#x27;, ( isset( $exclude_from_supermap ) &amp;&amp; $exclude_from_supermap !== false ? $exclude_from_supermap : &#x27;false&#x27; ) );

        /**
         * New experimental behavior:
         * If we have a coordinates then we have to keep them with help of &#x27;manual_coordinates&#x27; flag.
         * As result, it will protect address field from modification of by Google Validation Service (but only if Address is not empty, other vice we will receive address by coordinates on Revalidate All Addresses)
         *
         * @date 23.02.2013
         * @author odokienko@UD
         */
        if( !empty( $data[ &#x27;latitude&#x27; ] ) &amp;&amp; !empty( $data[ &#x27;longitude&#x27; ] ) ) {
          update_post_meta( $post_id, &#x27;manual_coordinates&#x27;, &#x27;true&#x27; );
        }

        //** Attempt to reassemble the &#x27;address_attribute&#x27; if it is not set */
        if( $address_attribute = $wp_properties[ &#x27;configuration&#x27; ][ &#x27;address_attribute&#x27; ] ) {
          $current_address = get_post_meta( $post_id, $address_attribute, true );
          if( empty( $current_address ) ) {
            if( $fixed_address = Utility::reassemble_address( $post_id ) ) {
              update_post_meta( $post_id, $address_attribute, $fixed_address );
              self::maybe_echo_log( &quot;No address found for property, reassembled it from parts: {$fixed_address}&quot; );
            }
          }
        }

        //** (Re)Validate address */
        if( $schedule_settings[ &#x27;revalidate_addreses_on_completion&#x27; ] == &#x27;on&#x27; &amp;&amp; !$wp_properties[ &#x27;_computed&#x27; ][ &#x27;over_query_limit&#x27; ] ) {

          self::maybe_echo_memory_usage( __( &#x27;before revalidating process&#x27;, &#x27;wpp&#x27; ), $schedule_id );

          $validation_result   = Utility::revalidate_address( $post_id, array( &#x27;skip_existing&#x27; =&gt; &#x27;true&#x27; ) );
          $validation_statuses = array(
            &#x27;skipped&#x27;          =&gt; __( &#x27;Address validation was skipped because address has been already validated.&#x27;, &#x27;wpp&#x27; ),
            &#x27;empty_address&#x27;    =&gt; __( &#x27;Address validation has been skipped because address/coordinates is empty. Check your Attribute Map for \&#x27;Address\&#x27; attribute.&#x27;, &#x27;wpp&#x27; ),
            &#x27;over_query_limit&#x27; =&gt; __( &#x27;Address validation was failed because Google service has denied request ( OVER QUERY LIMIT ).&#x27;, &#x27;wpp&#x27; ),
            &#x27;failed&#x27;           =&gt; __( &#x27;Address validation has been failed.&#x27;, &#x27;wpp&#x27; ),
            &#x27;updated&#x27;          =&gt; __( &#x27;Address validation has been successfully completed.&#x27;, &#x27;wpp&#x27; ),
          );

          if( !empty( $validation_result[ &#x27;status&#x27; ] ) &amp;&amp; array_key_exists( $validation_result[ &#x27;status&#x27; ], $validation_statuses ) ) {
            self::maybe_echo_log( $validation_statuses[ $validation_result[ &#x27;status&#x27; ] ] );
          }

          // Set Over Query Limit flag to prevent additional lookups for this request.
          if( $validation_result[ &#x27;status&#x27; ] === &#x27;over_query_limit&#x27; ) {
            $wp_properties[ &#x27;_computed&#x27; ][ &#x27;over_query_limit&#x27; ] = true;
          }

          self::maybe_echo_memory_usage( __( &#x27;after revalidating process&#x27;, &#x27;wpp&#x27; ), $schedule_id );

        }

        if( isset( $revalidation_result[ &#x27;geo_data&#x27; ] ) &amp;&amp; count( $revalidation_result[ &#x27;geo_data&#x27; ] ) ) {
          $wpp_import_result_stats[ ] = count( $revalidation_result[ &#x27;geo_data&#x27; ] ) . &quot; addresses re-validated.&quot;;
        }

        //** Save parent GPID association to meta for later association */
        if( $data[ &#x27;parent_gpid&#x27; ][ 0 ] ) {
          update_post_meta( $post_id, &#x27;parent_gpid&#x27;, $data[ &#x27;parent_gpid&#x27; ][ 0 ] );
          self::maybe_echo_log( &quot;Parent GPID found for {$post_id} -&gt; {$data[ &#x27;parent_gpid&#x27; ][0]}  .&quot; );
        }

        do_action( &#x27;wpp_import_property&#x27;, $post_id, $data );

        $return_data = array(
          &#x27;0&#x27; =&gt; $post_id,
          &#x27;1&#x27; =&gt; $mode,
        );

        return $return_data;
      }

      /**
       * This function gets and inits our rets object
       *
       */
      static public function connect_rets( $import ) {
        global $wp_properties;

        /** Create my new rets feed */
        $rets = new WPP_RETS();

        /** @updated 3.2.6 - potanin@UD */
        if( $wp_properties[ &#x27;configuration&#x27; ][ &#x27;developer_mode&#x27; ] == &#x27;true&#x27; ) {
          $upload_dir = wp_upload_dir();
          $rets-&gt;SetParam( &#x27;debug_mode&#x27;, true );
          $rets-&gt;SetParam( &#x27;debug_file&#x27;, $upload_dir[ &#x27;basedir&#x27; ] . &#x27;/xmli.rets.log&#x27; );
        }

        $rets-&gt;AddHeader( &#x27;Accept&#x27;, &#x27;*/*&#x27; );
        $rets-&gt;AddHeader( &#x27;User-Agent&#x27;, !empty( $import[ &#x27;rets_agent&#x27; ] ) ? $import[ &#x27;rets_agent&#x27; ] : &#x27;WP-Property/1.0&#x27; );
        $rets-&gt;AddHeader( &#x27;RETS-Version&#x27;, !empty( $import[ &#x27;rets_version&#x27; ] ) ? $import[ &#x27;rets_version&#x27; ] : &#x27;RETS/1.7&#x27; );

        if( isset( $import[ &#x27;rets_agent_password&#x27; ] ) &amp;&amp; !empty( $import[ &#x27;rets_agent_password&#x27; ] ) ) {
          $connect = $rets-&gt;Connect( $import[ &#x27;url&#x27; ], $import[ &#x27;rets_username&#x27; ], $import[ &#x27;rets_password&#x27; ], $import[ &#x27;rets_agent_password&#x27; ] );
        } else {
          $connect = $rets-&gt;Connect( $import[ &#x27;url&#x27; ], $import[ &#x27;rets_username&#x27; ], $import[ &#x27;rets_password&#x27; ] );
        }

        if( !$connect ) {
          $error_details = $rets-&gt;Error();
          $error_text    = !empty( $error_details[ &#x27;text&#x27; ] ) ? &#x27; - &#x27; . strip_tags( $error_details[ &#x27;text&#x27; ] ) : &#x27;&#x27;;
          $error_code    = !empty( $error_details[ &#x27;code&#x27; ] ) ? &#x27; - &#x27; . $error_details[ &#x27;code&#x27; ] : &#x27;&#x27;;
          $error_type    = strtoupper( $error_details[ &#x27;type&#x27; ] );
          throw new Exception( &quot;Could not connect to RETS server: {$error_type}{$error_code}{$error_text}&quot; );

          return false;
        }

        return $rets;
      }

      /**
       * Makes a request to specified url
       *
       * Recognized XML or Google Spreadsheet feed
       *
       * @todo $limit=1 on RETS seems to prevent preview query from looking past the first result, and doing something like /ROWS/ROW[L_Class = &quot;COMMERCIAL&quot;] does not work, but need to test. - potanin@UD
       * @todo Add error handling, right now rets class jus dies on errors, such as with GetObject, no feedback to user.
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc.
       */
      static public function wpp_make_request( $url, $method = &#x27;get&#x27;, $data ) {
        global $wpp_property_import, $wpp_import_result_stats, $wp_properties;

        //** Set schedule ID */
        $schedule_id = $data[ &#x27;schedule_id&#x27; ];

        if( isset( $_REQUEST[ &#x27;stepping&#x27; ] ) ) {
          // Open up our temp file for writing
          if( !is_dir( WPP_Path . &quot;cache&quot; ) ) {
            mkdir( WPP_Path . &quot;cache&quot; );
            chmod( WPP_Path . &quot;cache&quot;, 0755 );
          }
        }

        $newvars = array();

        // Google Spreadsheet Importing
        if( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;source_type&#x27; ] == &#x27;gs&#x27; &amp;&amp; class_exists( &#x27;GC_Import&#x27; ) ) {

          //set_include_path( WPP_Path . &#x27;third-party/&#x27; );
          //require_once( &#x27;Zend/Gdata/Spreadsheets.php&#x27; );
          //require_once( &#x27;Zend/Gdata/ClientLogin.php&#x27; );

          try {

            /** Only connect if we aren&#x27;t a stepping element */
            if( !isset( $_REQUEST[ &#x27;stepping_element&#x27; ] ) ) {

              $gdata = new GC_Import();
              /* Build our query */
              $query = new Zend_Gdata_Spreadsheets_ListQuery();
              $query-&gt;setSpreadsheetKey( $gdata-&gt;parse_spreadsheet_key( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;url&#x27; ] ) );
              $query-&gt;setWorksheetId( 1 );
              $query_url = $query-&gt;getQueryUrl();
              if( !empty( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;google_extra_query&#x27; ] ) ) $query_url .= &quot;?&quot; . $data[ &#x27;wpp_property_import&#x27; ][ &#x27;google_extra_query&#x27; ];
              /** Connect to the spreadsheet */
              $gdata-&gt;gdata_connect( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;google_username&#x27; ], $data[ &#x27;wpp_property_import&#x27; ][ &#x27;google_password&#x27; ] );
              $listFeed = $gdata-&gt;gdata[ &#x27;ss_service&#x27; ]-&gt;getListFeed( $query_url );

              /** Loop through the rows, building our XML string */
              $str  = &#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;GC&gt;&#x27;;
              $rows = 1;

              foreach( $listFeed-&gt;entries AS $entry ) {
                $str .= &#x27;&lt;ROW&gt;&#x27;;
                $str .= &#x27;&lt;IMPORT_ROWID&gt;&#x27; . $rows . &#x27;&lt;/IMPORT_ROWID&gt;&#x27;;
                /* Build a generic random number */
                $rowData = $entry-&gt;getCustom();
                foreach( $rowData as $customEntry ) {
                  $str .= &#x27;&lt;&#x27; . strtoupper( $customEntry-&gt;getColumnName() ) . &#x27;&gt;&lt;![CDATA[&#x27; . htmlentities( $customEntry-&gt;getText(), ENT_QUOTES, &quot;UTF-8&quot; ) . &#x27;]]&gt;&lt;/&#x27; . strtoupper( $customEntry-&gt;getColumnName() ) . &#x27;&gt;&#x27;;
                }
                $str .= &#x27;&lt;/ROW&gt;&#x27;;
                $rows++;
              }
              $str .= &#x27;&lt;/GC&gt;&#x27;;

              if( isset( $_REQUEST[ &#x27;stepping&#x27; ] ) ) {
                file_put_contents( WPP_Path . &quot;cache/&quot; . $data[ &#x27;wpp_property_import&#x27; ][ &#x27;hash&#x27; ] . &quot;.xml&quot;, $str );
              }

            } else {
              $str = file_get_contents( WPP_Path . &quot;cache/&quot; . $data[ &#x27;wpp_property_import&#x27; ][ &#x27;hash&#x27; ] . &quot;.xml&quot; );
            }

            return array( &#x27;body&#x27; =&gt; $str );
          } catch( Exception $e ) {
            die( json_encode( array( &#x27;success&#x27; =&gt; &#x27;false&#x27;, &#x27;message&#x27; =&gt; $e-&gt;getMessage() ) ) );
          }

        }

        // CSV Importing
        if( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;source_type&#x27; ] == &#x27;csv&#x27; ) {

          $url_array = parse_url( $url );

          if( !empty( $url_array[ &#x27;query&#x27; ] ) ) {
            parse_str( $url_array[ &#x27;query&#x27; ], $newvars );
          }

          if( $method == &#x27;post&#x27; &amp;&amp; count( $newvars ) &amp;&amp; !empty( $newvars ) ) {
            $return = wp_remote_post( $url, array( &#x27;timeout&#x27; =&gt; apply_filters( &#x27;wpp_xi_wp_remote_timeout&#x27;, 300, array( &#x27;method&#x27; =&gt; $method, &#x27;url&#x27; =&gt; $url ) ), &#x27;body&#x27; =&gt; array( &#x27;request&#x27; =&gt; serialize( $newvars ) ) ) );
          } else {
            $return = wp_remote_get( $url, array( &#x27;timeout&#x27; =&gt; apply_filters( &#x27;wpp_xi_wp_remote_timeout&#x27;, 300, array( &#x27;method&#x27; =&gt; $method, &#x27;url&#x27; =&gt; $url ) ) ) );
          }

          //** Check if data is JSON or XML */
          if( is_wp_error( $return ) ) {
            return $return;
          } else {

            //** Create a temporary file that fgetcsv() can read through */
            if( !empty( $return[ &#x27;body&#x27; ] ) ) {

              $xml_from_csv = Utility::csv_to_xml( $return[ &#x27;body&#x27; ] );

              //** Load the converted XML Back into body - as if nothing even happened */
              $return[ &#x27;body&#x27; ] = $xml_from_csv;

              return $return;

            }

          }

        }

        // RETS Importing
        if( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;source_type&#x27; ] == &#x27;rets&#x27; ) {

          try {

            if( !class_exists( &#x27;XmlWriter&#x27; ) ) {
              throw new \Exception( &#x27;Can not initialize Importer, XmlWriter class missing.&#x27; );
            }

            $import = $data[ &#x27;wpp_property_import&#x27; ];

            /** Get my rets object */
            $rets = self::connect_rets( $import );

            /** Include our function here to write arrays to XML */
            if( !function_exists( &#x27;write&#x27; ) ) {
              function write( XMLWriter $xml, $data ) {

                foreach( $data as $key =&gt; $value ) {

                  $key = !is_numeric( $key ) ? $key : &#x27;_&#x27; . $key;

                  if( is_array( $value ) ) {
                    $xml-&gt;startElement( $key );
                    write( $xml, $value );
                    $xml-&gt;endElement();
                    continue;
                  }

                  $xml-&gt;writeElement( $key, $value );

                }
              }

            }

            /** Start our XML */
            $xml = new XmlWriter();

            // Let&#x27;s trying not to use openMemory() but openUri() odokienko@UD
            //$xml-&gt;openMemory()

            $upload_dir = wp_upload_dir();

            // Create file to processed RETS XML
            $temp_directory = $upload_dir[ &#x27;basedir&#x27; ] . &quot;/wpp_import_files/temp/&quot;;
            if( !is_dir( $temp_directory ) ) {
              @mkdir( $temp_directory, 0755, 1 );
              @chmod( $temp_directory, 0755 );
              if( !is_dir( $temp_directory ) ) {
                throw new Exception( &#x27;Could not create the directory: &#x27; . $temp_directory );
              }
            }
            @touch( $xml_file = $upload_dir[ &#x27;basedir&#x27; ] . &quot;/wpp_import_files/temp/{$schedule_id}_rets_output.xml&quot; );

            $xml_file = realpath( $xml_file );

            $xml-&gt;openUri( $xml_file );
            $xml-&gt;startDocument( &#x27;1.0&#x27;, &#x27;UTF-8&#x27; );
            $xml-&gt;startElement( &#x27;ROWS&#x27; );

            /** set limit */
            $limit = !empty( $import[ &#x27;limit_scanned_properties&#x27; ] ) ? $import[ &#x27;limit_scanned_properties&#x27; ] : 0;
            /** Determine RETS resource */
            $resource = !empty( $import[ &#x27;rets_resource&#x27; ] ) ? $import[ &#x27;rets_resource&#x27; ] : self::$default_rets_resource;
            /** Determine our main ID */
            $rets_pk = !empty( $import[ &#x27;rets_pk&#x27; ] ) ? $import[ &#x27;rets_pk&#x27; ] : self::$meta[ &#x27;rets&#x27; ].pk;
            /** Determine our Photo object */
            //$rets_photo = !empty( $import[&#x27;rets_photo&#x27;] ) ? $import[&#x27;rets_photo&#x27;] : self::$meta[ &#x27;rets&#x27; ][ &#x27;photo&#x27; ];
            /** Determine our Query */
            $rets_query = !empty( $import[ &#x27;rets_query&#x27; ] ) ? $import[ &#x27;rets_query&#x27; ] : self::$default_rets_query;
            /** Do our dynamic dates */
            $rets_query = str_replace( array(
              &#x27;[this_month]&#x27;,
              &#x27;[next_month]&#x27;,
              &#x27;[previous_month]&#x27;
            ), array(
              date( &quot;Y-m&quot;, strtotime( &#x27;now&#x27; ) ) . &#x27;-01&#x27;,
              date( &quot;Y-m-d&quot;, strtotime( &#x27;+1 month&#x27; ) ),
              date( &quot;Y-m-d&quot;, strtotime( &#x27;-1 month&#x27; ) )
            ), $rets_query );

            /** On preview, we have to get the FULL feed, but not all the images */
            if( $_REQUEST[ &#x27;wpp_action_type&#x27; ] == &#x27;source_evaluation&#x27; || $_REQUEST[ &#x27;preview&#x27; ] == true || $_REQUEST[ &#x27;raw_preview&#x27; ] == &#x27;true&#x27; ) {
              $partial_cache = true;
              $limit         = 1;
              $_required     = array();
              $_one_required = array();
              $_searchable   = array();
              /* Do quick analysis of meta data @updated 1.3.6 */
              foreach( (array) $rets-&gt;GetMetadata( $resource, $import[ &#x27;rets_class&#x27; ] ) as $item ) {
                $_attribute_key = $item[ &#x27;StandardName&#x27; ] ? $item[ &#x27;StandardName&#x27; ] : $item[ &#x27;LongName&#x27; ];
                $item           = array_filter( (array) $item );
                if( $item[ &#x27;Required&#x27; ] == 1 ) {
                  $_required[ $_attribute_key ] = $item;
                }
                if( $item[ &#x27;Required&#x27; ] == 2 ) {
                  $_one_required[ $_attribute_key ] = $item;
                }
                if( $item[ &#x27;Searchable&#x27; ] ) {
                  $_searchable[ $_attribute_key ] = $item;
                }
              }
            }

            /** Search for Properties */
            $search = $rets-&gt;SearchQuery( $resource, $import[ &#x27;rets_class&#x27; ], $rets_query, array( &#x27;Limit&#x27; =&gt; $limit ) );

            if( !$search ) {

              preg_match_all( &#x27;/\(([^=]+)=(.*?)\)/sim&#x27;, $rets_query, $matches, PREG_SET_ORDER );

              foreach( (array) $matches as $match ) {
                $_used_keys[ ] = $match[ 1 ];
              }

              switch( $rets-&gt;error_info[ &#x27;code&#x27; ] ) {

                /* Invalid Query Syntax. */
                case 20206:
                  break;

                /* Missing close parenthesis on subquery. | Required search fields missing. | Illegal number in range for field List Price. */
                case 20203:

                  if( count( $_used_keys ) != count( $_required ) ) {
                    throw new Exception( &quot;The search query failed because this provider requires certain attributes to be included in the search query. Required attribute(s): &quot; . implode( &#x27;, &#x27;, array_keys( $_required ) ) . ( $_one_required ? &quot;. At least one: &quot; . implode( &#x27;, &#x27;, array_keys( $_one_required ) ) : &#x27;&#x27; ) );
                  }

                  break;

              }

              /* See if we are missing required attributes */

              throw new Exception( &quot;There was an issue doing the RETS search: &quot; . $rets-&gt;error_info[ &#x27;text&#x27; ] );
            }

            self::maybe_echo_log( &#x27;RETS connection established. Got &#x27; . number_format_i18n( $rets-&gt;NumRows( $search ) ) . &#x27; out of &#x27; . number_format_i18n( $rets-&gt;TotalRecordsFound( $search ) ) . &#x27; total listings.&#x27; );

            $processed_properties = array();

            $row_count = 1;

            //** Create a temp directory using the import ID as name */
            $image_directory = self::create_import_directory( array( &#x27;ad_hoc_temp_dir&#x27; =&gt; $schedule_id ) );

            if( $image_directory ) {
              $image_directory = $image_directory[ &#x27;ad_hoc_temp_dir&#x27; ];
            } else {
              self::maybe_echo_log( sprintf( __( &#x27;Image directory %1s could not be created.&#x27;, &#x27;wpp&#x27; ), $image_directory ) );
            }

            while( $row = $rets-&gt;FetchRow( $search ) ) {
              self::keep_hope_alive();
              $processed_properties[ $row[ $rets_pk ] ] = true;
              //** Write row data, with formatted image data, back to $xml object */
              write( $xml, array(
                &#x27;ROW&#x27; =&gt; $row
              ) );
              $row_count++;
            }
            /** End of RETS $search cycle */

            if( is_array( $processed_properties ) ) {
              $processed_properties = count( $processed_properties );
            }

            self::maybe_echo_log( &quot;Initial RETS cycle complete, processed {$processed_properties} properties.&quot; );
            $wpp_import_result_stats[ ] = &quot;Found {$processed_properties} properties in RETS feed.&quot;;

            $xml-&gt;endElement();
            $xml-&gt;endDocument();

            $rets-&gt;FreeResult( $search );
            unset ( $xml );
            unset ( $rets );

          } catch( Exception $e ) {
            die( json_encode( array( &#x27;success&#x27; =&gt; &#x27;false&#x27;, &#x27;message&#x27; =&gt; mb_convert_encoding( $e-&gt;getMessage(), &#x27;UTF8&#x27; ) ) ) );
          }

          $str = file_get_contents( $xml_file );

          return array( &#x27;body&#x27; =&gt; $str );

        }

        // XML / JSON and WP-Property Exports
        if( $data[ &#x27;wpp_property_import&#x27; ][ &#x27;source_type&#x27; ] == &#x27;xml&#x27; || $data[ &#x27;wpp_property_import&#x27; ][ &#x27;source_type&#x27; ] == &#x27;wpp&#x27; || $data[ &#x27;wpp_property_import&#x27; ][ &#x27;source_type&#x27; ] == &#x27;json&#x27; ) {

          /** Only connect if we aren&#x27;t a stepping element */
          if( !isset( $_REQUEST[ &#x27;stepping_element&#x27; ] ) ) {

            $url_array = parse_url( $url );

            if( !empty( $url_array[ &#x27;query&#x27; ] ) ) {
              parse_str( $url_array[ &#x27;query&#x27; ], $newvars );
            }

            if( $method == &#x27;post&#x27; &amp;&amp; !empty( $newvars ) &amp;&amp; count( $newvars ) ) {
              $return = wp_remote_post( $url, array( &#x27;timeout&#x27; =&gt; apply_filters( &#x27;wpp_xi_wp_remote_timeout&#x27;, 300, array( &#x27;method&#x27; =&gt; $method, &#x27;url&#x27; =&gt; $url ) ), &#x27;body&#x27; =&gt; array( &#x27;request&#x27; =&gt; serialize( $newvars ) ) ) );
            } else {
              $return = wp_remote_get( $url, array( &#x27;timeout&#x27; =&gt; apply_filters( &#x27;wpp_xi_wp_remote_timeout&#x27;, 300, array( &#x27;method&#x27; =&gt; $method, &#x27;url&#x27; =&gt; $url ) ) ) );
            }
            //** Check if data is JSON or XML */
            if( is_wp_error( $return ) ) {
              return $return;
            } else {
              $maybe_json = Utility::json_to_xml( $return[ &#x27;body&#x27; ] );
            }

            //** If json_to_xml() returns something then data was in JSON, but is now converted into XML */
            if( $maybe_json ) {
              $return[ &#x27;body&#x27; ] = $maybe_json;
            }

            /** Write our cached file */
            if( isset( $_REQUEST[ &#x27;stepping&#x27; ] ) ) {
              file_put_contents( WPP_Path . &quot;cache/&quot; . $data[ &#x27;wpp_property_import&#x27; ][ &#x27;hash&#x27; ] . &quot;.xml&quot;, $return[ &#x27;body&#x27; ] );
            }

          } else {
            $str              = file_get_contents( WPP_Path . &quot;cache/&quot; . $data[ &#x27;wpp_property_import&#x27; ][ &#x27;hash&#x27; ] . &quot;.xml&quot; );
            $return[ &#x27;body&#x27; ] = $str;
          }

          return $return;
        }

      }

      /**
       * Attaches an image from url to specified post
       *
       * Uses post_content_filtered to provide a unique ID which is generated by creating an md5 hash from the filename.
       *
       *
       * * hash - Will be generated from md5 of file if not provided.
       * * image - This may be a file path or a URL.
       * * data - The parent post object, should be renamed.
       *
       *
       * @args passed via $settings: $schedule_settings
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc.
       */
      static public function attach_image( $args = false ) {
        global $wpp_property_import, $wpdb, $wpp_import_result_stats;

        self::keep_hope_alive();

        if( !$args ) {
          return false;
        }

        $args = (object) wp_parse_args( $args, array(
          &#x27;post_id&#x27;           =&gt; &#x27;&#x27;,
          &#x27;image&#x27;             =&gt; null,
          &#x27;data&#x27;              =&gt; &#x27;&#x27;,
          &#x27;hash&#x27;              =&gt; null,
          &#x27;schedule_settings&#x27; =&gt; &#x27;&#x27;,
          &#x27;schedule_id&#x27;       =&gt; &#x27;&#x27;,
          &#x27;check_existance&#x27;   =&gt; true,
          &#x27;title&#x27;             =&gt; &#x27;Property Image&#x27;,
          &#x27;content&#x27;           =&gt; &#x27;&#x27;,
          &#x27;name&#x27;              =&gt; &#x27;wpp_i_&#x27; . time() . &#x27;_&#x27; . rand( 10000, 100000 )
        ) );

        $args-&gt;image = isset( $args-&gt;image ) ? trim( $args-&gt;image ) : &#x27;&#x27;;

        // Image argument is required.
        if( empty( $args-&gt;image ) ) {
          return false;
        }

        // Should probably figure this out at a higher leve.
        if( !( ( $uploads = wp_upload_dir( current_time( &#x27;mysql&#x27; ) ) ) &amp;&amp; false === $uploads[ &#x27;error&#x27; ] ) ) {
          return false;
        }

        //** Figure out if this file is local, or remote based off the URL */

        //$local_file = ( stripos( &#x27;http://&#x27;, $args-&gt;image ) === false || stripos( &#x27;https://&#x27;, $args-&gt;image ) === false ) ? true : false;
        $_local = ( preg_match( &#x27;%^https?://%i&#x27;, $args-&gt;image ) ? false : true );

        $url_parts = parse_url( $args-&gt;image );

        if( !empty( $url_parts[ &#x27;path&#x27; ] ) ) {
          $file_parts = pathinfo( $url_parts[ &#x27;path&#x27; ] );
          if( isset( $url_parts[ &#x27;query&#x27; ] ) ) {
            $filename = ( $file_parts[ &#x27;filename&#x27; ] . &#x27;-&#x27; . $url_parts[ &#x27;query&#x27; ] );
          } else {
            $filename = $file_parts[ &#x27;filename&#x27; ];
          }
          // remove all character symbols
          $filename = ereg_replace( &quot;[^-_A-Za-z0-9]&quot;, &quot;&quot;, $filename );
          $filename .= &#x27;.&#x27; . ( ( in_array( strtolower( $file_parts[ &#x27;extension&#x27; ] ), array( &#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;gif&#x27; ) ) ) ? $file_parts[ &#x27;extension&#x27; ] : &#x27;jpg&#x27; );
        } else {
          //** Will break out URL or Path properly. File filename cannot be generated for whatever reason, we create a random one. */
          $filename = rand( 100000000, 999999999 ) . &#x27;.jpg&#x27;;
        }

        $filename = apply_filters( &#x27;wpp_xi_temp_file_path&#x27;, sanitize_file_name( $filename ), array(
          &#x27;filename&#x27;   =&gt; $filename,
          &#x27;settings&#x27;   =&gt; $args,
          &#x27;hash_image&#x27; =&gt; $args-&gt;hash,
          &#x27;image&#x27;      =&gt; $args-&gt;image
        ) );

        // Create md5 hash for the new image, to see if it already exists
        if( !$args-&gt;hash ) {
          $args-&gt;hash = @md5_file( $args-&gt;image );
        }

        //** Create directory structure if it isn&#x27;t there already */
        $import_directory = self::create_import_directory( array(
          &#x27;post_id&#x27; =&gt; $args-&gt;post_id
        ) );

        if( $import_directory[ &#x27;post_dir&#x27; ] ) {
          $property_directory = $import_directory[ &#x27;post_dir&#x27; ];
        }

        if( !is_dir( $property_directory ) ) {
          self::maybe_echo_log( &quot;Unable to create image directory: {$property_directory}.&quot; );

          return false;
        }

        // Update uploads path for our unique file storage structure
        $new_file_path = apply_filters( &#x27;wpp_xi_new_file_path&#x27;, trailingslashit( $property_directory ) . wp_unique_filename( $property_directory, $filename ), array(
            &#x27;dir&#x27;        =&gt; $import_directory[ &#x27;post_dir&#x27; ],
            &#x27;url&#x27;        =&gt; $import_directory[ &#x27;post_url&#x27; ],
            &#x27;filename&#x27;   =&gt; $filename,
            &#x27;settings&#x27;   =&gt; $args,
            &#x27;hash_image&#x27; =&gt; $args-&gt;hash,
            &#x27;return&#x27;     =&gt; &#x27;path&#x27;
          ) );

        // If do_not_check_existance is passed, we skip this step
        if( $args-&gt;check_existance ) {

          $file_exists = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &quot;
        SELECT ID, guid, post_date, post_parent 
        FROM {$wpdb-&gt;posts} 
        WHERE post_content_filtered = &#x27;&quot; . $args-&gt;hash . &quot;&#x27; 
        AND post_parent = %d 
        LIMIT 1&quot;, $args-&gt;post_id )
          );

          if( $file_exists &amp;&amp; $args-&gt;post_id == $file_exists-&gt;post_parent ) {
            do_action( &#x27;wpp_xml_import_attach_image&#x27;, $args-&gt;post_id, $args-&gt;image, $file_exists-&gt;ID, $args-&gt;data );

            return array(
              &#x27;thumb_id&#x27; =&gt; $file_exists-&gt;ID,
              &#x27;action&#x27;   =&gt; &#x27;image_exists&#x27;
            );

          }

          // @note I have no fucking idea what this is for. -potanin @UD
          if( !empty( $file_exists ) ) {
            $uploads_old   = wp_upload_dir( $file_exists-&gt;post_date );
            $old_file      = pathinfo( $file_exists-&gt;guid );
            $old_file_size = @filesize( $uploads_old[ &#x27;path&#x27; ] . &#x27;/&#x27; . $old_file[ &#x27;basename&#x27; ] );
            $new_file_size = intval( self::get_remote_file_size( $args-&gt;image, false ) );

            if( ( $old_file_size == $new_file_size ) &amp;&amp; ( intval( $file_exists-&gt;post_parent ) == intval( $args-&gt;post_id ) ) ) {
              return false;
            } else if( $old_file_size == $new_file_size ) {
              wp_delete_attachment( $args-&gt;post_id, true );
            }
          }

        }

        //** Frist method of getting images */
        if( $_local ) {

          //** If URL appears to be a path, we load contents, but what if it&#x27;s not there? */
          if( file_exists( $args-&gt;image ) ) {
            $content         = file_get_contents( $args-&gt;image );
            $this_image_size = @getimagesize( $args-&gt;image );
          } else {
            //self::maybe_echo_log( sprintf( __( &#x27;Listing image  ( &#x27; .  $args-&gt;image . &#x27; )  appears to be local, but could not be accessed.&#x27;, &#x27;wpp&#x27; ), $args-&gt;image ) );
            return;
          }

          $image_request_method = __( &#x27;on disk using file_get_contents()&#x27;, &#x27;wpp&#x27; );

        } else {

          if( $args-&gt;schedule_settings[ &#x27;log_detail&#x27; ] == &#x27;on&#x27; ) {
            self::maybe_echo_log( sprintf( __( &#x27;Attempting to get image  ( &#x27; . $args-&gt;image . &#x27; )  using wp_remote_get()&#x27;, &#x27;wpp&#x27; ), $args-&gt;image ) );
          }

          $image_request = wp_remote_get( preg_replace( &#x27;~\s~&#x27;, &#x27;%20&#x27;, $args-&gt;image ), array(
            &#x27;timeout&#x27; =&gt; apply_filters( &#x27;wpp_xi_wp_remote_timeout&#x27;, 300 )
          ) );

          if( is_wp_error( $image_request ) || !$image_request[ &#x27;body&#x27; ] ) {
            self::maybe_echo_log( &quot;Unable to get image ( {args-&gt;image} ) : &quot; . ( !empty( $image_request ) ) ? $image_request-&gt;get_error_message() : &#x27;&#x27; );

            return;
          }

          $content = $image_request[ &#x27;body&#x27; ];

        }

        // Write to Disk.
        file_put_contents( $new_file_path, $content );

        // Check if image is valid, delete if not, and log message if detail is on.
        if( !$this_image_size = @getimagesize( $new_file_path ) ) {

          if( $args-&gt;schedule_settings[ &#x27;log_detail&#x27; ] == &#x27;on&#x27; ) {
            self::maybe_echo_log( sprintf( __( &#x27;Image %1s corrupted - skipped.&#x27;, &#x27;wpp&#x27; ), $args-&gt;image ) );
          }

          @unlink( $new_file_path );

          return false;
        }

        //** If minimum width or height are set, we check them here, and delete image if does  not meet quality standards */
        if( ( $args-&gt;schedule_settings[ &#x27;min_image_width&#x27; ] &gt; 0 &amp;&amp; ( $this_image_size[ 0 ] &lt; $args-&gt;schedule_settings[ &#x27;min_image_width&#x27; ] ) ) || ( $args-&gt;schedule_settings[ &#x27;max_image_height&#x27; ] &gt; 0 &amp;&amp; ( $this_image_size[ 1 ] &lt; $args-&gt;schedule_settings[ &#x27;max_image_height&#x27; ] ) ) ) {
          $image_size_fail = true;
        }

        if( $image_size_fail ) {

          if( $args-&gt;schedule_settings[ &#x27;log_detail&#x27; ] == &#x27;on&#x27; ) {
            self::maybe_echo_log( sprintf( __( &#x27;Image %1s downloaded, but image size failed quality standards - deleting.&#x27;, &#x27;wpp&#x27; ), $args-&gt;image ) );
            $wpp_import_result_stats[ &#x27;quality_control&#x27; ][ &#x27;skipped_images&#x27; ]++;
          }

          if( $_local ) {
            @unlink( $new_file_path );
          }

          return false;
        }

        // Try to remove the old one, if it still exists
        if( !preg_match( &#x27;/^http/&#x27;, $args-&gt;image ) ) {
          @unlink( $args-&gt;image );
        }

        $new_file_path = apply_filters( &#x27;wpp_xi_image_save&#x27;, $new_file_path, $args );

        // Bail if it didn&#x27;t work for some reason
        if( !file_exists( $new_file_path ) ) {
          self::maybe_echo_log( sprintf( __( &#x27;Unable to save image %1s.&#x27;, &#x27;wpp&#x27; ), $args-&gt;image ) );

          return false;
        }

        // Set correct file permissions
        $stat = stat( dirname( $new_file_path ) );

        chmod( $new_file_path, 0644 );

        // get file type
        $wp_check_filetype = wp_check_filetype( $new_file_path );

        // No file type! No point to proceed further
        if( ( !$wp_check_filetype[ &#x27;type&#x27; ] || !$wp_check_filetype[ &#x27;ext&#x27; ] ) &amp;&amp; !current_user_can( &#x27;unfiltered_upload&#x27; ) ) {
          self::maybe_echo_log( &quot;Image saved to disk, but some problem occured with file type.&quot; );

          return false;
        }

        include_once ABSPATH . &#x27;wp-admin/includes/image.php&#x27;;

        // use image exif/iptc data for title and caption defaults if possible
        if( $image_meta = wp_read_image_metadata( $new_file_path ) ) {

          if( trim( $image_meta[ &#x27;title&#x27; ] ) ) {
            $title = $image_meta[ &#x27;title&#x27; ];
          }

          if( trim( $image_meta[ &#x27;caption&#x27; ] ) ) {
            $post_content = $image_meta[ &#x27;caption&#x27; ];
          }

        }

        // Compute the URL
        $url = apply_filters( &#x27;wpp_xi_compute_url&#x27;, $uploads[ &#x27;baseurl&#x27; ] . &quot;/wpp_import_files/$args-&gt;post_id/$filename&quot;, array(
            &#x27;dir&#x27;        =&gt; $import_directory[ &#x27;post_dir&#x27; ],
            &#x27;url&#x27;        =&gt; $import_directory[ &#x27;post_url&#x27; ],
            &#x27;filename&#x27;   =&gt; $filename,
            &#x27;settings&#x27;   =&gt; $args,
            &#x27;hash_image&#x27; =&gt; $args-&gt;hash,
            &#x27;return&#x27;     =&gt; &#x27;url&#x27;
          ) );

        $thumb_id = wp_insert_attachment( array(
          &#x27;post_mime_type&#x27;        =&gt; $wp_check_filetype[ &#x27;type&#x27; ],
          &#x27;guid&#x27;                  =&gt; $url,
          &#x27;post_name&#x27;             =&gt; $args-&gt;name,
          &#x27;post_parent&#x27;           =&gt; $args-&gt;post_id,
          &#x27;post_title&#x27;            =&gt; $args-&gt;title,
          &#x27;post_content&#x27;          =&gt; $args-&gt;content,
          &#x27;post_content_filtered&#x27; =&gt; $args-&gt;hash
        ), $new_file_path, $args-&gt;post_id );

        // @note Is this really necessary here? 
        if( !is_wp_error( $thumb_id ) &amp;&amp; function_exists( &#x27;wp_generate_attachment_metadata&#x27; ) &amp;&amp; function_exists( &#x27;wp_update_attachment_metadata&#x27; ) ) {

          $attach_data = wp_generate_attachment_metadata( $thumb_id, $new_file_path );

          wp_update_attachment_metadata( $thumb_id, $attach_data );

          update_post_meta( $thumb_id, &#x27;wpp_imported_image&#x27;, true );

          do_action( &#x27;wpp_xml_import_attach_image&#x27;, $args-&gt;post_id, $args-&gt;image, $thumb_id, $$args-&gt;data );

        }

        return array(
          &#x27;thumb_id&#x27;   =&gt; $thumb_id,
          &#x27;action&#x27;     =&gt; &#x27;image_downloaded&#x27;,
          &#x27;image_size&#x27; =&gt; filesize( $new_file_path )
        );

      }

      /**
       * Cycle through all properties with parent_gpid and update post_parent variable to match
       *
       * @todo This seems to run every time regardles of if there were any parent/child relationships in the first place.
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc.
       */
      static public function reassociate_parent_ids() {
        global $wpdb;

        self::maybe_echo_log( &quot;Beginning parent IDs association.&quot; );

        //** Find properties that have a parent GPID. Get IDs and GPIDs of all properties that have parent_gpid meta_key value *//
        $orphans = $wpdb-&gt;get_results( &quot;SELECT post_id, meta_value as gpid FROM {$wpdb-&gt;postmeta} WHERE meta_key = &#x27;parent_gpid&#x27; AND meta_value IS NOT NULL&quot; );

        if( empty( $orphans ) ) {
          //** No orphan properties *//
          self::maybe_echo_log( &quot;No orphan properties - association stopped.&quot; );

          return;
        }

        //** Find properties&#x27; parents by GPID. *//
        foreach( $orphans as $orphan ) {
          $post_parent = $wpdb-&gt;get_var( $wpdb-&gt;prepare( &quot;SELECT post_id FROM {$wpdb-&gt;postmeta} WHERE meta_key = &#x27;wpp_gpid&#x27; AND meta_value = %s LIMIT 0, 1&quot;, $orphan-&gt;gpid ) );

          if( $post_parent ) {
            //** Parent found *//
            $wpdb-&gt;update( $wpdb-&gt;posts, array( &#x27;post_parent&#x27; =&gt; $post_parent ), array( &#x27;ID&#x27; =&gt; $orphan-&gt;post_id ) );
            self::maybe_echo_log( &quot;Associated child {$orphan-&gt;post_id} with parent {$post_parent}.&quot; );
          }

        }

        self::maybe_echo_log( &quot;Parent ID association complete.&quot; );
      }

      /**
       * Gets remote file size from url
       *
       * Copyright 2010 - 2014 Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
       *
       */
      static public function get_remote_file_size( $url, $readable = true ) {
        $parsed = parse_url( $url );
        $host   = $parsed[ &quot;host&quot; ];
        $fp     = @fsockopen( $host, 80, $errno, $errstr, 20 );
        if( !$fp ) return false;
        else {
          @fputs( $fp, &quot;HEAD $url HTTP/1.1\r\n&quot; );
          @fputs( $fp, &quot;HOST: $host\r\n&quot; );
          @fputs( $fp, &quot;Connection: close\r\n\r\n&quot; );
          $headers = &quot;&quot;;
          while( !@feof( $fp ) ) $headers .= @fgets( $fp, 128 );
        }
        @fclose( $fp );
        $return      = false;
        $arr_headers = explode( &quot;\n&quot;, $headers );
        foreach( $arr_headers as $header ) {
          // follow redirect
          $s = &#x27;Location: &#x27;;
          if( substr( strtolower( $header ), 0, strlen( $s ) ) == strtolower( $s ) ) {
            $url = trim( substr( $header, strlen( $s ) ) );

            return get_remote_file_size( $url, $readable );
          }

          // parse for content length
          $s = &quot;Content-Length: &quot;;
          if( substr( strtolower( $header ), 0, strlen( $s ) ) == strtolower( $s ) ) {
            $return = trim( substr( $header, strlen( $s ) ) );
            break;
          }
        }
        if( $return &amp;&amp; $readable ) {
          $size = round( $return / 1024, 2 );
          $sz   = &quot;KB&quot;; // Size In KB
          if( $size &gt; 1024 ) {
            $size = round( $size / 1024, 2 );
            $sz   = &quot;MB&quot;; // Size in MB
          }
          $return = &quot;$size $sz&quot;;
        }

        return $return;
      }

      /**
       * Gets data from cached source if it exists
       *
       *
       * @param      $schedule_id
       * @param bool $source_type
       *
       * @returns false on failure, XML in SimpleXMLElement format if data is there.
       */
      static public function get_cached_source( $schedule_id, $source_type = false ) {
        if( !( ( $uploads = wp_upload_dir( current_time( &#x27;mysql&#x27; ) ) ) &amp;&amp; false === $uploads[ &#x27;error&#x27; ] ) ) {
          return false; // upload dir is not accessible
        }
        if( $source_type ) {
          $source_type = $source_type . &#x27;_&#x27;;
        }
        $cache_file = $uploads[ &#x27;basedir&#x27; ] . &quot;/wpp_import_files/temp/{$schedule_id}/{$source_type}cache.xml&quot;;
        //** Check if  a source_cache file exists and is not empty */
        if( file_exists( $cache_file ) &amp;&amp; filesize( $cache_file ) ) {
          $xml_data             = file_get_contents( $cache_file );
          $result[ &#x27;time&#x27; ]     = filemtime( $cache_file );
          $result[ &#x27;xml_data&#x27; ] = $xml_data;

          return $result;
        }

        return false;
      }

      /**
       * This function creates the cached image directory
       *
       * @param array|bool $args If passed, creates a folder in the temp directory
       *
       * @return false on failure, directory path if known
       */
      static public function create_import_directory( $args = false ) {
        if( !( ( $uploads = wp_upload_dir( current_time( &#x27;mysql&#x27; ) ) ) &amp;&amp; false === $uploads[ &#x27;error&#x27; ] ) ) {
          return false; // upload dir is not accessible
        }
        //** The base directory all the other files and directories will be in */
        $base_dir = $uploads[ &#x27;basedir&#x27; ] . &#x27;/wpp_import_files&#x27;;
        $base_url = $uploads[ &#x27;baseurl&#x27; ] . &#x27;/wpp_import_files&#x27;;
        //** Check if directory is there, or create it and chmod it, for true */
        if( is_dir( $base_dir ) || ( mkdir( $base_dir ) &amp;&amp; chmod( $base_dir, 0755 ) ) ) {
          $exists[ &#x27;base_dir&#x27; ] = $base_dir;
          $exists[ &#x27;base_url&#x27; ] = $base_url;
        }
        //** Create a new directory if we have too many objects in root one */
        $sub_folder = 1;
        while( count( @scandir( $exists[ &#x27;base_dir&#x27; ] . &#x27;/&#x27; . $sub_folder ) ) &gt; 500 ) {
          $sub_folder++;
        }
        $current_sub_dir = $exists[ &#x27;base_dir&#x27; ] . &#x27;/&#x27; . $sub_folder;
        $current_sub_url = $exists[ &#x27;base_url&#x27; ] . &#x27;/&#x27; . $sub_folder;
        //** Create directory structure if it isn&#x27;t there already */
        if( is_dir( $current_sub_dir ) || ( mkdir( $current_sub_dir ) &amp;&amp; chmod( $current_sub_dir, 0755 ) ) ) {
          $exists[ &#x27;current_sub_dir&#x27; ] = $current_sub_dir;
          $exists[ &#x27;current_sub_url&#x27; ] = $current_sub_url;
        }
        $generic_temp_dir = $exists[ &#x27;base_dir&#x27; ] . &#x27;/temp&#x27;;
        $generic_temp_url = $exists[ &#x27;base_url&#x27; ] . &#x27;/temp&#x27;;
        //** Create a generic temporary directory */
        if( is_dir( $generic_temp_dir ) || ( mkdir( $generic_temp_dir ) &amp;&amp; chmod( $generic_temp_dir, 0755 ) ) ) {
          $exists[ &#x27;generic_temp_dir&#x27; ] = $generic_temp_dir;
          $exists[ &#x27;generic_temp_url&#x27; ] = $generic_temp_url;
        }
        if( $args[ &#x27;ad_hoc_temp_dir&#x27; ] ) {
          $ad_hoc_temp_dir = $exists[ &#x27;generic_temp_dir&#x27; ] . &#x27;/&#x27; . $args[ &#x27;ad_hoc_temp_dir&#x27; ];
          $ad_hoc_temp_url = $exists[ &#x27;generic_temp_url&#x27; ] . &#x27;/&#x27; . $args[ &#x27;ad_hoc_temp_dir&#x27; ];
          if( is_dir( $ad_hoc_temp_dir ) || ( mkdir( $ad_hoc_temp_dir ) &amp;&amp; chmod( $ad_hoc_temp_dir, 0755 ) ) ) {
            $exists[ &#x27;ad_hoc_temp_dir&#x27; ] = $ad_hoc_temp_dir;
            $exists[ &#x27;ad_hoc_temp_url&#x27; ] = $ad_hoc_temp_url;
          }
        }
        if( $args[ &#x27;post_id&#x27; ] ) {
          $post_dir = $current_sub_dir . &#x27;/&#x27; . $args[ &#x27;post_id&#x27; ];
          $post_url = $current_sub_url . &#x27;/&#x27; . $args[ &#x27;post_id&#x27; ];
          if( is_dir( $post_dir ) || ( mkdir( $post_dir ) &amp;&amp; chmod( $post_dir, 0755 ) ) ) {
            $exists[ &#x27;post_dir&#x27; ] = $post_dir;
            $exists[ &#x27;post_url&#x27; ] = $post_url;
          }
        }
        if( is_array( $exists = apply_filters( &#x27;wpp_xi_create_import_directory&#x27;, $exists, $args ) ) ) {
          return $exists;
        }

        return false;
      }

      /**
       * Called during rule processing for all single values.
       *
       * @params array ( value, rule_attribute, schedule_settings )
       */
      static public function format_single_value( $data ) {

        $data = wp_parse_args( $data, array(
          &#x27;uppercase&#x27; =&gt; false
        ) );

        $to_skip_attributes = array( &#x27;images&#x27;, &#x27;featured-image&#x27; );
        $original_value     = $data[ &#x27;value&#x27; ];
        $schedule_settings  = $data[ &#x27;schedule_settings&#x27; ];

        //** Set uppercase if needed */
        if( $data[ &#x27;uppercase&#x27; ] ) {
          $data[ &#x27;value&#x27; ] = strtoupper( $data[ &#x27;value&#x27; ] );
        }

        //** Certain fields should be skipped because they will not use any text formatting */
        if( in_array( $data[ &#x27;rule_attribute&#x27; ], $to_skip_attributes ) ) {
          return $data[ &#x27;value&#x27; ];
        }

        //* Property type must be a slug */
        if( $data[ &#x27;rule_attribute&#x27; ] == &#x27;property_type&#x27; ) {
          return UD_F::create_slug( $data[ &#x27;value&#x27; ], array( &#x27;separator&#x27; =&gt; &#x27;_&#x27; ) );
        }

        //** If caps lock fixing is enabled, and this string is ALL caps */
        if( isset( $data[ &#x27;schedule_settings&#x27; ][ &#x27;fix_caps&#x27; ] ) &amp;&amp; ( $data[ &#x27;schedule_settings&#x27; ][ &#x27;fix_caps&#x27; ] == &#x27;on&#x27; &amp;&amp; ( strtoupper( $data[ &#x27;value&#x27; ] ) == $data[ &#x27;value&#x27; ] ) ) ) {
          $data[ &#x27;value&#x27; ] = ucwords( strtolower( $data[ &#x27;value&#x27; ] ) );
        }

        //** Attempt to remove any formatting */
        if( $data[ &#x27;schedule_settings&#x27; ][ &#x27;force_remove_formatting&#x27; ] == &#x27;on&#x27; ) {
          $data[ &#x27;value&#x27; ] = strip_tags( $data[ &#x27;value&#x27; ] );
        }

        $data[ &#x27;value&#x27; ] = str_replace( &#x27;&amp;nbsp;&#x27;, &#x27;&amp;&#x27;, $data[ &#x27;value&#x27; ] );

        return $data[ &#x27;value&#x27; ];

      }

      /**
       * Email notification system, for using from cron.
       *
       * @version 2.5.6
       *
       **/
      static public function email_notify( $message_text, $short_text = false ) {
        global $wpdb;

        //** Try to get custom WPP email. If not, the default admin_email will work. */
        if( !$notification_email = $wpdb-&gt;get_var( &quot;SELECT option_value FROM {$wpdb-&gt;options} WHERE option_name = &#x27;wpp_importer_cron_email&#x27;&quot; ) ) {
          $notification_email = $wpdb-&gt;get_var( &quot;SELECT option_value FROM {$wpdb-&gt;options} WHERE option_name = &#x27;admin_email&#x27;&quot; );
        }

        //** Need to get the domain from, DB since $_SERVER is not available in cron */
        $siteurl = $wpdb-&gt;get_var( &quot;SELECT option_value FROM {$wpdb-&gt;options} WHERE option_name = &#x27;siteurl&#x27;&quot; );
        $domain  = parse_url( $siteurl, PHP_URL_HOST );

        $subject = &#x27;Update from XML Importer&#x27; . ( $short_text ? &#x27;: &#x27; . $short_text : &#x27;&#x27; );
        $headers = &#x27;From: &quot;XML Importer&quot; &lt;xml_importer@&#x27; . $domain . &#x27;&gt;&#x27;;

        //$message[] = &quot;Update from XML Importer:\n&quot;;
        $message[ ] = &#x27;&lt;div style=&quot;font-size: 1.6em;margin-bottom: 5px;&quot;&gt;XML Importer: &#x27; . $short_text . &#x27;&lt;/div&gt;&lt;div style=&quot;font-size: 1em;color:#555555;&quot;&gt;&#x27; . $message_text . &#x27;&lt;/div&gt;&#x27;;

        add_filter( &#x27;wp_mail_content_type&#x27;, create_function( &#x27;&#x27;, &#x27;return &quot;text/html&quot;;&#x27; ) );

        if( wp_mail( $notification_email, $subject, implode( &#x27;&#x27;, $message ), $headers ) ) {
          return true;
        }

        return false;

      }

      /**
       * Convert bytes to a more appropriate format.
       *
       * @version 2.5.6
       */
      static public function format_size( $size ) {
        $sizes = array( &quot; Bytes&quot;, &quot; KB&quot;, &quot; MB&quot;, &quot; GB&quot;, &quot; TB&quot;, &quot; PB&quot;, &quot; EB&quot;, &quot; ZB&quot;, &quot; YB&quot; );
        if( $size == 0 ) {
          return ( &#x27;n/a&#x27; );
        } else {
          return ( round( $size / pow( 1024, ( $i = floor( log( $size, 1024 ) ) ) ), 2 ) . $sizes[ $i ] );
        }
      }

      /**
       * Analyzes source feed after it has been converted into XML.
       *
       * @version 3.0.0
       */
      static public function analyze_feed( $xml, $root = &#x27;&#x27; ) {
        $root_element_parts = explode( &#x27;/&#x27;, $root );
        $common_tag_name    = end( $root_element_parts );
        $query              = &quot;//{$common_tag_name}/*[not( * )]&quot;;
        /** Get all unique tags */
        $isolated_tags = @$xml-&gt;xpath( $query );
        $matched_tags  = array();
        if( is_array( $isolated_tags ) ) {
          foreach( $isolated_tags as $node ) {
            $matched_tags[ $node-&gt;getName() ] = true;
          }
          /** Isolate tag names in array */
          $matched_tags = array_keys( $matched_tags );
        }

        return is_array( $matched_tags ) ? $matched_tags : false;
      }

      /**
       * Keep the MySQL Connection alive (and hope).
       *
       * @since 3.2.1
       * @author potanin@UD
       */
      static public function keep_hope_alive() {
        global $wpdb;
        $wpdb-&gt;query( &quot;SELECT 1&quot; );
      }

    }

  }

  // Importer Schedule.
  if( !class_exists( &#x27;UsabilityDynamics\WPP\Importer\Schedule&#x27; ) ) {

    /**
     * Class Schedule
     *
     * @package UsabilityDynamics\WPP
     */
    class Schedule {

      /**
       * XMLI Instance Settings.
       *
       * @property $_settings
       * @type {Object}
       */
      private $_settings = false;

      /**
       * Initialize Schedule Object.
       *
       * @author potanin@UD
       */
      public function __construct() {

      }

      /**
       * Get Single Setting
       *
       * @param $key
       * @param $default
       *
       * @return null
       * @author potanin@UD
       */
      private function get( $key, $default ) {
        return null;
      }

      /**
       * Set Setting.
       *
       * @param $key
       * @param $value
       *
       * @return null
       *
       * @author potanin@UD
       */
      private function set( $key, $value ) {
        return null;
      }

    }

  }

}


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
