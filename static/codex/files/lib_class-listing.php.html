<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/class-listing.php - usabilitydynamics/wp-property</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="usabilitydynamics/wp-property"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.0.0-beta1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Bootstrap.html">Bootstrap</a></li>
            
                <li><a href="../classes/Exception.html">Exception</a></li>
            
                <li><a href="../classes/Theme.html">Theme</a></li>
            
                <li><a href="../classes/UsabilityDynamics\WPP.Bootstrap.html">UsabilityDynamics\WPP.Bootstrap</a></li>
            
                <li><a href="../classes/UsabilityDynamics\WPP.Loader.html">UsabilityDynamics\WPP.Loader</a></li>
            
                <li><a href="../classes/WP_Error.html">WP_Error</a></li>
            
                <li><a href="../classes/WPP.html">WPP</a></li>
            
                <li><a href="../classes/WPP_UI.html">WPP_UI</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib/class-listing.php</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&lt;?php
/**
 * WP-Property Listing Object
 *
 * Currently not used.
 *
 * @class WP_Error
 * @version 1.0
 * @author Usability Dynamics, Inc. &lt;info@usabilitydynamics.com&gt;
 * @package WP-Property
 * @since 1.38
 */
namespace UsabilityDynamics\WPP {

  if( !class_exists( &#x27;UsabilityDynamics\WPP\Listing&#x27; ) ) {

    class Listing {

      /**
       * Listing ID.
       *
       * @property $id
       * @type String
       */
      public $id;

      /**
       * Global Property ID.
       *
       * @property $gpid
       * @type String
       */
      public $gpid = &#x27;&#x27;;

      /**
       * Listing Description.
       *
       *
       * @property $content
       * @type String
       */
      public $content = &#x27;&#x27;;

      /**
       * Content Title.
       *
       * @static
       * @property $title
       * @type String
       */
      public $title = &#x27;&#x27;;

      /**
       * Listing Excerpt / Summary.
       *
       * @static
       * @property $excerpt
       * @type String
       */
      public $excerpt = &#x27;&#x27;;

      /**
       * Status.
       *
       * @static
       * @property $status
       * @type String
       */
      public $status = &#x27;publish&#x27;;

      /**
       * Parent ID.
       *
       * @static
       * @property $parent
       * @type Integer
       */
      public $parent = 0;

      /**
       * @param string $key
       * @param null   $default
       *
       * @return mixed
       */
      public function get( $key = &#x27;&#x27;, $default = null ) {
        return get_post_meta( $this-&gt;id, $key );
      }

      /**
       * @param string $key
       * @param string $value
       *
       * @internal param null $default
       *
       * @return mixed
       */
      public function set( $key = &#x27;&#x27;, $value = null ) {
        return update_post_meta( $this-&gt;id, $key, $value );
      }

      /**
       * Hooks into save_post function and saves additional property data
       *
       * @todo Add some sort of custom capability so not only admins can make properties as featured. i.e. Agents can make their own properties featured.
       *
       * @since 1.04
       */
      public function save( $id ) {
        global $wp_properties, $wp_version;

        $_wpnonce = ( version_compare( $wp_version, &#x27;3.5&#x27;, &#x27;&gt;=&#x27; ) ? &#x27;update-post_&#x27; : &#x27;update-property_&#x27; ) . $id;

        if( !wp_verify_nonce( $_POST[ &#x27;_wpnonce&#x27; ], $_wpnonce ) || $_POST[ &#x27;post_type&#x27; ] !== &#x27;property&#x27; ) {
          return $id;
        }

        //* Delete cache files of search values for search widget&#x27;s form */
        $directory = WPP_Path . &#x27;cache/searchwidget&#x27;;

        if( is_dir( $directory ) ) {
          $dir = opendir( $directory );
          while( ( $cachefile = readdir( $dir ) ) ) {
            if( is_file( $directory . &quot;/&quot; . $cachefile ) ) {
              unlink( $directory . &quot;/&quot; . $cachefile );
            }
          }
        }

        if( defined( &#x27;DOING_AUTOSAVE&#x27; ) &amp;&amp; DOING_AUTOSAVE ) {
          return $id;
        }

        $update_data = $_REQUEST[ &#x27;wpp_data&#x27; ][ &#x27;meta&#x27; ];

        //** Neccessary meta data which is required by Supermap Premium Feature. Should be always set even the Supermap disabled. peshkov@UD */
        if( empty( $_REQUEST[ &#x27;exclude_from_supermap&#x27; ] ) ) {
          if( !metadata_exists( &#x27;post&#x27;, $id, &#x27;exclude_from_supermap&#x27; ) ) {
            $update_data[ &#x27;exclude_from_supermap&#x27; ] = &#x27;false&#x27;;
          }
        }

        if( (float) $update_data[ &#x27;latitude&#x27; ] == 0 ) $update_data[ &#x27;latitude&#x27; ] = &#x27;&#x27;;
        if( (float) $update_data[ &#x27;longitude&#x27; ] == 0 ) $update_data[ &#x27;longitude&#x27; ] = &#x27;&#x27;;

        /* get old coordinates and location */
        $old_lat  = get_post_meta( $id, &#x27;latitude&#x27;, true );
        $old_lng  = get_post_meta( $id, &#x27;longitude&#x27;, true );
        $geo_data = array(
          &#x27;old_coordinates&#x27; =&gt; ( ( empty( $old_lat ) ) || ( empty( $old_lng ) ) ) ? &quot;&quot; : array( &#x27;lat&#x27; =&gt; $old_lat, &#x27;lng&#x27; =&gt; $old_lng ),
          &#x27;old_location&#x27;    =&gt; ( !empty( $wp_properties[ &#x27;configuration&#x27; ][ &#x27;address_attribute&#x27; ] ) ) ? get_post_meta( $id, $wp_properties[ &#x27;configuration&#x27; ][ &#x27;address_attribute&#x27; ], true ) : &#x27;&#x27;
        );

        foreach( (array) $update_data as $meta_key =&gt; $meta_value ) {
          $attribute_data = Utility::get_attribute_data( $meta_key );

          //* Cleans the user input */
          $meta_value = Utility::encode_mysql_input( $meta_value, $meta_key );

          //* Only admins can mark properties as featured. */
          if( $meta_key == &#x27;featured&#x27; &amp;&amp; !current_user_can( &#x27;manage_options&#x27; ) ) {
            //** But be sure that meta &#x27;featured&#x27; exists at all */
            if( !metadata_exists( &#x27;post&#x27;, $id, $meta_key ) ) {
              $meta_value = &#x27;false&#x27;;
            } else {
              continue;
            }
          }

          //* Remove certain characters */

          if( $attribute_data[ &#x27;currency&#x27; ] || $attribute_data[ &#x27;numeric&#x27; ] ) {
            $meta_value = str_replace( array( &quot;$&quot;, &quot;,&quot; ), &#x27;&#x27;, $meta_value );
          }

          //* Overwrite old post meta allowing only one value */
          delete_post_meta( $id, $meta_key );
          add_post_meta( $id, $meta_key, $meta_value );
        }

        //* Check if property has children */
        $children = get_children( &quot;post_parent=$id&amp;post_type=property&quot; );

        //* Write any data to children properties that are supposed to inherit things */
        if( count( $children ) &gt; 0 ) {
          foreach( (array) $children as $child_id =&gt; $child_data ) {
            //* Determine child property_type */
            $child_property_type = get_post_meta( $child_id, &#x27;property_type&#x27;, true );
            //* Check if child&#x27;s property type has inheritence rules, and if meta_key exists in inheritance array */
            if( is_array( $wp_properties[ &#x27;property_inheritance&#x27; ][ $child_property_type ] ) ) {
              foreach( (array) $wp_properties[ &#x27;property_inheritance&#x27; ][ $child_property_type ] as $i_meta_key ) {
                $parent_meta_value = get_post_meta( $id, $i_meta_key, true );
                //* inheritance rule exists for this property_type for this meta_key */
                update_post_meta( $child_id, $i_meta_key, $parent_meta_value );
              }
            }
          }
        }

        self::maybe_set_gpid( $id );

        if( isset( $_REQUEST[ &#x27;parent_id&#x27; ] ) ) {
          $_REQUEST[ &#x27;parent_id&#x27; ] = self::update_parent_id( $_REQUEST[ &#x27;parent_id&#x27; ], $id );
        }

        self::geolocate( $id );

        do_action( &#x27;wpp:save_property&#x27;, $id, $this );

        return true;

      }

      /**
       * Address validation function
       *
       * Since 1.37.2 extracted from save_property and revalidate_all_addresses to make same functionality
       *
       * @global array  $wp_properties
       *
       * @param integer $id
       * @param array   $args
       *
       * @return array
       * @since 1.37.2
       * @author odokienko@UD
       */
      public static function geolocate( $id, $args = array() ) {
        global $wp_properties;

        $args = wp_parse_args( $args, array(
          &#x27;skip_existing&#x27;   =&gt; &#x27;false&#x27;,
          &#x27;return_geo_data&#x27; =&gt; false,
        ) );

        extract( $args, EXTR_SKIP );
        $skip_existing   = isset( $skip_existing ) ? $skip_existing : &#x27;false&#x27;;
        $return_geo_data = isset( $return_geo_data ) ? $return_geo_data : false;

        $return = array();

        $geo_data             = false;
        $geo_data_coordinates = false;
        $latitude             = get_post_meta( $id, &#x27;latitude&#x27;, true );
        $longitude            = get_post_meta( $id, &#x27;longitude&#x27;, true );
        $current_coordinates  = $latitude . $longitude;
        $address_is_formatted = get_post_meta( $id, &#x27;address_is_formatted&#x27;, true );

        $address = get_post_meta( $id, $wp_properties[ &#x27;configuration&#x27; ][ &#x27;address_attribute&#x27; ], true );

        $coordinates = ( empty( $latitude ) || empty( $longitude ) ) ? &quot;&quot; : array( &#x27;lat&#x27; =&gt; get_post_meta( $id, &#x27;latitude&#x27;, true ), &#x27;lng&#x27; =&gt; get_post_meta( $id, &#x27;longitude&#x27;, true ) );

        if( $skip_existing == &#x27;true&#x27; &amp;&amp; !empty( $current_coordinates ) &amp;&amp; in_array( $address_is_formatted, array( &#x27;1&#x27;, &#x27;true&#x27; ) ) ) {
          $return[ &#x27;status&#x27; ] = &#x27;skipped&#x27;;

          return $return;
        }

        if( !( empty( $coordinates ) &amp;&amp; empty( $address ) ) ) {

          /* will be true if address is empty and used manual_coordinates and coordinates is not empty */
          $manual_coordinates = get_post_meta( $id, &#x27;manual_coordinates&#x27;, true );
          $manual_coordinates = ( $manual_coordinates != &#x27;true&#x27; &amp;&amp; $manual_coordinates != &#x27;1&#x27; ) ? false : true;

          $address_by_coordinates = !empty( $coordinates ) &amp;&amp; $manual_coordinates &amp;&amp; empty( $address );

          if( !empty( $address ) ) {
            $geo_data = Utility::geo_locate_address( $address, $wp_properties[ &#x27;configuration&#x27; ][ &#x27;google_maps_localization&#x27; ], true );
          }

          if( !empty( $coordinates ) &amp;&amp; $manual_coordinates ) {
            $geo_data_coordinates = Utility::geo_locate_address( $address, $wp_properties[ &#x27;configuration&#x27; ][ &#x27;google_maps_localization&#x27; ], true, $coordinates );
          }

          /** if Address was invalid or empty but we have valid $coordinates we use them */
          if( !empty( $geo_data_coordinates-&gt;formatted_address ) &amp;&amp; ( $address_by_coordinates || empty( $geo_data-&gt;formatted_address ) ) ) {
            $geo_data = $geo_data_coordinates;
            /** clean up $address to remember that addres was empty or invalid*/
            $address = &#x27;&#x27;;
          }

          if( empty( $geo_data ) ) {
            $return[ &#x27;status&#x27; ] = &#x27;empty_address&#x27;;
          }

        }

        if( !empty( $geo_data-&gt;formatted_address ) ) {

          foreach( (array) $wp_properties[ &#x27;geo_type_attributes&#x27; ] + array( &#x27;display_address&#x27; ) as $meta_key ) {
            delete_post_meta( $id, $meta_key );
          }

          update_post_meta( $id, &#x27;address_is_formatted&#x27;, true );

          if( !empty( $wp_properties[ &#x27;configuration&#x27; ][ &#x27;address_attribute&#x27; ] ) &amp;&amp; ( !$manual_coordinates || $address_by_coordinates ) ) {
            update_post_meta( $id, $wp_properties[ &#x27;configuration&#x27; ][ &#x27;address_attribute&#x27; ], Utility::encode_mysql_input( $geo_data-&gt;formatted_address, $wp_properties[ &#x27;configuration&#x27; ][ &#x27;address_attribute&#x27; ] ) );
          }

          foreach( $geo_data as $geo_type =&gt; $this_data ) {
            if( in_array( $geo_type, (array) $wp_properties[ &#x27;geo_type_attributes&#x27; ] ) &amp;&amp; !in_array( $geo_type, array( &#x27;latitude&#x27;, &#x27;longitude&#x27; ) ) ) {
              update_post_meta( $id, $geo_type, Utility::encode_mysql_input( $this_data, $geo_type ) );
            }
          }

          update_post_meta( $id, &#x27;wpp::last_address_validation&#x27;, time() );

          update_post_meta( $id, &#x27;latitude&#x27;, $manual_coordinates ? $coordinates[ &#x27;lat&#x27; ] : $geo_data-&gt;latitude );
          update_post_meta( $id, &#x27;longitude&#x27;, $manual_coordinates ? $coordinates[ &#x27;lng&#x27; ] : $geo_data-&gt;longitude );

          if( $return_geo_data ) {
            $return[ &#x27;geo_data&#x27; ] = $geo_data;
          }

          $return[ &#x27;status&#x27; ] = &#x27;updated&#x27;;

        }

        //** Logs the last validation status for better troubleshooting */
        update_post_meta( $id, &#x27;wpp::google_validation_status&#x27;, $geo_data-&gt;status );

        // Try to figure out what went wrong
        if( !empty( $geo_data-&gt;status ) &amp;&amp; ( $geo_data-&gt;status == &#x27;OVER_QUERY_LIMIT&#x27; || $geo_data-&gt;status == &#x27;REQUEST_DENIED&#x27; ) ) {
          $return[ &#x27;status&#x27; ] = &#x27;over_query_limit&#x27;;
        } elseif( empty( $address ) &amp;&amp; empty( $geo_data ) ) {

          foreach( (array) $wp_properties[ &#x27;geo_type_attributes&#x27; ] + array( &#x27;display_address&#x27; ) as $meta_key ) {
            delete_post_meta( $id, $meta_key );
          }

          $return[ &#x27;status&#x27; ] = &#x27;empty_address&#x27;;
          update_post_meta( $id, &#x27;address_is_formatted&#x27;, false );
        } elseif( empty( $return[ &#x27;status&#x27; ] ) ) {
          $return[ &#x27;status&#x27; ] = &#x27;failed&#x27;;
          update_post_meta( $id, &#x27;address_is_formatted&#x27;, false );
        }

        //** Neccessary meta data which is required by Supermap Premium Feature. Should be always set even the Supermap disabled. peshkov@UD */
        if( !metadata_exists( &#x27;post&#x27;, $id, &#x27;exclude_from_supermap&#x27; ) ) {
          add_post_meta( $id, &#x27;exclude_from_supermap&#x27;, &#x27;false&#x27; );
        }

        return $return;

      }

      /**
       * Updates parent ID.
       * Determines if parent exists and it doesn&#x27;t have own parent.
       *
       * @param integer $parent_id
       * @param integer $id
       *
       * @return int
       * @author peshkov@UD
       * @since 1.37.5
       */
      public static function update_parent_id( $parent_id, $id ) {
        global $wpdb, $wp_properties;

        $parent_id = !empty( $parent_id ) ? $parent_id : 0;

        $post = get_post( $_REQUEST[ &#x27;parent_id&#x27; ] );

        if( !$post ) {
          $parent_id = 0;
        } else {
          if( $post-&gt;post_parent &gt; 0 ) {
            if( empty( $wp_properties[ &#x27;configuration&#x27; ][ &#x27;allow_parent_deep_depth&#x27; ] ) || $wp_properties[ &#x27;configuration&#x27; ][ &#x27;allow_parent_deep_depth&#x27; ] != &#x27;true&#x27; ) {
              $parent_id = 0;
            }
          }
        }

        if( $parent_id == 0 ) {
          $wpdb-&gt;query( &quot;UPDATE {$wpdb-&gt;posts} SET post_parent=0 WHERE ID={$id}&quot; );
        }

        update_post_meta( $id, &#x27;parent_gpid&#x27;, self::maybe_set_gpid( $parent_id ) );

        return $parent_id;
      }

      /**
       * Generates Global Property ID for standard reference point during imports.
       *
       * Property ID is currently not used.
       *
       * @return integer. Global ID number
       *
       * @param bool|int $id . Property ID.
       *
       * @param bool     $check_existance
       *
       * @todo API call to UD server to verify there is no duplicates
       * @since 1.6
       */
      public static function get_gpid( $id = false, $check_existance = false ) {

        if( $check_existance &amp;&amp; $id ) {
          $exists = get_post_meta( $id, &#x27;wpp_gpid&#x27;, true );

          if( $exists ) {
            return $exists;
          }
        }

        return &#x27;gpid_&#x27; . rand( 1000000000, 9999999999 );

      }

      /**
       * Generates Global Property ID if it does not exist
       *
       * @param bool $id
       *
       * @return string | Returns GPID
       * @since 1.6
       */
      public static function maybe_set_gpid( $id = false ) {

        if( !$id ) {
          return false;
        }

        $exists = get_post_meta( $id, &#x27;wpp_gpid&#x27;, true );

        if( $exists ) {
          return $exists;
        }

        $gpid = self::get_gpid( $id, true );

        update_post_meta( $id, &#x27;wpp_gpid&#x27;, $gpid );

        return $gpid;

      }

      /**
       * Load property information into an array or an object
       *
       * @version 1.11 Added support for multiple meta values for a given key
       *
       * @since 1.11
       * @version 1.14 - fixed problem with drafts
       * @todo Code pertaining to displaying data should be migrated to prepare_property_for_display() like :$real_value = nl2br($real_value);
       * @todo Fix the long dashes - when in latitude or longitude it breaks it when using static map
       *
       */
      static function load( $id, $args = false ) {
        global $wp_properties, $wpdb;

        $id = trim( $id );

        extract( wp_parse_args( $args, array(
          &#x27;get_children&#x27;          =&gt; &#x27;true&#x27;,
          &#x27;return_object&#x27;         =&gt; &#x27;false&#x27;,
          &#x27;load_gallery&#x27;          =&gt; &#x27;true&#x27;,
          &#x27;load_thumbnail&#x27;        =&gt; &#x27;true&#x27;,
          &#x27;allow_multiple_values&#x27; =&gt; &#x27;false&#x27;,
          &#x27;load_parent&#x27;           =&gt; &#x27;true&#x27;
        )), EXTR_SKIP );

        $get_children          = isset( $get_children ) ? $get_children : &#x27;true&#x27;;
        $return_object         = isset( $return_object ) ? $return_object : &#x27;false&#x27;;
        $load_gallery          = isset( $load_gallery ) ? $load_gallery : &#x27;true&#x27;;
        $load_thumbnail        = isset( $load_thumbnail ) ? $load_thumbnail : &#x27;true&#x27;;
        $allow_multiple_values = isset( $allow_multiple_values ) ? $allow_multiple_values : &#x27;false&#x27;;
        $load_parent           = isset( $load_parent ) ? $load_parent : &#x27;true&#x27;;

        $args = is_array( $args ) ? http_build_query( $args ) : (string) $args;

        if( $return = wp_cache_get( $id . $args ) ) {
          return $return;
        }

        $post = get_post( $id, ARRAY_A );

        if( $post[ &#x27;post_type&#x27; ] != &#x27;property&#x27; ) {
          return false;
        }

        //** Figure out what all the editable attributes are, and get their keys */
        $wp_properties[ &#x27;property_meta&#x27; ]  = ( is_array( $wp_properties[ &#x27;property_meta&#x27; ] ) ? $wp_properties[ &#x27;property_meta&#x27; ] : array() );
        $wp_properties[ &#x27;property_stats&#x27; ] = ( is_array( $wp_properties[ &#x27;property_stats&#x27; ] ) ? $wp_properties[ &#x27;property_stats&#x27; ] : array() );
        $editable_keys                     = array_keys( array_merge( $wp_properties[ &#x27;property_meta&#x27; ], $wp_properties[ &#x27;property_stats&#x27; ] ) );

        $return = array();

        //** Load all meta keys for this object */
        if( $keys = get_post_custom( $id ) ) {
          foreach( $keys as $key =&gt; $value ) {

            if( $allow_multiple_values == &#x27;false&#x27; ) {
              $value = $value[ 0 ];
            }

            $keyt = trim( $key );

            //** If has _ prefix it&#x27;s a built-in WP key */
            if( &#x27;_&#x27; == $keyt{0} ) {
              continue;
            }

            // Fix for boolean values
            switch( $value ) {

              case &#x27;true&#x27;:
                $real_value = true; //** Converts all &quot;true&quot; to 1 */
                break;

              case &#x27;false&#x27;:
                $real_value = false;
                break;

              default:
                $real_value = $value;
                break;

            }

            // Handle keys with multiple values
            if( count( $value ) &gt; 1 ) {
              $return[ $key ] = $value;
            } else {
              $return[ $key ] = $real_value;
            }

          }
        }

        $return = array_merge( $return, $post );

        //** Make sure certain keys were not messed up by custom attributes */
        $return[ &#x27;system&#x27; ]  = array();
        $return[ &#x27;gallery&#x27; ] = array();

        // Figure out what the thumbnail is, and load all sizes
        if( $load_thumbnail == &#x27;true&#x27; ) {

          $wp_image_sizes = \get_intermediate_image_sizes();

          $thumbnail_id = \get_post_meta( $id, &#x27;_thumbnail_id&#x27;, true );
          $attachments  = \get_children( array( &#x27;post_parent&#x27; =&gt; $id, &#x27;post_type&#x27; =&gt; &#x27;attachment&#x27;, &#x27;post_mime_type&#x27; =&gt; &#x27;image&#x27;, &#x27;orderby&#x27; =&gt; &#x27;menu_order ASC, ID&#x27;, &#x27;order&#x27; =&gt; &#x27;DESC&#x27; ) );

          if( $thumbnail_id ) {
            foreach( $wp_image_sizes as $image_name ) {
              $this_url                          = wp_get_attachment_image_src( $thumbnail_id, $image_name, true );
              $return[ &#x27;images&#x27; ][ $image_name ] = $this_url[ 0 ];
            }

            $featured_image_id = $thumbnail_id;

          } elseif( $attachments ) {
            foreach( $attachments as $attachment_id =&gt; $attachment ) {

              foreach( $wp_image_sizes as $image_name ) {
                $this_url                          = wp_get_attachment_image_src( $attachment_id, $image_name, true );
                $return[ &#x27;images&#x27; ][ $image_name ] = $this_url[ 0 ];
              }

              $featured_image_id = $attachment_id;
              break;
            }
          }

          if( $featured_image_id ) {
            $return[ &#x27;featured_image&#x27; ] = $featured_image_id;

            $image_title = $wpdb-&gt;get_var( &quot;SELECT post_title  FROM {$wpdb-&gt;prefix}posts WHERE ID = &#x27;{$featured_image_id}&#x27; &quot; );

            $return[ &#x27;featured_image_title&#x27; ] = $image_title;
            $return[ &#x27;featured_image_url&#x27; ]   = wp_get_attachment_url( $featured_image_id );
          }

        }

        // Load all attached images and their sizes
        if( $load_gallery == &#x27;true&#x27; ) {

          // Get gallery images
          if( $attachments ) {
            foreach( $attachments as $attachment_id =&gt; $attachment ) {
              $return[ &#x27;gallery&#x27; ][ $attachment-&gt;post_name ][ &#x27;post_title&#x27; ]    = $attachment-&gt;post_title;
              $return[ &#x27;gallery&#x27; ][ $attachment-&gt;post_name ][ &#x27;post_excerpt&#x27; ]  = $attachment-&gt;post_excerpt;
              $return[ &#x27;gallery&#x27; ][ $attachment-&gt;post_name ][ &#x27;post_content&#x27; ]  = $attachment-&gt;post_content;
              $return[ &#x27;gallery&#x27; ][ $attachment-&gt;post_name ][ &#x27;attachment_id&#x27; ] = $attachment_id;
              foreach( $wp_image_sizes as $image_name ) {
                $this_url                                                     = wp_get_attachment_image_src( $attachment_id, $image_name, true );
                $return[ &#x27;gallery&#x27; ][ $attachment-&gt;post_name ][ $image_name ] = $this_url[ 0 ];
              }
            }
          } else {
            $return[ &#x27;gallery&#x27; ] = false;
          }
        }

        // Load parent if exists and inherit Parent&#x27;s atttributes.
        if( $load_parent == &#x27;true&#x27; &amp;&amp; $post[ &#x27;post_parent&#x27; ] ) {

          $return[ &#x27;is_child&#x27; ] = true;

          $parent_object = self::load( $post[ &#x27;post_parent&#x27; ], array( &#x27;load_gallery&#x27; =&gt; $load_gallery, &#x27;get_children&#x27; =&gt; false ) );

          $return[ &#x27;parent_id&#x27; ]    = $post[ &#x27;post_parent&#x27; ];
          $return[ &#x27;parent_link&#x27; ]  = $parent_object[ &#x27;permalink&#x27; ];
          $return[ &#x27;parent_title&#x27; ] = $parent_object[ &#x27;post_title&#x27; ];

          // Inherit things
          if( is_array( $wp_properties[ &#x27;property_inheritance&#x27; ][ $return[ &#x27;property_type&#x27; ] ] ) ) {
            foreach( $wp_properties[ &#x27;property_inheritance&#x27; ][ $return[ &#x27;property_type&#x27; ] ] as $inherit_attrib ) {
              if( !empty( $parent_object[ $inherit_attrib ] ) &amp;&amp; empty( $return[ $inherit_attrib ] ) ) {
                $return[ $inherit_attrib ] = $parent_object[ $inherit_attrib ];
              }
            }
          }
        }

        // Load Children and their attributes
        if( $get_children == &#x27;true&#x27; ) {

          //** Calculate variables if based off children if children exist */
          $children = $wpdb-&gt;get_col( &quot;SELECT ID FROM {$wpdb-&gt;posts} WHERE  post_type = &#x27;property&#x27; AND post_status = &#x27;publish&#x27; AND post_parent = &#x27;{$id}&#x27; ORDER BY menu_order ASC &quot; );

          if( count( $children ) &gt; 0 ) {

            //** Cycle through children and get necessary variables */
            foreach( $children as $child_id ) {

              $child_object                      = self::load( $child_id, array( &#x27;load_gallery&#x27; =&gt; $load_gallery, &#x27;load_parent&#x27; =&gt; false ) );
              $return[ &#x27;children&#x27; ][ $child_id ] = $child_object;

              //** Save child image URLs into one array for quick access */
              if( !empty( $child_object[ &#x27;featured_image_url&#x27; ] ) ) {
                $return[ &#x27;system&#x27; ][ &#x27;child_images&#x27; ][ $child_id ] = $child_object[ &#x27;featured_image_url&#x27; ];
              }

              //** Exclude variables from searchable attributes (to prevent ranges) */
              $excluded_attributes    = $wp_properties[ &#x27;geo_type_attributes&#x27; ];
              $excluded_attributes[ ] = $wp_properties[ &#x27;configuration&#x27; ][ &#x27;address_attribute&#x27; ];

              foreach( $wp_properties[ &#x27;searchable_attributes&#x27; ] as $searchable_attribute ) {

                $attribute_data = Utility::get_attribute_data( $searchable_attribute );

                if( $attribute_data[ &#x27;numeric&#x27; ] || $attribute_data[ &#x27;currency&#x27; ] ) {

                  if( !empty( $child_object[ $searchable_attribute ] ) &amp;&amp; !in_array( $searchable_attribute, $excluded_attributes ) ) {
                    $range[ $searchable_attribute ][ ] = $child_object[ $searchable_attribute ];
                  }

                }
              }
            }

            //* Cycle through every type of range (i.e. price, deposit, bathroom, etc) and fix-up the respective data arrays */
            foreach( (array) $range as $range_attribute =&gt; $range_values ) {

              //* Cycle through all values of this range (attribute), and fix any ranges that use dashes */
              foreach( $range_values as $key =&gt; $single_value ) {

                //* Remove dollar signs */
                $single_value = str_replace( &quot;$&quot;, &#x27;&#x27;, $single_value );

                //* Fix ranges */
                if( strpos( $single_value, &#x27;&amp;ndash;&#x27; ) ) {

                  $split = explode( &#x27;&amp;ndash;&#x27;, $single_value );

                  foreach( $split as $new_single_value )

                    if( !empty( $new_single_value ) ) {
                      array_push( $range_values, trim( $new_single_value ) );
                    }

                  //* Unset original value with dash */
                  unset( $range_values[ $key ] );

                }
              }

              //* Remove duplicate values from this range */
              $range[ $range_attribute ] = array_unique( $range_values );

              //* Sort the values in this particular range */
              sort( $range[ $range_attribute ] );

              if( count( $range[ $range_attribute ] ) &lt; 2 ) {
                $return[ $range_attribute ] = $return[ $range_attribute ] . &#x27; ( &#x27; . $range[ $range_attribute ][ 0 ] . &#x27; )&#x27;;
              }

              if( count( $range[ $range_attribute ] ) &gt; 1 ) {
                $return[ $range_attribute ] = $return[ $range_attribute ] . &#x27; ( &#x27; . min( $range[ $range_attribute ] ) . &quot; - &quot; . max( $range[ $range_attribute ] ) . &#x27; )&#x27;;
              }

              //** If we end up with a range, we make a note of it */
              if( !empty( $return[ $range_attribute ] ) ) {
                $return[ &#x27;system&#x27; ][ &#x27;upwards_inherited_attributes&#x27; ][ ] = $range_attribute;
              }

            }

          }
        }

        if( !empty( $return[ &#x27;location&#x27; ] ) &amp;&amp; !in_array( &#x27;address&#x27;, $editable_keys ) &amp;&amp; !isset( $return[ &#x27;address&#x27; ] ) ) {
          $return[ &#x27;address&#x27; ] = $return[ &#x27;location&#x27; ];
        }

        $return[ &#x27;wpp_gpid&#x27; ]  = self::maybe_set_gpid( $id );

        $return[ &#x27;permalink&#x27; ] = get_permalink( $id );

        //** Make sure property_type stays as slug, or it will break many things:  (widgets, class names, etc)  */
        $return[ &#x27;property_type_label&#x27; ] = $wp_properties[ &#x27;property_types&#x27; ][ $return[ &#x27;property_type&#x27; ] ];

        if( empty( $return[ &#x27;property_type_label&#x27; ] ) ) {
          foreach( $wp_properties[ &#x27;property_types&#x27; ] as $pt_key =&gt; $pt_value ) {
            if( strtolower( $pt_value ) == strtolower( $return[ &#x27;property_type&#x27; ] ) ) {
              $return[ &#x27;property_type&#x27; ]       = $pt_key;
              $return[ &#x27;property_type_label&#x27; ] = $pt_value;
            }
          }
        }

        //** If phone number is not set but set globally, we load it into property array here */
        if( empty( $return[ &#x27;phone_number&#x27; ] ) &amp;&amp; !empty( $wp_properties[ &#x27;configuration&#x27; ][ &#x27;phone_number&#x27; ] ) ) {
          $return[ &#x27;phone_number&#x27; ] = $wp_properties[ &#x27;configuration&#x27; ][ &#x27;phone_number&#x27; ];
        }

        if( is_array( $return ) ) {
          ksort( $return );
        }

        $return = apply_filters( &#x27;wpp_get_property&#x27;, $return );
        $return = apply_filters( &#x27;wpp:get_property&#x27;, $return );

        //* Get rid of all empty values */
        foreach( $return as $key =&gt; $item ) {

          //** Don&#x27;t blank keys starting w/ post_  - this should be converted to use get_attribute_data() to check where data is stored for better check - potanin@UD */
          if( strpos( $key, &#x27;post_&#x27; ) === 0 ) {
            continue;
          }

          if( empty( $item ) ) {
            unset( $return[ $key ] );
          }

        }

        //** Convert to object */
        if( $return_object == &#x27;true&#x27; ) {
          $return = Utility::array_to_object( $return );
        }

        wp_cache_add( $id . $args, $return );

        return $return;

      }

    }

  }

}




    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
